<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module CSE</title>
<meta name="description" content="Documentation of Coq module CSE" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module CSE</h1>
<div class="coq">
<br/>
<div class="doc">Common subexpression elimination over RTL.  This optimization
  proceeds by value numbering over extended basic blocks. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Errors</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">Lattice</span> <span class="id">Kildall</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Registers</span> <span class="id">RTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValueDomain</span> <span class="id">ValueAnalysis</span> <span class="id">CSEdomain</span> <span class="id">CombineOp</span>.<br/>
<br/>
<div class="doc">The idea behind value numbering algorithms is to associate
  abstract identifiers (``value numbers'') to the contents of registers
  at various program points, and record equations between these
  identifiers.  For instance, consider the instruction
  <span class="bracket"><span class="id">r1</span> = <span class="id">add</span>(<span class="id">r2</span>, <span class="id">r3</span>)</span> and assume that <span class="bracket"><span class="id">r2</span></span> and <span class="bracket"><span class="id">r3</span></span> are mapped
  to abstract identifiers <span class="bracket"><span class="id">x</span></span> and <span class="bracket"><span class="id">y</span></span> respectively at the program
  point just before this instruction.  At the program point just after,
  we can add the equation <span class="bracket"><span class="id">z</span> = <span class="id">add</span>(<span class="id">x</span>, <span class="id">y</span>)</span> and associate <span class="bracket"><span class="id">r1</span></span> with <span class="bracket"><span class="id">z</span></span>,
  where <span class="bracket"><span class="id">z</span></span> is a fresh abstract identifier.  However, if we already
  knew an equation <span class="bracket"><span class="id">u</span> = <span class="id">add</span>(<span class="id">x</span>, <span class="id">y</span>)</span>, we can preferably add no equation
  and just associate <span class="bracket"><span class="id">r1</span></span> with <span class="bracket"><span class="id">u</span></span>.  If there exists a register <span class="bracket"><span class="id">r4</span></span>
  mapped with <span class="bracket"><span class="id">u</span></span> at this point, we can then replace the instruction
  <span class="bracket"><span class="id">r1</span> = <span class="id">add</span>(<span class="id">r2</span>, <span class="id">r3</span>)</span> by a move instruction <span class="bracket"><span class="id">r1</span> = <span class="id">r4</span></span>, therefore eliminating
  a common subexpression and reusing the result of an earlier addition.
  The representation of value numbers and equations is described in
  module <span class="bracket"><span class="id">CSEdomain</span></span>. </div>
<br/>
<h1> Operations on value numberings </h1>
<br/>
<div class="doc"><span class="bracket"><span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">r</span></span> returns the value number for the contents of
  register <span class="bracket"><span class="id">r</span></span>.  If none exists, a fresh value number is returned
  and associated with register <span class="bracket"><span class="id">r</span></span>.  The possibly updated numbering
  is also returned.  <span class="bracket"><span class="id">valnum_regs</span></span> is similar, but for a list of
  registers. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">valnum_reg</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">r</span>: <span class="id">reg</span>) : <span class="id">numbering</span> * <span class="id">valnum</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">PTree.get</span> <span class="id">r</span> <span class="id">n</span>.(<span class="id">num_reg</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">v</span> =&gt; (<span class="id">n</span>, <span class="id">v</span>)<br/>
&nbsp;&nbsp;| <span class="id">None</span>   =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">v</span> := <span class="id">n</span>.(<span class="id">num_next</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( {| <span class="id">num_next</span> := <span class="id">Psucc</span> <span class="id">v</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">n</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">PTree.set</span> <span class="id">r</span> <span class="id">v</span> <span class="id">n</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">PMap.set</span> <span class="id">v</span> (<span class="id">r</span> :: <span class="id">nil</span>) <span class="id">n</span>.(<span class="id">num_val</span>) |},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">v</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">valnum_regs</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rl</span>: <span class="id">list</span> <span class="id">reg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">rl</span>} : <span class="id">numbering</span> * <span class="id">list</span> <span class="id">valnum</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">rl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">n</span>, <span class="id">nil</span>)<br/>
&nbsp;&nbsp;| <span class="id">r1</span> :: <span class="id">rs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">v1</span>) := <span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">r1</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">ns</span>, <span class="id">vs</span>) := <span class="id">valnum_regs</span> <span class="id">n1</span> <span class="id">rs</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ns</span>, <span class="id">v1</span> :: <span class="id">vs</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">find_valnum_rhs</span> <span class="id">rhs</span> <span class="id">eqs</span></span> searches the list of equations <span class="bracket"><span class="id">eqs</span></span>
  for an equation of the form <span class="bracket"><span class="id">vn</span> = <span class="id">rhs</span></span> for some value number <span class="bracket"><span class="id">vn</span></span>.
  If found, <span class="bracket"><span class="id">Some</span> <span class="id">vn</span></span> is returned, otherwise <span class="bracket"><span class="id">None</span></span> is returned. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">find_valnum_rhs</span> (<span class="id">r</span>: <span class="id">rhs</span>) (<span class="id">eqs</span>: <span class="id">list</span> <span class="id">equation</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">eqs</span>} : <span class="id">option</span> <span class="id">valnum</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">eqs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Eq</span> <span class="id">v</span> <span class="id">str</span> <span class="id">r</span>' :: <span class="id">eqs1</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">str</span> &amp;&amp; <span class="id">eq_rhs</span> <span class="id">r</span> <span class="id">r</span>' <span class="kwd">then</span> <span class="id">Some</span> <span class="id">v</span> <span class="kwd">else</span> <span class="id">find_valnum_rhs</span> <span class="id">r</span> <span class="id">eqs1</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">find_valnum_rhs</span>' <span class="id">rhs</span> <span class="id">eqs</span></span> is similar, but also accepts equations
  of the form <span class="bracket"><span class="id">vn</span> &gt;= <span class="id">rhs</span></span>. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">find_valnum_rhs</span>' (<span class="id">r</span>: <span class="id">rhs</span>) (<span class="id">eqs</span>: <span class="id">list</span> <span class="id">equation</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">eqs</span>} : <span class="id">option</span> <span class="id">valnum</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">eqs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Eq</span> <span class="id">v</span> <span class="id">str</span> <span class="id">r</span>' :: <span class="id">eqs1</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">eq_rhs</span> <span class="id">r</span> <span class="id">r</span>' <span class="kwd">then</span> <span class="id">Some</span> <span class="id">v</span> <span class="kwd">else</span> <span class="id">find_valnum_rhs</span>' <span class="id">r</span> <span class="id">eqs1</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">find_valnum_num</span> <span class="id">vn</span> <span class="id">eqs</span></span> searches the list of equations <span class="bracket"><span class="id">eqs</span></span>
  for an equation of the form <span class="bracket"><span class="id">vn</span> = <span class="id">rhs</span></span> for some equation <span class="bracket"><span class="id">rhs</span></span>.
  If found, <span class="bracket"><span class="id">Some</span> <span class="id">rhs</span></span> is returned, otherwise <span class="bracket"><span class="id">None</span></span> is returned. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">find_valnum_num</span> (<span class="id">v</span>: <span class="id">valnum</span>) (<span class="id">eqs</span>: <span class="id">list</span> <span class="id">equation</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">eqs</span>} : <span class="id">option</span> <span class="id">rhs</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">eqs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Eq</span> <span class="id">v</span>' <span class="id">str</span> <span class="id">r</span>' :: <span class="id">eqs1</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">str</span> &amp;&amp; <span class="id">peq</span> <span class="id">v</span> <span class="id">v</span>' <span class="kwd">then</span> <span class="id">Some</span> <span class="id">r</span>' <span class="kwd">else</span> <span class="id">find_valnum_num</span> <span class="id">v</span> <span class="id">eqs1</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">reg_valnum</span> <span class="id">n</span> <span class="id">vn</span></span> returns a register that is mapped to value number
    <span class="bracket"><span class="id">vn</span></span>, or <span class="bracket"><span class="id">None</span></span> if no such register exists. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">reg_valnum</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">vn</span>: <span class="id">valnum</span>) : <span class="id">option</span> <span class="id">reg</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">PMap.get</span> <span class="id">vn</span> <span class="id">n</span>.(<span class="id">num_val</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">r</span> :: <span class="id">rs</span> =&gt; <span class="id">Some</span> <span class="id">r</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">regs_valnums</span></span> is similar, for a list of value numbers. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">regs_valnums</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">vl</span>: <span class="id">list</span> <span class="id">valnum</span>) : <span class="id">option</span> (<span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">vl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">Some</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">v1</span> :: <span class="id">vs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">reg_valnum</span> <span class="id">n</span> <span class="id">v1</span>, <span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r1</span>, <span class="id">Some</span> <span class="id">rs</span> =&gt; <span class="id">Some</span> (<span class="id">r1</span> :: <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">find_rhs</span></span> return a register that already holds the result of the
    given arithmetic operation or memory load, or a value more defined
    than this result, according to the given
    numbering.  <span class="bracket"><span class="id">None</span></span> is returned if no such register exists. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">find_rhs</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rh</span>: <span class="id">rhs</span>) : <span class="id">option</span> <span class="id">reg</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_valnum_rhs</span>' <span class="id">rh</span> <span class="id">n</span>.(<span class="id">num_eqs</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">vres</span> =&gt; <span class="id">reg_valnum</span> <span class="id">n</span> <span class="id">vres</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Update the <span class="bracket"><span class="id">num_val</span></span> mapping prior to a redefinition of register <span class="bracket"><span class="id">r</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">forget_reg</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>) : <span class="id">PMap.t</span> (<span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">PTree.get</span> <span class="id">rd</span> <span class="id">n</span>.(<span class="id">num_reg</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">n</span>.(<span class="id">num_val</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">v</span> =&gt; <span class="id">PMap.set</span> <span class="id">v</span> (<span class="id">List.remove</span> <span class="id">peq</span> <span class="id">rd</span> (<span class="id">PMap.get</span> <span class="id">v</span> <span class="id">n</span>.(<span class="id">num_val</span>))) <span class="id">n</span>.(<span class="id">num_val</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">update_reg</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>) (<span class="id">vn</span>: <span class="id">valnum</span>) : <span class="id">PMap.t</span> (<span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">nv</span> := <span class="id">forget_reg</span> <span class="id">n</span> <span class="id">rd</span> <span class="kwd">in</span> <span class="id">PMap.set</span> <span class="id">vn</span> (<span class="id">rd</span> :: <span class="id">PMap.get</span> <span class="id">vn</span> <span class="id">nv</span>) <span class="id">nv</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">add_rhs</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">rhs</span></span> updates the value numbering <span class="bracket"><span class="id">n</span></span> to reflect
  the computation of the operation or load represented by <span class="bracket"><span class="id">rhs</span></span>
  and the storing of the result in register <span class="bracket"><span class="id">rd</span></span>.  If an equation
  <span class="bracket"><span class="id">vn</span> = <span class="id">rhs</span></span> is known, register <span class="bracket"><span class="id">rd</span></span> is set to <span class="bracket"><span class="id">vn</span></span>.  Otherwise,
  a fresh value number <span class="bracket"><span class="id">vn</span></span> is generated and associated with <span class="bracket"><span class="id">rd</span></span>,
  and the equation <span class="bracket"><span class="id">vn</span> = <span class="id">rhs</span></span> is added. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">add_rhs</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>) (<span class="id">rh</span>: <span class="id">rhs</span>) : <span class="id">numbering</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_valnum_rhs</span> <span class="id">rh</span> <span class="id">n</span>.(<span class="id">num_eqs</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">vres</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">n</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">PTree.set</span> <span class="id">rd</span> <span class="id">vres</span> <span class="id">n</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">update_reg</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">vres</span> |}<br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">Psucc</span> <span class="id">n</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">Eq</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">true</span> <span class="id">rh</span> :: <span class="id">n</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">PTree.set</span> <span class="id">rd</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">n</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">update_reg</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">n</span>.(<span class="id">num_next</span>) |}<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">add_op</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">op</span> <span class="id">rs</span></span> specializes <span class="bracket"><span class="id">add_rhs</span></span> for the case of an
  arithmetic operation.  The right-hand side corresponding to <span class="bracket"><span class="id">op</span></span>
  and the value numbers for the argument registers <span class="bracket"><span class="id">rs</span></span> is built
  and added to <span class="bracket"><span class="id">n</span></span> as described in <span class="bracket"><span class="id">add_rhs</span></span>.
  If <span class="bracket"><span class="id">op</span></span> is a move instruction, we simply assign the value number of
  the source register to the destination register, since we know that
  the source and destination registers have exactly the same value.
  This enables more common subexpressions to be recognized. For instance:
<pre>
     z = add(x, y);  u = x; v = add(u, y);</pre>
  Since <span class="bracket"><span class="id">u</span></span> and <span class="bracket"><span class="id">x</span></span> have the same value number, the second <span class="bracket"><span class="id">add</span></span>
  is recognized as computing the same result as the first <span class="bracket"><span class="id">add</span></span>,
  and therefore <span class="bracket"><span class="id">u</span></span> and <span class="bracket"><span class="id">z</span></span> have the same value number. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">add_op</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>) (<span class="id">op</span>: <span class="id">operation</span>) (<span class="id">rs</span>: <span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">is_move_operation</span> <span class="id">op</span> <span class="id">rs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">v</span>) := <span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">r</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n1</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">n1</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">PTree.set</span> <span class="id">rd</span> <span class="id">v</span> <span class="id">n1</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">update_reg</span> <span class="id">n1</span> <span class="id">rd</span> <span class="id">v</span> |}<br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vs</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">rs</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">add_rhs</span> <span class="id">n1</span> <span class="id">rd</span> (<span class="id">Op</span> <span class="id">op</span> <span class="id">vs</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">add_load</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">rs</span></span> specializes <span class="bracket"><span class="id">add_rhs</span></span> for the case of a
  memory load.  The right-hand side corresponding to <span class="bracket"><span class="id">chunk</span></span>, <span class="bracket"><span class="id">addr</span></span>
  and the value numbers for the argument registers <span class="bracket"><span class="id">rs</span></span> is built
  and added to <span class="bracket"><span class="id">n</span></span> as described in <span class="bracket"><span class="id">add_rhs</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">add_load</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">memory_chunk</span>) (<span class="id">addr</span>: <span class="id">addressing</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rs</span>: <span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vs</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">rs</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">add_rhs</span> <span class="id">n1</span> <span class="id">rd</span> (<span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vs</span>).<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">set_unknown</span> <span class="id">n</span> <span class="id">rd</span></span> returns a numbering where <span class="bracket"><span class="id">rd</span></span> is mapped to
  no value number, and no equations are added.  This is useful
  to model instructions with unpredictable results such as <span class="bracket"><span class="id">Ibuiltin</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">set_unknown</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">rd</span>: <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">n</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">PTree.remove</span> <span class="id">rd</span> <span class="id">n</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">forget_reg</span> <span class="id">n</span> <span class="id">rd</span> |}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">set_res_unknown</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">res</span>: <span class="id">builtin_res</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">res</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BR</span> <span class="id">r</span> =&gt; <span class="id">set_unknown</span> <span class="id">n</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">_</span>    =&gt; <span class="id">n</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">kill_equations</span> <span class="id">pred</span> <span class="id">n</span></span> remove all equations satisfying predicate <span class="bracket"><span class="id">pred</span></span>. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">kill_eqs</span> (<span class="id">pred</span>: <span class="id">rhs</span> -&gt; <span class="id">bool</span>) (<span class="id">eqs</span>: <span class="id">list</span> <span class="id">equation</span>) : <span class="id">list</span> <span class="id">equation</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">eqs</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">Eq</span> <span class="id">l</span> <span class="id">strict</span> <span class="id">r</span>) <span class="kwd">as</span> <span class="id">eq</span> :: <span class="id">rem</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">pred</span> <span class="id">r</span> <span class="kwd">then</span> <span class="id">kill_eqs</span> <span class="id">pred</span> <span class="id">rem</span> <span class="kwd">else</span> <span class="id">eq</span> :: <span class="id">kill_eqs</span> <span class="id">pred</span> <span class="id">rem</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kill_equations</span> (<span class="id">pred</span>: <span class="id">rhs</span> -&gt; <span class="id">bool</span>) (<span class="id">n</span>: <span class="id">numbering</span>) : <span class="id">numbering</span> :=<br/>
&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">kill_eqs</span> <span class="id">pred</span> <span class="id">n</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">n</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">n</span>.(<span class="id">num_val</span>) |}.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">kill_all_loads</span> <span class="id">n</span></span> removes all equations involving memory loads,
  as well as those involving memory-dependent operators.
  It is used to reflect the effect of a builtin operation, which can
  change memory in unpredictable ways and potentially invalidate all such equations. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">filter_loads</span> (<span class="id">r</span>: <span class="id">rhs</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">r</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Op</span> <span class="id">op</span> <span class="id">_</span> =&gt; <span class="id">op_depends_on_memory</span> <span class="id">op</span><br/>
&nbsp;&nbsp;| <span class="kwd">Load</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kill_all_loads</span> (<span class="id">n</span>: <span class="id">numbering</span>) : <span class="id">numbering</span> :=<br/>
&nbsp;&nbsp;<span class="id">kill_equations</span> <span class="id">filter_loads</span> <span class="id">n</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">kill_loads_after_store</span> <span class="id">app</span> <span class="id">n</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span></span> removes all equations
  involving loads that could be invalidated by a store of quantity <span class="bracket"><span class="id">chunk</span></span>
  at address determined by <span class="bracket"><span class="id">addr</span></span> and <span class="bracket"><span class="id">args</span></span>.  Loads that are disjoint
  from this store are preserved.  Equations involving memory-dependent
  operators are also removed. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">filter_after_store</span> (<span class="id">app</span>: <span class="id">VA.t</span>) (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">p</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) (<span class="id">r</span>: <span class="id">rhs</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">r</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Op</span> <span class="id">op</span> <span class="id">vl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">op_depends_on_memory</span> <span class="id">op</span><br/>
&nbsp;&nbsp;| <span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">rl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">negb</span> (<span class="id">pdisjoint</span> (<span class="id">aaddressing</span> <span class="id">app</span> <span class="id">addr</span> <span class="id">rl</span>) (<span class="id">size_chunk</span> <span class="id">chunk</span>) <span class="id">p</span> <span class="id">sz</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kill_loads_after_store</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">app</span>: <span class="id">VA.t</span>) (<span class="id">n</span>: <span class="id">numbering</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">chunk</span>: <span class="id">memory_chunk</span>) (<span class="id">addr</span>: <span class="id">addressing</span>) (<span class="id">args</span>: <span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">p</span> := <span class="id">aaddressing</span> <span class="id">app</span> <span class="id">addr</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">kill_equations</span> (<span class="id">filter_after_store</span> <span class="id">app</span> <span class="id">n</span> <span class="id">p</span> (<span class="id">size_chunk</span> <span class="id">chunk</span>)) <span class="id">n</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">add_store_result</span> <span class="id">n</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">rargs</span> <span class="id">rsrc</span></span> updates the numbering <span class="bracket"><span class="id">n</span></span>
  to reflect the knowledge gained after executing an instruction
  <span class="bracket"><span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">rargs</span> <span class="id">rsrc</span></span>.  An equation <span class="bracket"><span class="id">vsrc</span> &gt;= <span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vargs</span></span>
  is added, but only if the value of <span class="bracket"><span class="id">rsrc</span></span> is known to be normalized
  with respect to <span class="bracket"><span class="id">chunk</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">store_normalized_range</span> (<span class="id">chunk</span>: <span class="id">memory_chunk</span>) : <span class="id">aval</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">chunk</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Mint8signed</span> =&gt; <span class="id">Sgn</span> <span class="id">Ptop</span> 8<br/>
&nbsp;&nbsp;| <span class="id">Mint8unsigned</span> =&gt; <span class="id">Uns</span> <span class="id">Ptop</span> 8<br/>
&nbsp;&nbsp;| <span class="id">Mint16signed</span> =&gt; <span class="id">Sgn</span> <span class="id">Ptop</span> 16<br/>
&nbsp;&nbsp;| <span class="id">Mint16unsigned</span> =&gt; <span class="id">Uns</span> <span class="id">Ptop</span> 16<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">Vtop</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">add_store_result</span> (<span class="id">app</span>: <span class="id">VA.t</span>) (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">chunk</span>: <span class="id">memory_chunk</span>) (<span class="id">addr</span>: <span class="id">addressing</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rargs</span>: <span class="id">list</span> <span class="id">reg</span>) (<span class="id">rsrc</span>: <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">vincl</span> (<span class="id">avalue</span> <span class="id">app</span> <span class="id">rsrc</span>) (<span class="id">store_normalized_range</span> <span class="id">chunk</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vsrc</span>) := <span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">rsrc</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n2</span>, <span class="id">vargs</span>) := <span class="id">valnum_regs</span> <span class="id">n1</span> <span class="id">rargs</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n2</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">Eq</span> <span class="id">vsrc</span> <span class="id">false</span> (<span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vargs</span>) :: <span class="id">n2</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">n2</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">n2</span>.(<span class="id">num_val</span>) |}<br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">n</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">kill_loads_after_storebyte</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">sz</span></span> removes all equations
  involving loads that could be invalidated by a store of <span class="bracket"><span class="id">sz</span></span> bytes
  starting at address <span class="bracket"><span class="id">dst</span></span>. Loads that are disjoint from this
  store-bytes are preserved.  Equations involving memory-dependent
  operators are also removed. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">kill_loads_after_storebytes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">app</span>: <span class="id">VA.t</span>) (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">dst</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) :=<br/>
&nbsp;&nbsp;<span class="id">kill_equations</span> (<span class="id">filter_after_store</span> <span class="id">app</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">sz</span>) <span class="id">n</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">add_memcpy</span> <span class="id">app</span> <span class="id">n1</span> <span class="id">n2</span> <span class="id">rsrc</span> <span class="id">rdst</span> <span class="id">sz</span></span> adds equations to <span class="bracket"><span class="id">n2</span></span> that
  represent the effect of a <span class="bracket"><span class="id">memcpy</span></span> block copy operation of <span class="bracket"><span class="id">sz</span></span> bytes
  from the address denoted by <span class="bracket"><span class="id">rsrc</span></span> to the address denoted by <span class="bracket"><span class="id">rdst</span></span>.
  <span class="bracket"><span class="id">n2</span></span> is the numbering returned by <span class="bracket"><span class="id">kill_loads_after_storebytes</span></span>
  and <span class="bracket"><span class="id">n1</span></span> is the original numbering before the <span class="bracket"><span class="id">memcpy</span></span> operation.
  Valid equations (found in <span class="bracket"><span class="id">n1</span></span>) involving loads within the source
  area of the <span class="bracket"><span class="id">memcpy</span></span> are translated as equations involving loads
  within the destination area, and added to numbering <span class="bracket"><span class="id">n2</span></span>.
  Currently, we only track <span class="bracket"><span class="id">memcpy</span></span> operations between stack
  locations, as often occur when compiling assignments between local C
  variables of struct type. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">shift_memcpy_eq</span> (<span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span>: <span class="id">Z</span>) (<span class="id">e</span>: <span class="id">equation</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">e</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Eq</span> <span class="id">l</span> <span class="id">strict</span> (<span class="kwd">Load</span> <span class="id">chunk</span> (<span class="id">Ainstack</span> <span class="id">i</span>) <span class="id">_</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">i</span> := <span class="id">Ptrofs.unsigned</span> <span class="id">i</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">j</span> := <span class="id">i</span> + <span class="id">delta</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">zle</span> <span class="id">src</span> <span class="id">i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">zle</span> (<span class="id">i</span> + <span class="id">size_chunk</span> <span class="id">chunk</span>) (<span class="id">src</span> + <span class="id">sz</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">zeq</span> (<span class="id">Zmod</span> <span class="id">delta</span> (<span class="id">align_chunk</span> <span class="id">chunk</span>)) 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">zle</span> 0 <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; <span class="id">zle</span> <span class="id">j</span> <span class="id">Ptrofs.max_unsigned</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">Some</span>(<span class="id">Eq</span> <span class="id">l</span> <span class="id">strict</span> (<span class="kwd">Load</span> <span class="id">chunk</span> (<span class="id">Ainstack</span> (<span class="id">Ptrofs.repr</span> <span class="id">j</span>)) <span class="id">nil</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">add_memcpy_eqs</span> (<span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span>: <span class="id">Z</span>) (<span class="id">eqs1</span> <span class="id">eqs2</span>: <span class="id">list</span> <span class="id">equation</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">eqs1</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">eqs2</span><br/>
&nbsp;&nbsp;| <span class="id">e</span> :: <span class="id">eqs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">shift_memcpy_eq</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">e</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">add_memcpy_eqs</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">eqs</span> <span class="id">eqs2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">e</span>' =&gt; <span class="id">e</span>' :: <span class="id">add_memcpy_eqs</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">eqs</span> <span class="id">eqs2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">add_memcpy</span> (<span class="id">n1</span> <span class="id">n2</span>: <span class="id">numbering</span>) (<span class="id">asrc</span> <span class="id">adst</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">asrc</span>, <span class="id">adst</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Stk</span> <span class="id">src</span>, <span class="id">Stk</span> <span class="id">dst</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{| <span class="id">num_next</span> := <span class="id">n2</span>.(<span class="id">num_next</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_eqs</span>  := <span class="id">add_memcpy_eqs</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">src</span>) <span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ptrofs.unsigned</span> <span class="id">dst</span> - <span class="id">Ptrofs.unsigned</span> <span class="id">src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n1</span>.(<span class="id">num_eqs</span>) <span class="id">n2</span>.(<span class="id">num_eqs</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_reg</span>  := <span class="id">n2</span>.(<span class="id">num_reg</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">num_val</span>  := <span class="id">n2</span>.(<span class="id">num_val</span>) |}<br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">n2</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Take advantage of known equations to select more efficient
  forms of operations, addressing modes, and conditions. </div>
<br/>
<span class="kwd">Section</span> <span class="id">REDUCE</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">A</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: (<span class="id">valnum</span> -&gt; <span class="id">option</span> <span class="id">rhs</span>) -&gt; <span class="id">A</span> -&gt; <span class="id">list</span> <span class="id">valnum</span> -&gt; <span class="id">option</span> (<span class="id">A</span> * <span class="id">list</span> <span class="id">valnum</span>).<br/>
<span class="kwd">Variable</span> <span class="id">n</span>: <span class="id">numbering</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">reduce_rec</span> (<span class="id">niter</span>: <span class="id">nat</span>) (<span class="id">op</span>: <span class="id">A</span>) (<span class="id">args</span>: <span class="id">list</span> <span class="id">valnum</span>) : <span class="id">option</span>(<span class="id">A</span> * <span class="id">list</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">niter</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">O</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Datatypes.S</span> <span class="id">niter</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">find_valnum_num</span> <span class="id">v</span> <span class="id">n</span>.(<span class="id">num_eqs</span>)) <span class="id">op</span> <span class="id">args</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">op</span>', <span class="id">args</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">reduce_rec</span> <span class="id">niter</span>' <span class="id">op</span>' <span class="id">args</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">args</span>' <span class="kwd">with</span> <span class="id">Some</span> <span class="id">rl</span> =&gt; <span class="id">Some</span>(<span class="id">op</span>', <span class="id">rl</span>) | <span class="id">None</span> =&gt; <span class="id">None</span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">_</span> <span class="kwd">as</span> <span class="id">res</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">res</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">reduce</span> (<span class="id">op</span>: <span class="id">A</span>) (<span class="id">rl</span>: <span class="id">list</span> <span class="id">reg</span>) (<span class="id">vl</span>: <span class="id">list</span> <span class="id">valnum</span>) : <span class="id">A</span> * <span class="id">list</span> <span class="id">reg</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">reduce_rec</span> 4%<span class="id">nat</span> <span class="id">op</span> <span class="id">vl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span>     =&gt; (<span class="id">op</span>, <span class="id">rl</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">res</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">End</span> <span class="id">REDUCE</span>.<br/>
<br/>
<h1> The static analysis </h1>
<br/>
<div class="doc">We now equip the type <span class="bracket"><span class="id">numbering</span></span> with a partial order and a greatest
  element.  The partial order is based on entailment: <span class="bracket"><span class="id">n1</span></span> is greater
  than <span class="bracket"><span class="id">n2</span></span> if <span class="bracket"><span class="id">n1</span></span> is satisfiable whenever <span class="bracket"><span class="id">n2</span></span> is.  The greatest element
  is, of course, the empty numbering (no equations). </div>
<br/>
<span class="kwd">Module</span> <span class="id">Numbering</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">t</span> := <span class="id">numbering</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ge</span> (<span class="id">n1</span> <span class="id">n2</span>: <span class="id">numbering</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n1</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">top</span> := <span class="id">empty_numbering</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">top_ge</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ge</span> <span class="id">top</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3129')">Proof.</div>
<div class="proofscript" id="proof3129">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">top</span>. <span class="tactic">apply</span> <span class="id">empty_numbering_holds</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">refl_ge</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ge</span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3130')">Proof.</div>
<div class="proofscript" id="proof3130">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<span class="kwd">End</span> <span class="id">Numbering</span>.<br/>
<br/>
<div class="doc">We reuse the solver for forward dataflow inequations based on
  propagation over extended basic blocks defined in library <span class="bracket"><span class="id">Kildall</span></span>. </div>
<br/>
<span class="kwd">Module</span> <span class="id">Solver</span> := <span class="id">BBlock_solver</span>(<span class="id">Numbering</span>).<br/>
<br/>
<div class="doc">The transfer function for the dataflow analysis returns the numbering
  ``after'' execution of the instruction at <span class="bracket"><span class="id">pc</span></span>, as a function of the
  numbering ``before''.  For <span class="bracket"><span class="id">Iop</span></span> and <span class="bracket"><span class="id">Iload</span></span> instructions, we add
  equations or reuse existing value numbers as described for
  <span class="bracket"><span class="id">add_op</span></span> and <span class="bracket"><span class="id">add_load</span></span>.  For <span class="bracket"><span class="id">Istore</span></span> instructions, we forget
  equations involving memory loads at possibly overlapping locations,
  then add an equation for loads from the same location stored to.
  For <span class="bracket"><span class="id">Icall</span></span> instructions, we could simply associate a fresh, unconstrained by equations value number
  to the result register.  However, it is often undesirable to eliminate
  common subexpressions across a function call (there is a risk of
  increasing too much the register pressure across the call), so we
  just forget all equations and start afresh with an empty numbering.
  Finally, for instructions that modify neither registers nor
  the memory, we keep the numbering unchanged.
  For builtin invocations <span class="bracket"><span class="id">Ibuiltin</span></span>, we have three strategies:
<ul>
<li>
 Forget all equations.  This is appropriate for builtins that can be
  turned into function calls
  (<span class="bracket"><span class="id">EF_external</span></span>, <span class="bracket"><span class="id">EF_runtime</span></span>, <span class="bracket"><span class="id">EF_malloc</span></span>, <span class="bracket"><span class="id">EF_free</span></span>).
</li>
<li>
 Forget equations involving loads but keep equations over registers.
  This is appropriate for builtins that can modify memory,
  e.g. volatile stores, or <span class="bracket"><span class="id">EF_builtin</span></span>
</li>
<li>
 Keep all equations, taking advantage of the fact that neither memory
  nor registers are modified.  This is appropriate for annotations
  and for volatile loads.
</li>
</ul>
</div>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">approx</span>: <span class="id">PMap.t</span> <span class="id">VA.t</span>) (<span class="id">pc</span>: <span class="id">node</span>) (<span class="id">before</span>: <span class="id">numbering</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">before</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">i</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">i</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Inop</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">before</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Iop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">add_op</span> <span class="id">before</span> <span class="id">res</span> <span class="id">op</span> <span class="id">args</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Iload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">add_load</span> <span class="id">before</span> <span class="id">dst</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">app</span> := <span class="id">approx</span>!!<span class="id">pc</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">n</span> := <span class="id">kill_loads_after_store</span> <span class="id">app</span> <span class="id">before</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">add_store_result</span> <span class="id">app</span> <span class="id">n</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Icall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">empty_numbering</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Itailcall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">empty_numbering</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ibuiltin</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ef</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">EF_external</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_runtime</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_malloc</span> | <span class="id">EF_free</span> | <span class="id">EF_inline_asm</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">empty_numbering</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">EF_builtin</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_vstore</span> <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_res_unknown</span> (<span class="id">kill_all_loads</span> <span class="id">before</span>) <span class="id">res</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">EF_memcpy</span> <span class="id">sz</span> <span class="id">al</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">args</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">dst</span> :: <span class="id">src</span> :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">app</span> := <span class="id">approx</span>!!<span class="id">pc</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">adst</span> := <span class="id">aaddr_arg</span> <span class="id">app</span> <span class="id">dst</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">asrc</span> := <span class="id">aaddr_arg</span> <span class="id">app</span> <span class="id">src</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">n</span> := <span class="id">kill_loads_after_storebytes</span> <span class="id">app</span> <span class="id">before</span> <span class="id">adst</span> <span class="id">sz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_res_unknown</span> (<span class="id">add_memcpy</span> <span class="id">before</span> <span class="id">n</span> <span class="id">asrc</span> <span class="id">adst</span> <span class="id">sz</span>) <span class="id">res</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">empty_numbering</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">EF_vload</span> <span class="id">_</span> | <span class="id">EF_annot</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_annot_val</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_debug</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set_res_unknown</span> <span class="id">before</span> <span class="id">res</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Icond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">ifso</span> <span class="id">ifnot</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">before</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ijumptable</span> <span class="id">arg</span> <span class="id">tbl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">before</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ireturn</span> <span class="id">optarg</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">before</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The static analysis solves the dataflow inequations implied
  by the <span class="bracket"><span class="id">transfer</span></span> function using the ``extended basic block'' solver,
  which produces sub-optimal solutions quickly.  The result is
  a mapping from program points to numberings. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">analyze</span> (<span class="id">f</span>: <span class="id">RTL.function</span>) (<span class="id">approx</span>: <span class="id">PMap.t</span> <span class="id">VA.t</span>): <span class="id">option</span> (<span class="id">PMap.t</span> <span class="id">numbering</span>) :=<br/>
&nbsp;&nbsp;<span class="id">Solver.fixpoint</span> (<span class="id">fn_code</span> <span class="id">f</span>) <span class="id">successors_instr</span> (<span class="id">transfer</span> <span class="id">f</span> <span class="id">approx</span>) <span class="id">f</span>.(<span class="id">fn_entrypoint</span>).<br/>
<br/>
<h1> Code transformation </h1>
<br/>
<div class="doc">The code transformation is performed instruction by instruction.
  <span class="bracket"><span class="id">Iload</span></span> instructions and non-trivial <span class="bracket"><span class="id">Iop</span></span> instructions are turned
  into move instructions if their result is already available in a
  register, as indicated by the numbering inferred at that program point.
  Some operations are so cheap to compute that it is generally not
  worth reusing their results.  These operations are detected by the
  function <span class="bracket"><span class="id">is_trivial_op</span></span> in module <span class="bracket"><span class="id">Op</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_instr</span> (<span class="id">n</span>: <span class="id">numbering</span>) (<span class="id">instr</span>: <span class="id">instruction</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">instr</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Iop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">is_trivial_op</span> <span class="id">op</span> <span class="kwd">then</span> <span class="id">instr</span> <span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vl</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_rhs</span> <span class="id">n1</span> (<span class="id">Op</span> <span class="id">op</span> <span class="id">vl</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Iop</span> <span class="id">Omove</span> (<span class="id">r</span> :: <span class="id">nil</span>) <span class="id">res</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">op</span>', <span class="id">args</span>') := <span class="id">reduce</span> <span class="id">_</span> <span class="id">combine_op</span> <span class="id">n1</span> <span class="id">op</span> <span class="id">args</span> <span class="id">vl</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Iop</span> <span class="id">op</span>' <span class="id">args</span>' <span class="id">res</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;| <span class="id">Iload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vl</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_rhs</span> <span class="id">n1</span> (<span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vl</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">r</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Iop</span> <span class="id">Omove</span> (<span class="id">r</span> :: <span class="id">nil</span>) <span class="id">dst</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">addr</span>', <span class="id">args</span>') := <span class="id">reduce</span> <span class="id">_</span> <span class="id">combine_addr</span> <span class="id">n1</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">vl</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Iload</span> <span class="id">chunk</span> <span class="id">addr</span>' <span class="id">args</span>' <span class="id">dst</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;| <span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vl</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">addr</span>', <span class="id">args</span>') := <span class="id">reduce</span> <span class="id">_</span> <span class="id">combine_addr</span> <span class="id">n1</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">vl</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span>' <span class="id">args</span>' <span class="id">src</span> <span class="id">s</span><br/>
&nbsp;&nbsp;| <span class="id">Icond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">s1</span> <span class="id">s2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">n1</span>, <span class="id">vl</span>) := <span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">cond</span>', <span class="id">args</span>') := <span class="id">reduce</span> <span class="id">_</span> <span class="id">combine_cond</span> <span class="id">n1</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">vl</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Icond</span> <span class="id">cond</span>' <span class="id">args</span>' <span class="id">s1</span> <span class="id">s2</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instr</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_code</span> (<span class="id">approxs</span>: <span class="id">PMap.t</span> <span class="id">numbering</span>) (<span class="id">instrs</span>: <span class="id">code</span>) : <span class="id">code</span> :=<br/>
&nbsp;&nbsp;<span class="id">PTree.map</span> (<span class="kwd">fun</span> <span class="id">pc</span> <span class="id">instr</span> =&gt; <span class="id">transf_instr</span> <span class="id">approxs</span>!!<span class="id">pc</span> <span class="id">instr</span>) <span class="id">instrs</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">vanalyze</span> := <span class="id">ValueAnalysis.analyze</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_function</span> (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">f</span>: <span class="id">function</span>) : <span class="id">res</span> <span class="id">function</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">approx</span> := <span class="id">vanalyze</span> <span class="id">rm</span> <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">analyze</span> <span class="id">f</span> <span class="id">approx</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">Error</span> (<span class="id">msg</span> "<span class="id">CSE</span> <span class="id">failure</span>")<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">approxs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">OK</span>(<span class="id">mkfunction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_sig</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_params</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">transf_code</span> <span class="id">approxs</span> <span class="id">f</span>.(<span class="id">fn_code</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_entrypoint</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_fundef</span> (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">f</span>: <span class="id">fundef</span>) : <span class="id">res</span> <span class="id">fundef</span> :=<br/>
&nbsp;&nbsp;<span class="id">AST.transf_partial_fundef</span> (<span class="id">transf_function</span> <span class="id">rm</span>) <span class="id">f</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_program</span> (<span class="id">p</span>: <span class="id">program</span>) : <span class="id">res</span> <span class="id">program</span> :=<br/>
&nbsp;&nbsp;<span class="id">transform_partial_program</span> (<span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">p</span>)) <span class="id">p</span>.<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
