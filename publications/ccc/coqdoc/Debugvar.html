<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Debugvar</title>
<meta name="description" content="Documentation of Coq module Debugvar" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Debugvar</h1>
<div class="coq">
<br/>
<div class="doc">Computation of live ranges for local variables that carry
    debugging information. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Axioms</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Iteration</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">AST</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Machregs</span> <span class="id">Locations</span> <span class="id">Conventions</span> <span class="id">Linear</span>.<br/>
<br/>
<div class="doc">A debug info is a <span class="bracket"><span class="id">builtin_arg</span> <span class="id">loc</span></span> expression that safely evaluates
   in any context. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">safe_builtin_arg</span> {<span class="id">A</span>: <span class="kwd">Type</span>} (<span class="id">a</span>: <span class="id">builtin_arg</span> <span class="id">A</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BA</span> <span class="id">_</span> | <span class="id">BA_int</span> <span class="id">_</span> | <span class="id">BA_long</span> <span class="id">_</span> | <span class="id">BA_float</span> <span class="id">_</span> | <span class="id">BA_single</span> <span class="id">_</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| <span class="id">BA_splitlong</span> <span class="id">hi</span> <span class="id">lo</span> =&gt; <span class="id">safe_builtin_arg</span> <span class="id">hi</span> /\ <span class="id">safe_builtin_arg</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">debuginfo</span> := { <span class="id">a</span> : <span class="id">builtin_arg</span> <span class="id">loc</span> | <span class="id">safe_builtin_arg</span> <span class="id">a</span> }.<br/>
<br/>
<div class="doc">Normalization of debug info.  Prefer an actual location to a constant.
    Make sure that the debug info is safe to evaluate in any context. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">normalize_debug_1</span> (<span class="id">a</span>: <span class="id">builtin_arg</span> <span class="id">loc</span>) : <span class="id">option</span> <span class="id">debuginfo</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BA</span> <span class="id">x</span> =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA</span> <span class="id">x</span>) <span class="id">I</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_int</span> <span class="id">n</span> =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA_int</span> <span class="id">n</span>) <span class="id">I</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_long</span> <span class="id">n</span> =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA_long</span> <span class="id">n</span>) <span class="id">I</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_float</span> <span class="id">n</span> =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA_float</span> <span class="id">n</span>) <span class="id">I</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_single</span> <span class="id">n</span> =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA_single</span> <span class="id">n</span>) <span class="id">I</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_splitlong</span> (<span class="id">BA</span> <span class="id">hi</span>) (<span class="id">BA</span> <span class="id">lo</span>) =&gt; <span class="id">Some</span> (<span class="id">exist</span> <span class="id">_</span> (<span class="id">BA_splitlong</span> (<span class="id">BA</span> <span class="id">hi</span>) (<span class="id">BA</span> <span class="id">lo</span>)) (<span class="id">conj</span> <span class="id">I</span> <span class="id">I</span>))<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">normalize_debug</span> (<span class="id">l</span>: <span class="id">list</span> (<span class="id">builtin_arg</span> <span class="id">loc</span>)) : <span class="id">option</span> <span class="id">debuginfo</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">a</span> :: <span class="id">l</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">BA_int</span> <span class="id">_</span> | <span class="id">BA_long</span> <span class="id">_</span> | <span class="id">BA_float</span> <span class="id">_</span> | <span class="id">BA_single</span> <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">normalize_debug</span> <span class="id">l</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">i</span> =&gt; <span class="id">Some</span> <span class="id">i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">normalize_debug_1</span> <span class="id">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">normalize_debug_1</span> <span class="id">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<h1> Availability analysis </h1>
<br/>
<div class="doc">This static analysis tracks which locations (registers and stack slots)
    contain the values of which C local variables.
    The abstraction of the program state at a program point is a list of
    pairs (variable name, location).  It is kept sorted by increasing name.
    The location is represented by a safe <span class="bracket"><span class="id">builtin_arg</span> <span class="id">loc</span></span> expression. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">avail</span> : <span class="kwd">Type</span> := <span class="id">list</span> (<span class="id">ident</span> * <span class="id">debuginfo</span>).<br/>
<br/>
<div class="doc">Operations on <span class="bracket"><span class="id">avail</span></span> abstract states. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">set_state</span> (<span class="id">v</span>: <span class="id">ident</span>) (<span class="id">i</span>: <span class="id">debuginfo</span>) (<span class="id">s</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; (<span class="id">v</span>, <span class="id">i</span>) :: <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">v</span>', <span class="id">i</span>') <span class="kwd">as</span> <span class="id">vi</span>' :: <span class="id">s</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Pos.compare</span> <span class="id">v</span> <span class="id">v</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Eq</span> =&gt; (<span class="id">v</span>, <span class="id">i</span>) :: <span class="id">s</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lt</span> =&gt; (<span class="id">v</span>, <span class="id">i</span>) :: <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gt</span> =&gt; <span class="id">vi</span>' :: <span class="id">set_state</span> <span class="id">v</span> <span class="id">i</span> <span class="id">s</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">remove_state</span> (<span class="id">v</span>: <span class="id">ident</span>) (<span class="id">s</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">v</span>', <span class="id">i</span>') <span class="kwd">as</span> <span class="id">vi</span>' :: <span class="id">s</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Pos.compare</span> <span class="id">v</span> <span class="id">v</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Eq</span> =&gt; <span class="id">s</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lt</span> =&gt; <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gt</span> =&gt; <span class="id">vi</span>' :: <span class="id">remove_state</span> <span class="id">v</span> <span class="id">s</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">set_debug_info</span> (<span class="id">v</span>: <span class="id">ident</span>) (<span class="id">info</span>: <span class="id">list</span> (<span class="id">builtin_arg</span> <span class="id">loc</span>)) (<span class="id">s</span>: <span class="id">avail</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">normalize_debug</span> <span class="id">info</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">a</span> =&gt; <span class="id">set_state</span> <span class="id">v</span> <span class="id">a</span> <span class="id">s</span><br/>
&nbsp;&nbsp;| <span class="id">None</span>   =&gt; <span class="id">remove_state</span> <span class="id">v</span> <span class="id">s</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">When the program writes to a register or stack location, some
  availability information is invalidated. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">arg_no_overlap</span> (<span class="id">a</span>: <span class="id">builtin_arg</span> <span class="id">loc</span>) (<span class="id">l</span>: <span class="id">loc</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BA</span> <span class="id">l</span>' =&gt; <span class="id">Loc.diff_dec</span> <span class="id">l</span>' <span class="id">l</span><br/>
&nbsp;&nbsp;| <span class="id">BA_splitlong</span> <span class="id">hi</span> <span class="id">lo</span> =&gt; <span class="id">arg_no_overlap</span> <span class="id">hi</span> <span class="id">l</span> &amp;&amp; <span class="id">arg_no_overlap</span> <span class="id">lo</span> <span class="id">l</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kill</span> (<span class="id">l</span>: <span class="id">loc</span>) (<span class="id">s</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.filter</span> (<span class="kwd">fun</span> <span class="id">vi</span> =&gt; <span class="id">arg_no_overlap</span> (<span class="id">proj1_sig</span> (<span class="id">snd</span> <span class="id">vi</span>)) <span class="id">l</span>) <span class="id">s</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">kill_res</span> (<span class="id">r</span>: <span class="id">builtin_res</span> <span class="id">mreg</span>) (<span class="id">s</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">r</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BR</span> <span class="id">r</span> =&gt; <span class="id">kill</span> (<span class="id">R</span> <span class="id">r</span>) <span class="id">s</span><br/>
&nbsp;&nbsp;| <span class="id">BR_none</span> =&gt; <span class="id">s</span><br/>
&nbsp;&nbsp;| <span class="id">BR_splitlong</span> <span class="id">hi</span> <span class="id">lo</span> =&gt; <span class="id">kill_res</span> <span class="id">hi</span> (<span class="id">kill_res</span> <span class="id">lo</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Likewise when a function call takes place. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">arg_preserved</span> (<span class="id">a</span>: <span class="id">builtin_arg</span> <span class="id">loc</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BA</span> (<span class="id">R</span> <span class="id">r</span>) =&gt; <span class="id">negb</span> (<span class="id">List.In_dec</span> <span class="id">mreg_eq</span> <span class="id">r</span> <span class="id">destroyed_at_call</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA</span> (<span class="id">S</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>) =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">BA_splitlong</span> <span class="id">hi</span> <span class="id">lo</span> =&gt; <span class="id">arg_preserved</span> <span class="id">hi</span> &amp;&amp; <span class="id">arg_preserved</span> <span class="id">lo</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kill_at_call</span> (<span class="id">s</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.filter</span> (<span class="kwd">fun</span> <span class="id">vi</span> =&gt; <span class="id">arg_preserved</span> (<span class="id">proj1_sig</span>(<span class="id">snd</span> <span class="id">vi</span>))) <span class="id">s</span>.<br/>
<br/>
<div class="doc">The join of two availability states is the intersection of the
    corresponding lists. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">eq_arg</span> (<span class="id">a1</span> <span class="id">a2</span>: <span class="id">builtin_arg</span> <span class="id">loc</span>) : {<span class="id">a1</span>=<span class="id">a2</span>} + {<span class="id">a1</span>&lt;&gt;<span class="id">a2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3634')">Proof.</div>
<div class="proofscript" id="proof3634">
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Loc.eq</span> <span class="id">ident_eq</span> <span class="id">Int.eq_dec</span> <span class="id">Int64.eq_dec</span> <span class="id">Ptrofs.eq_dec</span> <span class="id">Float.eq_dec</span> <span class="id">Float32.eq_dec</span> <span class="id">chunk_eq</span>;<br/>
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>.<br/>
Defined.</div>
<span class="kwd">Global</span> <span class="id">Opaque</span> <span class="id">eq_arg</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eq_debuginfo</span> (<span class="id">i1</span> <span class="id">i2</span>: <span class="id">debuginfo</span>) : {<span class="id">i1</span>=<span class="id">i2</span>} + {<span class="id">i1</span> &lt;&gt; <span class="id">i2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3635')">Proof.</div>
<div class="proofscript" id="proof3635">
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_arg</span> (<span class="id">proj1_sig</span> <span class="id">i1</span>) (<span class="id">proj1_sig</span> <span class="id">i2</span>)).<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">destruct</span> <span class="id">i1</span>, <span class="id">i2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">subst</span> <span class="id">x0</span>. <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">proof_irr</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">congruence</span>.<br/>
Defined.</div>
<span class="kwd">Global</span> <span class="id">Opaque</span> <span class="id">eq_debuginfo</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">join</span> (<span class="id">s1</span>: <span class="id">avail</span>) (<span class="id">s2</span>: <span class="id">avail</span>) {<span class="kwd">struct</span> <span class="id">s1</span>} : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s1</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">v1</span>, <span class="id">i1</span>) <span class="kwd">as</span> <span class="id">vi1</span> :: <span class="id">s1</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">fix</span> <span class="id">join2</span> (<span class="id">s2</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">v2</span>, <span class="id">i2</span>) <span class="kwd">as</span> <span class="id">vi2</span> :: <span class="id">s2</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Pos.compare</span> <span class="id">v1</span> <span class="id">v2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Eq</span> =&gt; <span class="kwd">if</span> <span class="id">eq_debuginfo</span> <span class="id">i1</span> <span class="id">i2</span> <span class="kwd">then</span> <span class="id">vi1</span> :: <span class="id">join</span> <span class="id">s1</span>' <span class="id">s2</span>' <span class="kwd">else</span> <span class="id">join</span> <span class="id">s1</span>' <span class="id">s2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lt</span> =&gt; <span class="id">join</span> <span class="id">s1</span>' <span class="id">s2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gt</span> =&gt; <span class="id">join2</span> <span class="id">s2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">join2</span> <span class="id">s2</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eq_state</span> (<span class="id">s1</span> <span class="id">s2</span>: <span class="id">avail</span>) : {<span class="id">s1</span>=<span class="id">s2</span>} + {<span class="id">s1</span>&lt;&gt;<span class="id">s2</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3636')">Proof.</div>
<div class="proofscript" id="proof3636">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_eq_dec</span>. <span class="id">decide</span> <span class="id">equality</span>. <span class="tactic">apply</span> <span class="id">eq_debuginfo</span>. <span class="tactic">apply</span> <span class="id">ident_eq</span>.<br/>
Defined.</div>
<span class="kwd">Global</span> <span class="id">Opaque</span> <span class="id">eq_state</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">top</span> : <span class="id">avail</span> := <span class="id">nil</span>.<br/>
<br/>
<div class="doc">Record availability information at labels. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">labelmap</span> := (<span class="id">PTree.t</span> <span class="id">avail</span> * <span class="id">bool</span>)%<span class="id">type</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">get_label</span> (<span class="id">lbl</span>: <span class="id">label</span>) (<span class="id">lm</span>: <span class="id">labelmap</span>) : <span class="id">option</span> <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">lbl</span> (<span class="id">fst</span> <span class="id">lm</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">update_label</span> (<span class="id">lbl</span>: <span class="id">label</span>) (<span class="id">s1</span>: <span class="id">avail</span>) (<span class="id">lm</span>: <span class="id">labelmap</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">labelmap</span> * <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">get_label</span> <span class="id">lbl</span> <span class="id">lm</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id">PTree.set</span> <span class="id">lbl</span> <span class="id">s1</span> (<span class="id">fst</span> <span class="id">lm</span>), <span class="id">true</span>), <span class="id">s1</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">s2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">s</span> := <span class="id">join</span> <span class="id">s1</span> <span class="id">s2</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">eq_state</span> <span class="id">s</span> <span class="id">s2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">lm</span>, <span class="id">s2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> ((<span class="id">PTree.set</span> <span class="id">lbl</span> <span class="id">s</span> (<span class="id">fst</span> <span class="id">lm</span>), <span class="id">true</span>), <span class="id">s</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">update_labels</span> (<span class="id">lbls</span>: <span class="id">list</span> <span class="id">label</span>) (<span class="id">s</span>: <span class="id">avail</span>) (<span class="id">lm</span>: <span class="id">labelmap</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">labelmap</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lbls</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">lm</span><br/>
&nbsp;&nbsp;| <span class="id">lbl1</span> :: <span class="id">lbls</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">update_labels</span> <span class="id">lbls</span> <span class="id">s</span> (<span class="id">fst</span> (<span class="id">update_label</span> <span class="id">lbl1</span> <span class="id">s</span> <span class="id">lm</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Classification of builtins </div>
<br/>
<span class="kwd">Definition</span> <span class="id">is_debug_setvar</span> (<span class="id">ef</span>: <span class="id">external_function</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ef</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">EF_debug</span> 2%<span class="id">positive</span> <span class="id">txt</span> <span class="id">targs</span> =&gt; <span class="id">Some</span> <span class="id">txt</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">is_builtin_debug_setvar</span> (<span class="id">i</span>: <span class="id">instruction</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">i</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Lbuiltin</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">BR_none</span> =&gt; <span class="id">is_debug_setvar</span> <span class="id">ef</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The transfer function for the forward dataflow analysis. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer</span> (<span class="id">lm</span>: <span class="id">labelmap</span>) (<span class="id">before</span>: <span class="id">option</span> <span class="id">avail</span>) (<span class="id">i</span>: <span class="id">instruction</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">labelmap</span> * <span class="id">option</span> <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">before</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">i</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Llabel</span> <span class="id">lbl</span> =&gt; (<span class="id">lm</span>, <span class="id">get_label</span> <span class="id">lbl</span> <span class="id">lm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; (<span class="id">lm</span>, <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">s</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">i</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lgetstack</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">rd</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill</span> (<span class="id">R</span> <span class="id">rd</span>) <span class="id">s</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lsetstack</span> <span class="id">rs</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">s</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">dst</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill</span> (<span class="id">R</span> <span class="id">dst</span>) <span class="id">s</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">dst</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill</span> (<span class="id">R</span> <span class="id">dst</span>) <span class="id">s</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lstore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">before</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lcall</span> <span class="id">sg</span> <span class="id">ros</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill_at_call</span> <span class="id">s</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ltailcall</span> <span class="id">sg</span> <span class="id">ros</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lbuiltin</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">s</span>' :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">is_debug_setvar</span> <span class="id">ef</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">v</span> =&gt; <span class="id">set_debug_info</span> <span class="id">v</span> <span class="id">args</span> <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span>   =&gt; <span class="id">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">Some</span> (<span class="id">kill_res</span> <span class="id">res</span> <span class="id">s</span>'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Llabel</span> <span class="id">lbl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">lm1</span>, <span class="id">s1</span>) := <span class="id">update_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">lm</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm1</span>, <span class="id">Some</span> <span class="id">s1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lgoto</span> <span class="id">lbl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">lm1</span>, <span class="id">s1</span>) := <span class="id">update_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">lm</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm1</span>, <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lcond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">lbl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">lm1</span>, <span class="id">s1</span>) := <span class="id">update_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">lm</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm1</span>, <span class="id">before</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Ljumptable</span> <span class="id">r</span> <span class="id">lbls</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">update_labels</span> <span class="id">lbls</span> <span class="id">s</span> <span class="id">lm</span>, <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lreturn</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lm</span>, <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">One pass of forward analysis over the code <span class="bracket"><span class="id">c</span></span>.
    Return an updated label map. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">ana_code</span> (<span class="id">lm</span>: <span class="id">labelmap</span>) (<span class="id">before</span>: <span class="id">option</span> <span class="id">avail</span>) (<span class="id">c</span>: <span class="id">code</span>) : <span class="id">labelmap</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">lm</span><br/>
&nbsp;&nbsp;| <span class="id">i</span> :: <span class="id">c</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">lm1</span>, <span class="id">after</span>) := <span class="id">transfer</span> <span class="id">lm</span> <span class="id">before</span> <span class="id">i</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ana_code</span> <span class="id">lm1</span> <span class="id">after</span> <span class="id">c</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Iterate <span class="bracket"><span class="id">ana_code</span></span> until the label map is stable. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">ana_iter</span> (<span class="id">c</span>: <span class="id">code</span>) (<span class="id">lm</span>: <span class="id">labelmap</span>) : <span class="id">labelmap</span> + <span class="id">labelmap</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">lm</span>' := <span class="id">ana_code</span> (<span class="id">fst</span> <span class="id">lm</span>, <span class="id">false</span>) (<span class="id">Some</span> <span class="id">top</span>) <span class="id">c</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">snd</span> <span class="id">lm</span>' <span class="kwd">then</span> <span class="id">inr</span> <span class="id">_</span> <span class="id">lm</span>' <span class="kwd">else</span> <span class="id">inl</span> <span class="id">_</span> <span class="id">lm</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ana_function</span> (<span class="id">f</span>: <span class="id">function</span>) : <span class="id">option</span> <span class="id">labelmap</span> :=<br/>
&nbsp;&nbsp;<span class="id">PrimIter.iterate</span> <span class="id">_</span> <span class="id">_</span> (<span class="id">ana_iter</span> <span class="id">f</span>.(<span class="id">fn_code</span>)) (<span class="id">PTree.empty</span> <span class="id">_</span>, <span class="id">false</span>).<br/>
<br/>
<h1> Code transformation </h1>
<br/>
<div class="doc">Compute the changes between two abstract states </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">diff</span> (<span class="id">s1</span> <span class="id">s2</span>: <span class="id">avail</span>) {<span class="kwd">struct</span> <span class="id">s1</span>} : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s1</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">v1</span>, <span class="id">i1</span>) <span class="kwd">as</span> <span class="id">vi1</span> :: <span class="id">s1</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">fix</span> <span class="id">diff2</span> (<span class="id">s2</span>: <span class="id">avail</span>) : <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">s1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">v2</span>, <span class="id">i2</span>) :: <span class="id">s2</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Pos.compare</span> <span class="id">v1</span> <span class="id">v2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Eq</span> =&gt; <span class="kwd">if</span> <span class="id">eq_debuginfo</span> <span class="id">i1</span> <span class="id">i2</span> <span class="kwd">then</span> <span class="id">diff</span> <span class="id">s1</span>' <span class="id">s2</span>' <span class="kwd">else</span> <span class="id">vi1</span> :: <span class="id">diff</span> <span class="id">s1</span>' <span class="id">s2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Lt</span> =&gt; <span class="id">vi1</span> :: <span class="id">diff</span> <span class="id">s1</span>' <span class="id">s2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gt</span> =&gt; <span class="id">diff2</span> <span class="id">s2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">in</span> <span class="id">diff2</span> <span class="id">s2</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">delta_state</span> (<span class="id">before</span> <span class="id">after</span>: <span class="id">option</span> <span class="id">avail</span>) : <span class="id">avail</span> * <span class="id">avail</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">before</span>, <span class="id">after</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span>, <span class="id">None</span> =&gt; (<span class="id">nil</span>, <span class="id">nil</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">b</span>, <span class="id">None</span> =&gt; (<span class="id">b</span>, <span class="id">nil</span>)<br/>
&nbsp;&nbsp;| <span class="id">None</span>, <span class="id">Some</span> <span class="id">a</span> =&gt; (<span class="id">nil</span>, <span class="id">a</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">b</span>, <span class="id">Some</span> <span class="id">a</span> =&gt; (<span class="id">diff</span> <span class="id">b</span> <span class="id">a</span>, <span class="id">diff</span> <span class="id">a</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Insert debug annotations at the beginning and end of live ranges
    of locations that correspond to source local variables. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">add_start_range</span> (<span class="id">vi</span>: <span class="id">ident</span> * <span class="id">debuginfo</span>) (<span class="id">c</span>: <span class="id">code</span>) : <span class="id">code</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">v</span>, <span class="id">i</span>) := <span class="id">vi</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">Lbuiltin</span> (<span class="id">EF_debug</span> 3%<span class="id">positive</span> <span class="id">v</span> <span class="id">nil</span>) (<span class="id">proj1_sig</span> <span class="id">i</span> :: <span class="id">nil</span>) <span class="id">BR_none</span> :: <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">add_end_range</span> (<span class="id">vi</span>: <span class="id">ident</span> * <span class="id">debuginfo</span>) (<span class="id">c</span>: <span class="id">code</span>) : <span class="id">code</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">v</span>, <span class="id">i</span>) := <span class="id">vi</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">Lbuiltin</span> (<span class="id">EF_debug</span> 4%<span class="id">positive</span> <span class="id">v</span> <span class="id">nil</span>) <span class="id">nil</span> <span class="id">BR_none</span> :: <span class="id">c</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">add_delta_ranges</span> (<span class="id">before</span> <span class="id">after</span>: <span class="id">option</span> <span class="id">avail</span>) (<span class="id">c</span>: <span class="id">code</span>) : <span class="id">code</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">killed</span>, <span class="id">born</span>) := <span class="id">delta_state</span> <span class="id">before</span> <span class="id">after</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">List.fold_right</span> <span class="id">add_end_range</span> (<span class="id">List.fold_right</span> <span class="id">add_start_range</span> <span class="id">c</span> <span class="id">born</span>) <span class="id">killed</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">skip_debug_setvar</span> (<span class="id">lm</span>: <span class="id">labelmap</span>) (<span class="id">before</span>: <span class="id">option</span> <span class="id">avail</span>) (<span class="id">c</span>: <span class="id">code</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">before</span><br/>
&nbsp;&nbsp;| <span class="id">i</span> :: <span class="id">c</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">is_builtin_debug_setvar</span> <span class="id">i</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">_</span> =&gt; <span class="id">skip_debug_setvar</span> <span class="id">lm</span> (<span class="id">snd</span> (<span class="id">transfer</span> <span class="id">lm</span> <span class="id">before</span> <span class="id">i</span>)) <span class="id">c</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">before</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">transf_code</span> (<span class="id">lm</span>: <span class="id">labelmap</span>) (<span class="id">before</span>: <span class="id">option</span> <span class="id">avail</span>) (<span class="id">c</span>: <span class="id">code</span>) : <span class="id">code</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">Lgoto</span> <span class="id">lbl1</span> :: <span class="id">Llabel</span> <span class="id">lbl2</span> :: <span class="id">c</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">after</span> := <span class="id">get_label</span> <span class="id">lbl2</span> <span class="id">lm</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Lgoto</span> <span class="id">lbl1</span> :: <span class="id">Llabel</span> <span class="id">lbl2</span> ::<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">add_delta_ranges</span> <span class="id">before</span> <span class="id">after</span> (<span class="id">transf_code</span> <span class="id">lm</span> <span class="id">after</span> <span class="id">c</span>')<br/>
&nbsp;&nbsp;| <span class="id">i</span> :: <span class="id">c</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">after</span> := <span class="id">skip_debug_setvar</span> <span class="id">lm</span> (<span class="id">snd</span> (<span class="id">transfer</span> <span class="id">lm</span> <span class="id">before</span> <span class="id">i</span>)) <span class="id">c</span>' <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span> :: <span class="id">add_delta_ranges</span> <span class="id">before</span> <span class="id">after</span> (<span class="id">transf_code</span> <span class="id">lm</span> <span class="id">after</span> <span class="id">c</span>')<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">string_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_function</span> (<span class="id">f</span>: <span class="id">function</span>) : <span class="id">res</span> <span class="id">function</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ana_function</span> <span class="id">f</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">Error</span> (<span class="id">msg</span> "<span class="id">Debugvar</span>: <span class="id">analysis</span> <span class="id">diverges</span>")<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">lm</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">OK</span> (<span class="id">mkfunction</span> <span class="id">f</span>.(<span class="id">fn_sig</span>) <span class="id">f</span>.(<span class="id">fn_stacksize</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">transf_code</span> <span class="id">lm</span> (<span class="id">Some</span> <span class="id">top</span>) <span class="id">f</span>.(<span class="id">fn_code</span>)))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_fundef</span> (<span class="id">fd</span>: <span class="id">fundef</span>) : <span class="id">res</span> <span class="id">fundef</span> :=<br/>
&nbsp;&nbsp;<span class="id">AST.transf_partial_fundef</span> <span class="id">transf_function</span> <span class="id">fd</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_program</span> (<span class="id">p</span>: <span class="id">program</span>) : <span class="id">res</span> <span class="id">program</span> :=<br/>
&nbsp;&nbsp;<span class="id">transform_partial_program</span> <span class="id">transf_fundef</span> <span class="id">p</span>.<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
