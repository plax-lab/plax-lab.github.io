<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module ValueAnalysis</title>
<meta name="description" content="Documentation of Coq module ValueAnalysis" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module ValueAnalysis</h1>
<div class="coq">
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">Lattice</span> <span class="id">Kildall</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Compopts</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Globalenvs</span> <span class="id">Events</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Registers</span> <span class="id">Op</span> <span class="id">RTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValueDomain</span> <span class="id">ValueAOp</span> <span class="id">Liveness</span>.<br/>
<br/>
<h1> The dataflow analysis </h1>
<br/>
<span class="kwd">Definition</span> <span class="id">areg</span> (<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">r</span>: <span class="id">reg</span>) : <span class="id">aval</span> := <span class="id">AE.get</span> <span class="id">r</span> <span class="id">ae</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">aregs</span> (<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">rl</span>: <span class="id">list</span> <span class="id">reg</span>) : <span class="id">list</span> <span class="id">aval</span> := <span class="id">List.map</span> (<span class="id">areg</span> <span class="id">ae</span>) <span class="id">rl</span>.<br/>
<br/>
<div class="doc">Analysis of function calls.  We treat specially the case where
  neither the arguments nor the global variables point within the
  stack frame of the current function.  In this case, no pointer
  within the stack frame escapes during the call. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">mafter_public_call</span> : <span class="id">amem</span> := <span class="id">mtop</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mafter_private_call</span> (<span class="id">am_before</span>: <span class="id">amem</span>) : <span class="id">amem</span> :=<br/>
&nbsp;&nbsp;{| <span class="id">am_stack</span> := <span class="id">am_before</span>.(<span class="id">am_stack</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_glob</span> := <span class="id">PTree.empty</span> <span class="id">_</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_nonstack</span> := <span class="id">Nonstack</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_top</span> := <span class="id">plub</span> (<span class="id">ab_summary</span> (<span class="id">am_stack</span> <span class="id">am_before</span>)) <span class="id">Nonstack</span> |}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">analyze_call</span> (<span class="id">am</span>: <span class="id">amem</span>) (<span class="id">aargs</span>: <span class="id">list</span> <span class="id">aval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">pincl</span> <span class="id">am</span>.(<span class="id">am_nonstack</span>) <span class="id">Nonstack</span><br/>
&nbsp;&nbsp;&amp;&amp; <span class="id">forallb</span> (<span class="kwd">fun</span> <span class="id">av</span> =&gt; <span class="id">vpincl</span> <span class="id">av</span> <span class="id">Nonstack</span>) <span class="id">aargs</span><br/>
&nbsp;&nbsp;<span class="kwd">then</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>, <span class="id">mafter_private_call</span> <span class="id">am</span>)<br/>
&nbsp;&nbsp;<span class="kwd">else</span> (<span class="id">Vtop</span>, <span class="id">mafter_public_call</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer_call</span> (<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">am</span>: <span class="id">amem</span>) (<span class="id">args</span>: <span class="id">list</span> <span class="id">reg</span>) (<span class="id">res</span>: <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">av</span>, <span class="id">am</span>') := <span class="id">analyze_call</span> <span class="id">am</span> (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">AE.set</span> <span class="id">res</span> <span class="id">av</span> <span class="id">ae</span>) <span class="id">am</span>'.<br/>
<br/>
<div class="doc">Analysis of builtins. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">abuiltin_arg</span> (<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">am</span>: <span class="id">amem</span>) (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">ba</span>: <span class="id">builtin_arg</span> <span class="id">reg</span>) : <span class="id">aval</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ba</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BA</span> <span class="id">r</span> =&gt; <span class="id">areg</span> <span class="id">ae</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">BA_int</span> <span class="id">n</span> =&gt; <span class="id">I</span> <span class="id">n</span><br/>
&nbsp;&nbsp;| <span class="id">BA_long</span> <span class="id">n</span> =&gt; <span class="id">L</span> <span class="id">n</span><br/>
&nbsp;&nbsp;| <span class="id">BA_float</span> <span class="id">n</span> =&gt; <span class="id">F</span> <span class="id">n</span><br/>
&nbsp;&nbsp;| <span class="id">BA_single</span> <span class="id">n</span> =&gt; <span class="id">FS</span> <span class="id">n</span><br/>
&nbsp;&nbsp;| <span class="id">BA_loadstack</span> <span class="id">chunk</span> <span class="id">ofs</span> =&gt; <span class="id">loadv</span> <span class="id">chunk</span> <span class="id">rm</span> <span class="id">am</span> (<span class="id">Ptr</span> (<span class="id">Stk</span> <span class="id">ofs</span>))<br/>
&nbsp;&nbsp;| <span class="id">BA_addrstack</span> <span class="id">ofs</span> =&gt; <span class="id">Ptr</span> (<span class="id">Stk</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_loadglobal</span> <span class="id">chunk</span> <span class="id">id</span> <span class="id">ofs</span> =&gt; <span class="id">loadv</span> <span class="id">chunk</span> <span class="id">rm</span> <span class="id">am</span> (<span class="id">Ptr</span> (<span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span>))<br/>
&nbsp;&nbsp;| <span class="id">BA_addrglobal</span> <span class="id">id</span> <span class="id">ofs</span> =&gt; <span class="id">Ptr</span> (<span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;| <span class="id">BA_splitlong</span> <span class="id">hi</span> <span class="id">lo</span> =&gt; <span class="id">longofwords</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">hi</span>) (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">lo</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">set_builtin_res</span> (<span class="id">br</span>: <span class="id">builtin_res</span> <span class="id">reg</span>) (<span class="id">av</span>: <span class="id">aval</span>) (<span class="id">ae</span>: <span class="id">aenv</span>) : <span class="id">aenv</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">br</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">BR</span> <span class="id">r</span> =&gt; <span class="id">AE.set</span> <span class="id">r</span> <span class="id">av</span> <span class="id">ae</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">ae</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer_builtin_default</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">am</span>: <span class="id">amem</span>) (<span class="id">rm</span>: <span class="id">romem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> (<span class="id">builtin_arg</span> <span class="id">reg</span>)) (<span class="id">res</span>: <span class="id">builtin_res</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> (<span class="id">av</span>, <span class="id">am</span>') := <span class="id">analyze_call</span> <span class="id">am</span> (<span class="id">map</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span>) <span class="id">args</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">av</span> <span class="id">ae</span>) <span class="id">am</span>'.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer_builtin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">am</span>: <span class="id">amem</span>) (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">ef</span>: <span class="id">external_function</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span>: <span class="id">list</span> (<span class="id">builtin_arg</span> <span class="id">reg</span>)) (<span class="id">res</span>: <span class="id">builtin_res</span> <span class="id">reg</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ef</span>, <span class="id">args</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">EF_vload</span> <span class="id">chunk</span>, <span class="id">addr</span> :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">aaddr</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">addr</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">a</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">va_strict</span> <span class="id">tt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">vlub</span> (<span class="id">loadv</span> <span class="id">chunk</span> <span class="id">rm</span> <span class="id">am</span> <span class="id">aaddr</span>) (<span class="id">vnormalize</span> <span class="id">chunk</span> (<span class="id">Ifptr</span> <span class="id">Glob</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">vnormalize</span> <span class="id">chunk</span> <span class="id">Vtop</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">a</span> <span class="id">ae</span>) <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">EF_vstore</span> <span class="id">chunk</span>, <span class="id">addr</span> :: <span class="id">v</span> :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">aaddr</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">addr</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">av</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">v</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">am</span>' := <span class="id">storev</span> <span class="id">chunk</span> <span class="id">am</span> <span class="id">aaddr</span> <span class="id">av</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">ntop</span> <span class="id">ae</span>) (<span class="id">mlub</span> <span class="id">am</span> <span class="id">am</span>')<br/>
&nbsp;&nbsp;| <span class="id">EF_memcpy</span> <span class="id">sz</span> <span class="id">al</span>, <span class="id">dst</span> :: <span class="id">src</span> :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">adst</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">dst</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">asrc</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">src</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">p</span> := <span class="id">loadbytes</span> <span class="id">am</span> <span class="id">rm</span> (<span class="id">aptr_of_aval</span> <span class="id">asrc</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">am</span>' := <span class="id">storebytes</span> <span class="id">am</span> (<span class="id">aptr_of_aval</span> <span class="id">adst</span>) <span class="id">sz</span> <span class="id">p</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">ntop</span> <span class="id">ae</span>) <span class="id">am</span>'<br/>
&nbsp;&nbsp;| (<span class="id">EF_annot</span> <span class="id">_</span> <span class="id">_</span> | <span class="id">EF_debug</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>), <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">ntop</span> <span class="id">ae</span>) <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">EF_annot_val</span> <span class="id">_</span> <span class="id">_</span>, <span class="id">v</span> :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">av</span> := <span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">v</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">av</span> <span class="id">ae</span>) <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transfer_builtin_default</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">args</span> <span class="id">res</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The transfer function for one instruction.  Given the abstract state
  "before" the instruction, computes the abstract state "after". </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">pc</span>: <span class="id">node</span>) (<span class="id">ae</span>: <span class="id">aenv</span>) (<span class="id">am</span>: <span class="id">amem</span>) : <span class="id">VA.t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.Bot</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Inop</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Iop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">a</span> := <span class="id">eval_static_operation</span> <span class="id">op</span> (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">AE.set</span> <span class="id">res</span> <span class="id">a</span> <span class="id">ae</span>) <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Iload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">a</span> := <span class="id">loadv</span> <span class="id">chunk</span> <span class="id">rm</span> <span class="id">am</span> (<span class="id">eval_static_addressing</span> <span class="id">addr</span> (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>)) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> (<span class="id">AE.set</span> <span class="id">dst</span> <span class="id">a</span> <span class="id">ae</span>) <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">am</span>' := <span class="id">storev</span> <span class="id">chunk</span> <span class="id">am</span> (<span class="id">eval_static_addressing</span> <span class="id">addr</span> (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>)) (<span class="id">areg</span> <span class="id">ae</span> <span class="id">src</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span>'<br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Icall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transfer_call</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">args</span> <span class="id">res</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Itailcall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.Bot</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Ibuiltin</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transfer_builtin</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Icond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">s1</span> <span class="id">s2</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Ijumptable</span> <span class="id">arg</span> <span class="id">tbl</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">arg</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.Bot</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">A wrapper on <span class="bracket"><span class="id">transfer</span></span> that removes information associated with
  dead registers, so as to reduce the sizes of abstract states. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transfer</span>' (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">lastuses</span>: <span class="id">PTree.t</span> (<span class="id">list</span> <span class="id">reg</span>)) (<span class="id">rm</span>: <span class="id">romem</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pc</span>: <span class="id">node</span>) (<span class="id">before</span>: <span class="id">VA.t</span>) : <span class="id">VA.t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">before</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">VA.Bot</span><br/>
&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">VA.Bot</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span>' <span class="id">am</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">ae</span>'' :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">lastuses</span>!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">ae</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">regs</span> =&gt; <span class="id">eforget</span> <span class="id">regs</span> <span class="id">ae</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">VA.State</span> <span class="id">ae</span>'' <span class="id">am</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The forward dataflow analysis. </div>
<br/>
<span class="kwd">Module</span> <span class="id">DS</span> := <span class="id">Dataflow_Solver</span>(<span class="id">VA</span>)(<span class="id">NodeSetForward</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">mfunction_entry</span> :=<br/>
&nbsp;&nbsp;{| <span class="id">am_stack</span> := <span class="id">ablock_init</span> <span class="id">Pbot</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_glob</span> := <span class="id">PTree.empty</span> <span class="id">_</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_nonstack</span> := <span class="id">Nonstack</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">am_top</span> := <span class="id">Nonstack</span> |}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">analyze</span> (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">f</span>: <span class="id">function</span>): <span class="id">PMap.t</span> <span class="id">VA.t</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">lu</span> := <span class="id">Liveness.last_uses</span> <span class="id">f</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">entry</span> := <span class="id">VA.State</span> (<span class="id">einit_regs</span> <span class="id">f</span>.(<span class="id">fn_params</span>)) <span class="id">mfunction_entry</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">DS.fixpoint</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">successors_instr</span> (<span class="id">transfer</span>' <span class="id">f</span> <span class="id">lu</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_entrypoint</span>) <span class="id">entry</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">PMap.init</span> (<span class="id">VA.State</span> <span class="id">AE.top</span> <span class="id">mtop</span>)<br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">res</span> =&gt; <span class="id">res</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Constructing the approximation of read-only globals </div>
<br/>
<span class="kwd">Definition</span> <span class="id">store_init_data</span> (<span class="id">ab</span>: <span class="id">ablock</span>) (<span class="id">p</span>: <span class="id">Z</span>) (<span class="id">id</span>: <span class="id">init_data</span>) : <span class="id">ablock</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Init_int8</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mint8unsigned</span> <span class="id">ab</span> <span class="id">p</span> (<span class="id">I</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_int16</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mint16unsigned</span> <span class="id">ab</span> <span class="id">p</span> (<span class="id">I</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_int32</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mint32</span> <span class="id">ab</span> <span class="id">p</span> (<span class="id">I</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_int64</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mint64</span> <span class="id">ab</span> <span class="id">p</span> (<span class="id">L</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_float32</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mfloat32</span> <span class="id">ab</span> <span class="id">p</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id">propagate_float_constants</span> <span class="id">tt</span> <span class="kwd">then</span> <span class="id">FS</span> <span class="id">n</span> <span class="kwd">else</span> <span class="id">ntop</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_float64</span> <span class="id">n</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mfloat64</span> <span class="id">ab</span> <span class="id">p</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">if</span> <span class="id">propagate_float_constants</span> <span class="id">tt</span> <span class="kwd">then</span> <span class="id">F</span> <span class="id">n</span> <span class="kwd">else</span> <span class="id">ntop</span>)<br/>
&nbsp;&nbsp;| <span class="id">Init_addrof</span> <span class="id">symb</span> <span class="id">ofs</span> =&gt; <span class="id">ablock_store</span> <span class="id">Mptr</span> <span class="id">ab</span> <span class="id">p</span> (<span class="id">Ptr</span> (<span class="id">Gl</span> <span class="id">symb</span> <span class="id">ofs</span>))<br/>
&nbsp;&nbsp;| <span class="id">Init_space</span> <span class="id">n</span> =&gt; <span class="id">ab</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">store_init_data_list</span> (<span class="id">ab</span>: <span class="id">ablock</span>) (<span class="id">p</span>: <span class="id">Z</span>) (<span class="id">idl</span>: <span class="id">list</span> <span class="id">init_data</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">idl</span>}: <span class="id">ablock</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">idl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">ab</span><br/>
&nbsp;&nbsp;| <span class="id">id</span> :: <span class="id">idl</span>' =&gt; <span class="id">store_init_data_list</span> (<span class="id">store_init_data</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">id</span>) (<span class="id">p</span> + <span class="id">init_data_size</span> <span class="id">id</span>) <span class="id">idl</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">When CompCert is used in separate compilation mode, the <span class="bracket"><span class="id">gvar_init</span></span>
  initializer attached to a readonly global variable may not correspond
  to the actual initial value of this global.  This occurs in two cases:
<ul>
<li>
 an <span class="bracket"><span class="id">extern</span> <span class="id">const</span></span> variable, which is represented by <span class="bracket"><span class="id">gvar_init</span> = <span class="id">nil</span></span>;
</li>
<li>
 a <span class="bracket"><span class="id">const</span></span> variable without an explicit initializer, which is treated
  by the linker as a "common" symbol, and is represented by
  <span class="bracket"><span class="id">gvar_init</span> = <span class="id">Init_space</span> <span class="id">sz</span> :: <span class="id">nil</span></span>.
</li>
</ul>
In both cases, the variable can be defined and initialized in another
compilation unit which is later linked with the current compilation unit. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">definitive_initializer</span> (<span class="id">init</span>: <span class="id">list</span> <span class="id">init_data</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">init</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;| <span class="id">Init_space</span> <span class="id">_</span> :: <span class="id">nil</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">alloc_global</span> (<span class="id">rm</span>: <span class="id">romem</span>) (<span class="id">idg</span>: <span class="id">ident</span> * <span class="id">globdef</span> <span class="id">fundef</span> <span class="id">unit</span>): <span class="id">romem</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">idg</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| (<span class="id">id</span>, <span class="id">Gfun</span> <span class="id">f</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PTree.remove</span> <span class="id">id</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;| (<span class="id">id</span>, <span class="id">Gvar</span> <span class="id">v</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">v</span>.(<span class="id">gvar_readonly</span>) &amp;&amp; <span class="id">negb</span> <span class="id">v</span>.(<span class="id">gvar_volatile</span>) &amp;&amp; <span class="id">definitive_initializer</span> <span class="id">v</span>.(<span class="id">gvar_init</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">store_init_data_list</span> (<span class="id">ablock_init</span> <span class="id">Pbot</span>) 0 <span class="id">v</span>.(<span class="id">gvar_init</span>)) <span class="id">rm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">PTree.remove</span> <span class="id">id</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">romem_for</span> (<span class="id">p</span>: <span class="id">program</span>) : <span class="id">romem</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.fold_left</span> <span class="id">alloc_global</span> <span class="id">p</span>.(<span class="id">prog_defs</span>) (<span class="id">PTree.empty</span> <span class="id">_</span>).<br/>
<br/>
<h1> Soundness proof </h1>
<br/>
<div class="doc">Properties of the dataflow solution. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">analyze_entrypoint</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rm</span> <span class="id">f</span> <span class="id">vl</span> <span class="id">m</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> <span class="id">vl</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">mfunction_entry</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ae</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!(<span class="id">fn_entrypoint</span> <span class="id">f</span>) = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span><br/>
&nbsp;&nbsp;/\ <span class="id">ematch</span> <span class="id">bc</span> (<span class="id">init_regs</span> <span class="id">vl</span> (<span class="id">fn_params</span> <span class="id">f</span>)) <span class="id">ae</span><br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3013')">Proof.</div>
<div class="proofscript" id="proof3013">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">analyze</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">lu</span> := <span class="id">Liveness.last_uses</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">entry</span> := <span class="id">VA.State</span> (<span class="id">einit_regs</span> <span class="id">f</span>.(<span class="id">fn_params</span>)) <span class="id">mfunction_entry</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">DS.fixpoint</span> (<span class="id">fn_code</span> <span class="id">f</span>) <span class="id">successors_instr</span> (<span class="id">transfer</span>' <span class="id">f</span> <span class="id">lu</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fn_entrypoint</span> <span class="id">f</span>) <span class="id">entry</span>) <span class="kwd">as</span> [<span class="id">res</span>|] <span class="id">eqn</span>:<span class="id">FIX</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">VA.ge</span> <span class="id">res</span>!!(<span class="id">fn_entrypoint</span> <span class="id">f</span>) <span class="id">entry</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">DS.fixpoint_entry</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">res</span>!!(<span class="id">fn_entrypoint</span> <span class="id">f</span>)) <span class="kwd">as</span> [ | <span class="id">ae</span> <span class="id">am</span> ]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> [<span class="id">A1</span> <span class="id">A2</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ae</span>, <span class="id">am</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">ematch_ge</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">ematch_init</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="id">exists</span> <span class="id">AE.top</span>, <span class="id">mtop</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">PMap.gi</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">ematch_ge</span> <span class="kwd">with</span> (<span class="id">einit_regs</span> (<span class="id">fn_params</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ematch_init</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">AE.ge_top</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_top</span>'; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">analyze_successor</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">n</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">instr</span> <span class="id">s</span> <span class="id">rm</span> <span class="id">ae</span>' <span class="id">am</span>',<br/>
&nbsp;&nbsp;(<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">n</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">n</span> = <span class="id">Some</span> <span class="id">instr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">s</span> (<span class="id">successors_instr</span> <span class="id">instr</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">n</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">VA.State</span> <span class="id">ae</span>' <span class="id">am</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">VA.ge</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">s</span> (<span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">n</span> <span class="id">ae</span> <span class="id">am</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3014')">Proof.</div>
<div class="proofscript" id="proof3014">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">analyze</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">lu</span> := <span class="id">Liveness.last_uses</span> <span class="id">f</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">entry</span> := <span class="id">VA.State</span> (<span class="id">einit_regs</span> <span class="id">f</span>.(<span class="id">fn_params</span>)) <span class="id">mfunction_entry</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">DS.fixpoint</span> (<span class="id">fn_code</span> <span class="id">f</span>) <span class="id">successors_instr</span> (<span class="id">transfer</span>' <span class="id">f</span> <span class="id">lu</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fn_entrypoint</span> <span class="id">f</span>) <span class="id">entry</span>) <span class="kwd">as</span> [<span class="id">res</span>|] <span class="id">eqn</span>:<span class="id">FIX</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">VA.ge</span> <span class="id">res</span>!!<span class="id">s</span> (<span class="id">transfer</span>' <span class="id">f</span> <span class="id">lu</span> <span class="id">rm</span> <span class="id">n</span> <span class="id">res</span>#<span class="id">n</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">DS.fixpoint_solution</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">transfer</span>'. <span class="tactic">simpl</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">unfold</span> <span class="id">transfer</span>' <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">lu</span>!<span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VA.ge_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">eforget_ge</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gi</span>. <span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">AE.ge_top</span>. <span class="tactic">eapply</span> <span class="id">mmatch_top</span>'; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">analyze_succ</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">m</span> <span class="id">rm</span> <span class="id">f</span> <span class="id">n</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">instr</span> <span class="id">s</span> <span class="id">ae</span>' <span class="id">am</span>' <span class="id">bc</span>,<br/>
&nbsp;&nbsp;(<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">n</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">n</span> = <span class="id">Some</span> <span class="id">instr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">s</span> (<span class="id">successors_instr</span> <span class="id">instr</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">n</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">VA.State</span> <span class="id">ae</span>' <span class="id">am</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ae</span>'' <span class="id">am</span>'',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">s</span> = <span class="id">VA.State</span> <span class="id">ae</span>'' <span class="id">am</span>''<br/>
&nbsp;&nbsp;/\ <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span>''<br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span>''.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3015')">Proof.</div>
<div class="proofscript" id="proof3015">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">analyze_successor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)#<span class="id">s</span> <span class="kwd">as</span> [ | <span class="id">ae</span>'' <span class="id">am</span>'']; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">tauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ae</span>'', <span class="id">am</span>''.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">ematch_ge</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h2> Analysis of registers and builtin arguments </h2>
<br/>
<span class="kwd">Lemma</span> <span class="id">areg_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span> <span class="id">r</span>, <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> (<span class="id">e</span>#<span class="id">r</span>) (<span class="id">areg</span> <span class="id">ae</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3016')">Proof.</div>
<div class="proofscript" id="proof3016">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">aregs_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span> <span class="id">rl</span>, <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span> -&gt; <span class="id">list_forall2</span> (<span class="id">vmatch</span> <span class="id">bc</span>) (<span class="id">e</span>##<span class="id">rl</span>) (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">rl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3017')">Proof.</div>
<div class="proofscript" id="proof3017">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="id">constructor</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">areg_sound</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">areg_sound</span> <span class="id">aregs_sound</span>: <span class="id">va</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">abuiltin_arg_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">ge</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">ae</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">a</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3018')">Proof.</div>
<div class="proofscript" id="proof3018">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">EM</span> <span class="id">RM</span> <span class="id">MM</span> <span class="id">GM</span> <span class="id">SP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">loadv_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
- <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">loadv_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">symbol_address_sound</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">symbol_address_sound</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">abuiltin_args_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">ge</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">ae</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">vmatch</span> <span class="id">bc</span>) <span class="id">vl</span> (<span class="id">map</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span>) <span class="id">al</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3019')">Proof.</div>
<div class="proofscript" id="proof3019">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">EM</span> <span class="id">RM</span> <span class="id">MM</span> <span class="id">GM</span> <span class="id">SP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">abuiltin_arg_sound</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_builtin_res_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> <span class="id">v</span> <span class="id">av</span> <span class="id">res</span>,<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">av</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">v</span> <span class="id">rs</span>) (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">av</span> <span class="id">ae</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3020')">Proof.</div>
<div class="proofscript" id="proof3020">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">res</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">ematch_update</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Constructing block classifications </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">bc_nostack</span> (<span class="id">bc</span>: <span class="id">block_classification</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">bc</span> <span class="id">b</span> &lt;&gt; <span class="id">BCstack</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">NOSTACK</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">bc</span>: <span class="id">block_classification</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">NOSTACK</span>: <span class="id">bc_nostack</span> <span class="id">bc</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">pmatch_no_stack</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Nonstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3021')">Proof.</div>
<div class="proofscript" id="proof3021">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">vmatch_no_stack</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3022')">Proof.</div>
<div class="proofscript" id="proof3022">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">eapply</span> <span class="id">pmatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">smatch_no_stack</span>: <span class="kwd">forall</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">Nonstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3023')">Proof.</div>
<div class="proofscript" id="proof3023">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">vmatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">pmatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mmatch_no_stack</span>: <span class="kwd">forall</span> <span class="id">m</span> <span class="id">am</span> <span class="id">astk</span>,<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt; <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> {| <span class="id">am_stack</span> := <span class="id">astk</span>; <span class="id">am_glob</span> := <span class="id">PTree.empty</span> <span class="id">_</span>; <span class="id">am_nonstack</span> := <span class="id">Nonstack</span>; <span class="id">am_top</span> := <span class="id">Nonstack</span> |}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3024')">Proof.</div>
<div class="proofscript" id="proof3024">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">elim</span> (<span class="id">NOSTACK</span> <span class="id">b</span>); <span class="tactic">auto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">smatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">smatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">NOSTACK</span>.<br/>
<br/>
<h2> Construction 1: allocating the stack frame at function entry </h2>
<br/>
<span class="kwd">Ltac</span> <span class="id">splitall</span> := <span class="tactic">repeat</span> (<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- <span class="id">_</span> /\ <span class="id">_</span> =&gt; <span class="tactic">split</span> <span class="kwd">end</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">allocate_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">sz</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">bc</span> <span class="id">ge</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m</span> 0 <span class="id">sz</span> = (<span class="id">m</span>', <span class="id">sp</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">bc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bc_incr</span> <span class="id">bc</span> <span class="id">bc</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span>' <span class="id">sp</span> = <span class="id">BCstack</span><br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">rm</span><br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">mfunction_entry</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">sp</span> -&gt; <span class="id">bc</span>' <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3025')">Proof.</div>
<div class="proofscript" id="proof3025">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">ALLOC</span> <span class="id">GENV</span> <span class="id">RO</span> <span class="id">MM</span> <span class="id">NOSTACK</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">NB</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">SP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SPINVALID</span>: <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCinvalid</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">SP</span>. <span class="tactic">eapply</span> <span class="id">bc_below_invalid</span>. <span class="tactic">apply</span> <span class="id">Plt_strict</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;Part&nbsp;1:&nbsp;constructing&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span> <span class="kwd">then</span> <span class="id">BCstack</span> <span class="kwd">else</span> <span class="id">bc</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCstack</span> -&gt; <span class="id">b</span> = <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">auto</span>. <span class="id">eelim</span> <span class="id">NOSTACK</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> <span class="id">sp</span>; <span class="tactic">auto</span>. <span class="tactic">symmetry</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> (<span class="id">bc_glob</span> <span class="id">bc</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span>' := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">BC</span>'<span class="id">EQ</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">bc</span> <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span> -&gt; <span class="id">bc</span>' <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">dec_eq_false</span>. <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INCR</span>: <span class="id">bc_incr</span> <span class="id">bc</span> <span class="id">bc</span>').<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">BC</span>'<span class="id">EQ</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;Part&nbsp;2:&nbsp;invariance&nbsp;properties&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">bc</span> <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">b</span> <span class="id">Nonstack</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">smatch_incr</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">smatch_inv</span> <span class="kwd">with</span> <span class="id">m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">smatch_no_stack</span> <span class="kwd">with</span> <span class="id">p</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_alloc_unchanged</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SMSTACK</span>: <span class="id">smatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">sp</span> <span class="id">Pbot</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_alloc_same</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ</span>. <span class="tactic">subst</span> <span class="id">v</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_alloc_same</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>'; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;incr&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
- <span class="comment">(*&nbsp;sp&nbsp;is&nbsp;BCstack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">dec_eq_true</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;match&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">genv_match_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;romatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">romatch_exten</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">romatch_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;stack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ablock_init_sound</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">apply</span> <span class="id">SMSTACK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">NOSTACK</span> <span class="id">b</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;globals&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;nonstack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">SM</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">apply</span> <span class="id">smatch_ge</span> <span class="kwd">with</span> <span class="id">Pbot</span>. <span class="tactic">apply</span> <span class="id">SMSTACK</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_top</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;below&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">NB</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>; <span class="tactic">rewrite</span> <span class="id">SP</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
- <span class="comment">(*&nbsp;unchanged&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">dec_eq_false</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;values&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">vmatch_incr</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">vmatch_no_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Construction 2: turn the stack into an "other" block, at public calls or function returns </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">anonymize_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">bc</span> <span class="id">ge</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">bc</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span>' <span class="id">sp</span> = <span class="id">BCother</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">bc</span>' <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> <span class="id">Vtop</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">mtop</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3026')">Proof.</div>
<div class="proofscript" id="proof3026">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">GENV</span> <span class="id">RO</span> <span class="id">MM</span> <span class="id">SP</span>.<br/>
&nbsp;Part&nbsp;1:&nbsp;constructing&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span> <span class="kwd">then</span> <span class="id">BCother</span> <span class="kwd">else</span> <span class="id">bc</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b1</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b2</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b1</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b2</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bc_glob</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span>' := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>'.<br/>
<br/>
&nbsp;Part&nbsp;2:&nbsp;matching&nbsp;wrt&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">pmatch_top</span>'; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VM</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> <span class="id">Vtop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">b</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">S1</span> <span class="id">S2</span>]. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VM</span>. <span class="tactic">eapply</span> <span class="id">S1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">PM</span>. <span class="tactic">eapply</span> <span class="id">S2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>'; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;nostack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;bc'&nbsp;sp&nbsp;is&nbsp;BCother&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">dec_eq_true</span>.<br/>
- <span class="comment">(*&nbsp;other&nbsp;blocks&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">dec_eq_false</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;values&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">genv_match_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;romatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">romatch_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_top</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Construction 3: turn the stack into an invalid block, at private calls </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">hide_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">bc</span> <span class="id">ge</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Nonstack</span> <span class="id">am</span>.(<span class="id">am_nonstack</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">bc</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span>' <span class="id">sp</span> = <span class="id">BCinvalid</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">bc</span>' <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vge</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>) <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> <span class="id">Vtop</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">mtop</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3027')">Proof.</div>
<div class="proofscript" id="proof3027">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">GENV</span> <span class="id">RO</span> <span class="id">MM</span> <span class="id">SP</span> <span class="id">NOLEAK</span>.<br/>
&nbsp;Part&nbsp;1:&nbsp;constructing&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span> <span class="kwd">then</span> <span class="id">BCinvalid</span> <span class="kwd">else</span> <span class="id">bc</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b1</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b2</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b1</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b2</span> <span class="id">sp</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bc_glob</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span>' := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>'.<br/>
<br/>
&nbsp;Part&nbsp;2:&nbsp;matching&nbsp;wrt&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">pge</span> <span class="id">Nonstack</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Nonstack</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">pmatch_ge</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VM</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vge</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>) <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> <span class="id">Vtop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">vmatch_ifptr</span>; <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">eapply</span> <span class="id">PM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">pge</span> <span class="id">Nonstack</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">b</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">S1</span> <span class="id">S2</span>]. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VM</span> <span class="kwd">with</span> (<span class="id">x</span> := <span class="id">Ifptr</span> <span class="id">p</span>). <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">S1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">PM</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">S2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>'; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;nostack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;bc'&nbsp;sp&nbsp;is&nbsp;BCinvalid&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">dec_eq_true</span>.<br/>
- <span class="comment">(*&nbsp;other&nbsp;blocks&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">dec_eq_false</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;values&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">genv_match_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;romatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">romatch_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Construction 4: restore the stack after a public call </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">return_from_public_call</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">caller</span> <span class="id">callee</span>: <span class="id">block_classification</span>) <span class="id">bound</span> <span class="id">sp</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">ae</span> <span class="id">v</span> <span class="id">m</span> <span class="id">rm</span>,<br/>
&nbsp;&nbsp;<span class="id">bc_below</span> <span class="id">caller</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">callee</span> <span class="id">sp</span> = <span class="id">BCother</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">caller</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">caller</span> <span class="id">b</span> = <span class="id">callee</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">caller</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">caller</span> <span class="id">e</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v</span> <span class="id">Vtop</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">mtop</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">callee</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">callee</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">Vtop</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">mafter_public_call</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span><br/>
&nbsp;&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">sp</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">caller</span> <span class="id">b</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3028')">Proof.</div>
<div class="proofscript" id="proof3028">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">rm</span>; <span class="tactic">intros</span> <span class="id">BELOW</span> <span class="id">SP1</span> <span class="id">SP2</span> <span class="id">SAME</span> <span class="id">GE1</span> <span class="id">EM</span> <span class="id">BOUND</span> <span class="id">RESM</span> <span class="id">RM</span> <span class="id">MM</span> <span class="id">GE2</span> <span class="id">NOSTACK</span>.<br/>
&nbsp;Constructing&nbsp;bc&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span> <span class="kwd">then</span> <span class="id">BCstack</span> <span class="kwd">else</span> <span class="id">callee</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCstack</span> -&gt; <span class="id">b</span> = <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">auto</span>. <span class="id">eelim</span> <span class="id">NOSTACK</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> <span class="id">sp</span>; <span class="tactic">auto</span>. <span class="tactic">symmetry</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">callee</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> (<span class="id">bc_glob</span> <span class="id">callee</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span> := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INCR</span>: <span class="id">bc_incr</span> <span class="id">caller</span> <span class="id">bc</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Invariance&nbsp;properties&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">pmatch</span> <span class="id">callee</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">callee</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">pmatch_top</span>'; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VM</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">Vtop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v0</span> <span class="id">Vtop</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">vmatch_top</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">smatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">VM</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">PM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;result&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VM</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;environment&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ematch_incr</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;romem&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">romatch_exten</span> <span class="kwd">with</span> <span class="id">callee</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;stack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ablock_init_sound</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">NOSTACK</span> <span class="id">b</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;globals&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;nonstack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">SM</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_top</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;below&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">genv_match_exten</span> <span class="kwd">with</span> <span class="id">caller</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">SAME</span> <span class="kwd">in</span> <span class="id">H</span> <span class="tactic">by</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> &lt;- (<span class="id">proj1</span> <span class="id">GE2</span>) <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> (<span class="id">proj1</span> <span class="id">GE1</span>) <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">SAME</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
- <span class="comment">(*&nbsp;sp&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">dec_eq_true</span>.<br/>
- <span class="comment">(*&nbsp;unchanged&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Plt_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">BELOW</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Construction 5: restore the stack after a private call </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">return_from_private_call</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">caller</span> <span class="id">callee</span>: <span class="id">block_classification</span>) <span class="id">bound</span> <span class="id">sp</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">ae</span> <span class="id">v</span> <span class="id">m</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">bc_below</span> <span class="id">caller</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">callee</span> <span class="id">sp</span> = <span class="id">BCinvalid</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">caller</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">caller</span> <span class="id">b</span> = <span class="id">callee</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">caller</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">caller</span> <span class="id">e</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">caller</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">am</span>.(<span class="id">am_stack</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v</span> <span class="id">Vtop</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">mtop</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">callee</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">callee</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>)<br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> (<span class="id">mafter_private_call</span> <span class="id">am</span>)<br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span><br/>
&nbsp;&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">sp</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">caller</span> <span class="id">b</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3029')">Proof.</div>
<div class="proofscript" id="proof3029">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">BELOW</span> <span class="id">SP1</span> <span class="id">SP2</span> <span class="id">SAME</span> <span class="id">GE1</span> <span class="id">EM</span> <span class="id">CONTENTS</span> <span class="id">BOUND</span> <span class="id">RESM</span> <span class="id">RM</span> <span class="id">MM</span> <span class="id">GE2</span> <span class="id">NOSTACK</span>.<br/>
&nbsp;Constructing&nbsp;bc&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span> <span class="kwd">then</span> <span class="id">BCstack</span> <span class="kwd">else</span> <span class="id">callee</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCstack</span> -&gt; <span class="id">b</span> = <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">auto</span>. <span class="id">eelim</span> <span class="id">NOSTACK</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> <span class="id">sp</span>; <span class="tactic">auto</span>. <span class="tactic">symmetry</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">callee</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> (<span class="id">bc_glob</span> <span class="id">callee</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span> := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INCR1</span>: <span class="id">bc_incr</span> <span class="id">caller</span> <span class="id">bc</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INCR2</span>: <span class="id">bc_incr</span> <span class="id">callee</span> <span class="id">bc</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;Invariance&nbsp;properties&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">pmatch</span> <span class="id">callee</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt; <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Nonstack</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">callee</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">pmatch_top</span>'; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VM</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v</span> <span class="id">x</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">vmatch</span> <span class="id">callee</span> <span class="id">v0</span> <span class="id">Vtop</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">vmatch_top</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">p</span>, <span class="id">smatch</span> <span class="id">callee</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">Nonstack</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">VM</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">PM</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">BSTK</span>: <span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">sp</span> (<span class="id">am_stack</span> <span class="id">am</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_incr</span> <span class="kwd">with</span> <span class="id">caller</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;result&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VM</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;environment&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ematch_incr</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;romem&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">romatch_exten</span> <span class="kwd">with</span> <span class="id">callee</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;stack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">exact</span> <span class="id">BSTK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">NOSTACK</span> <span class="id">b</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;globals&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;nonstack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">SM</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_nonstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>. <span class="tactic">apply</span> <span class="id">smatch_ge</span> <span class="kwd">with</span> (<span class="id">ab_summary</span> (<span class="id">am_stack</span> <span class="id">am</span>)). <span class="tactic">apply</span> <span class="id">BSTK</span>. <span class="tactic">apply</span> <span class="id">pge_lub_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">smatch_ge</span> <span class="kwd">with</span> <span class="id">Nonstack</span>. <span class="tactic">eapply</span> <span class="id">SM</span>. <span class="tactic">eapply</span> <span class="id">mmatch_top</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">pge_lub_r</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;below&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">apply</span> <span class="id">Plt_le_trans</span> <span class="kwd">with</span> <span class="id">bound</span>. <span class="tactic">apply</span> <span class="id">BELOW</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">genv_match_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>); <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;sp&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">dec_eq_true</span>.<br/>
- <span class="comment">(*&nbsp;unchanged&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">sp</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Plt_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">BELOW</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Construction 6: external call </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">external_call_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ef</span> (<span class="id">ge</span>: <span class="id">genv</span>) <span class="id">vargs</span> <span class="id">m</span> <span class="id">t</span> <span class="id">vres</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">rm</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">external_call</span> <span class="id">ef</span> <span class="id">ge</span> <span class="id">vargs</span> <span class="id">m</span> <span class="id">t</span> <span class="id">vres</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> <span class="id">vargs</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">Vtop</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc_nostack</span> <span class="id">bc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bc_incr</span> <span class="id">bc</span> <span class="id">bc</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt; <span class="id">bc</span>' <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">vres</span> <span class="id">Vtop</span><br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">romatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">rm</span><br/>
&nbsp;&nbsp;/\ <span class="id">mmatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">mtop</span><br/>
&nbsp;&nbsp;/\ <span class="id">bc_nostack</span> <span class="id">bc</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span>, <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCinvalid</span> -&gt; <span class="id">Mem.loadbytes</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span> = <span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3030')">Proof.</div>
<div class="proofscript" id="proof3030">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">am</span>; <span class="tactic">intros</span> <span class="id">EC</span> <span class="id">GENV</span> <span class="id">ARGS</span> <span class="id">RO</span> <span class="id">MM</span> <span class="id">NOSTACK</span>.<br/>
&nbsp;Part&nbsp;1:&nbsp;using&nbsp;ec_mem_inject&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">external_call_mem_inject</span> <span class="id">ef</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ge</span> <span class="id">vargs</span> <span class="id">m</span> <span class="id">t</span> <span class="id">vres</span> <span class="id">m</span>' (<span class="id">inj_of_bc</span> <span class="id">bc</span>) <span class="id">m</span> <span class="id">vargs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inj_of_bc_preserves_globals</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">EC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_inj</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">ARGS</span>. <span class="tactic">generalize</span> <span class="id">vargs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vargs0</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">vmatch_inj</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">vres</span>' &amp; <span class="id">m</span>'' &amp; <span class="id">EC</span>' &amp; <span class="id">IRES</span> &amp; <span class="id">IMEM</span> &amp; <span class="id">UNCH1</span> &amp; <span class="id">UNCH2</span> &amp; <span class="id">IINCR</span> &amp; <span class="id">ISEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">JBELOW</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt; <span class="id">j</span>' <span class="id">b</span> = <span class="id">inj_of_bc</span> <span class="id">bc</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">inj_of_bc</span> <span class="id">bc</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>] | ] <span class="id">eqn</span>:<span class="id">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IINCR</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>'' <span class="id">delta</span>'] | ] <span class="id">eqn</span>:<span class="id">EQ</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">ISEP</span>; <span class="tactic">eauto</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Part&nbsp;2:&nbsp;constructing&nbsp;bc'&nbsp;from&nbsp;j'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt; <span class="kwd">if</span> <span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">bc</span> <span class="id">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="kwd">match</span> <span class="id">j</span>' <span class="id">b</span> <span class="kwd">with</span> <span class="id">None</span> =&gt; <span class="id">BCinvalid</span> | <span class="id">Some</span> <span class="id">_</span> =&gt; <span class="id">BCother</span> <span class="kwd">end</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCstack</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCstack</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)); <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>); <span class="tactic">discriminate</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> (<span class="id">bc_stack</span> <span class="id">bc</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)); <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>); <span class="tactic">discriminate</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> (<span class="id">bc_glob</span> <span class="id">bc</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span>' := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">INCR</span>: <span class="id">bc_incr</span> <span class="id">bc</span> <span class="id">bc</span>').<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">pred_dec_true</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">BC</span>'<span class="id">INV</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">bc</span>' <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span> -&gt; <span class="id">exists</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>, 0. <span class="tactic">rewrite</span> <span class="id">JBELOW</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">inj_of_bc_valid</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>] | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>', <span class="id">delta</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;Part&nbsp;3:&nbsp;injection&nbsp;wrt&nbsp;j'&nbsp;implies&nbsp;matching&nbsp;with&nbsp;top&nbsp;wrt&nbsp;bc'&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PMTOP</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span> <span class="id">ofs</span>, <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span> (<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">pmatch</span> <span class="id">bc</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">constructor</span>. <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">JBELOW</span> <span class="kwd">in</span> <span class="id">H</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">inj_of_bc_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VMTOP</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">v</span>', <span class="id">Val.inject</span> <span class="id">j</span>' <span class="id">v</span> <span class="id">v</span>' -&gt; <span class="id">vmatch</span> <span class="id">bc</span>' <span class="id">v</span> <span class="id">Vtop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>. <span class="tactic">eapply</span> <span class="id">PMTOP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SMTOP</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">bc</span>' <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span> -&gt; <span class="id">smatch</span> <span class="id">bc</span>' <span class="id">m</span>' <span class="id">b</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">BC</span>'<span class="id">INV</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">delta</span> &amp; <span class="id">J</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_inject</span>. <span class="id">eexact</span> <span class="id">IMEM</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VMTOP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id">exploit</span> <span class="id">BC</span>'<span class="id">INV</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>'' &amp; <span class="id">delta</span> &amp; <span class="id">J</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_inject</span>. <span class="id">eexact</span> <span class="id">IMEM</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bytes</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">B</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H7</span>. <span class="tactic">eapply</span> <span class="id">PMTOP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>'; <span class="id">splitall</span>.<br/>
- <span class="comment">(*&nbsp;incr&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">INCR</span>.<br/>
- <span class="comment">(*&nbsp;unchanged&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">pred_dec_true</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;vmatch&nbsp;res&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">VMTOP</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;genv&nbsp;match&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">genv_match_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)). <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>). <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;romatch&nbsp;m'&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">RO</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">R</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">bmatch_incr</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_unchanged_on_1</span>. <span class="tactic">eapply</span> <span class="id">external_call_readonly</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">intros</span>; <span class="tactic">red</span>. <span class="tactic">apply</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">elim</span> (<span class="id">Q</span> <span class="id">ofs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_max_perm</span> <span class="kwd">with</span> (<span class="id">m2</span> := <span class="id">m</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;mmatch&nbsp;top&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">ablock_init_sound</span>. <span class="tactic">apply</span> <span class="id">SMTOP</span>. <span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">SMTOP</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">SMTOP</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Plt_le_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">bx</span> <span class="id">deltax</span>] | ] <span class="id">eqn</span>:<span class="id">J</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;nostack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NOSTACK</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">j</span>' <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;unmapped&nbsp;blocks&nbsp;are&nbsp;invariant&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_unchanged_on_1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">UNCH1</span>; <span class="tactic">auto</span>. <span class="tactic">intros</span>; <span class="tactic">red</span>. <span class="tactic">unfold</span> <span class="id">inj_of_bc</span>; <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">list_forall2_in_l</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span>: <span class="kwd">Type</span>) (<span class="id">P</span>: <span class="id">A</span> -&gt; <span class="id">B</span> -&gt; <span class="kwd">Prop</span>) <span class="id">x1</span> <span class="id">l1</span> <span class="id">l2</span>,<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">P</span> <span class="id">l1</span> <span class="id">l2</span> -&gt; <span class="id">In</span> <span class="id">x1</span> <span class="id">l1</span> -&gt; <span class="id">exists</span> <span class="id">x2</span>, <span class="id">In</span> <span class="id">x2</span> <span class="id">l2</span> /\ <span class="id">P</span> <span class="id">x1</span> <span class="id">x2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3031')">Proof.</div>
<div class="proofscript" id="proof3031">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">contradiction</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">subst</span>. <span class="id">exists</span> <span class="id">b1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">IHlist_forall2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">x2</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>). <span class="id">exists</span> <span class="id">x2</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Semantic invariant </h2>
<br/>
<span class="kwd">Section</span> <span class="id">SOUNDNESS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">rm</span> := <span class="id">romem_for</span> <span class="id">prog</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">sound_stack</span>: <span class="id">block_classification</span> -&gt; <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">mem</span> -&gt; <span class="id">block</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">sound_stack_nil</span>: <span class="kwd">forall</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">nil</span> <span class="id">m</span> <span class="id">bound</span><br/>
&nbsp;&nbsp;| <span class="id">sound_stack_public_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">bc</span>: <span class="id">block_classification</span>) <span class="id">res</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">bc</span>' <span class="id">bound</span>' <span class="id">ae</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">sound_stack</span> <span class="id">bc</span>' <span class="id">stk</span> <span class="id">m</span> <span class="id">sp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INCR</span>: <span class="id">Ple</span> <span class="id">bound</span>' <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BELOW</span>: <span class="id">bc_below</span> <span class="id">bc</span>' <span class="id">bound</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCother</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>': <span class="id">bc</span>' <span class="id">sp</span> = <span class="id">BCstack</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SAME</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>' -&gt; <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">bc</span>' <span class="id">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GE</span>: <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AN</span>: <span class="id">VA.ge</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">pc</span> (<span class="id">VA.State</span> (<span class="id">AE.set</span> <span class="id">res</span> <span class="id">Vtop</span> <span class="id">ae</span>) <span class="id">mafter_public_call</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EM</span>: <span class="id">ematch</span> <span class="id">bc</span>' <span class="id">e</span> <span class="id">ae</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> (<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> :: <span class="id">stk</span>) <span class="id">m</span> <span class="id">bound</span><br/>
&nbsp;&nbsp;| <span class="id">sound_stack_private_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">bc</span>: <span class="id">block_classification</span>) <span class="id">res</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">bc</span>' <span class="id">bound</span>' <span class="id">ae</span> <span class="id">am</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">sound_stack</span> <span class="id">bc</span>' <span class="id">stk</span> <span class="id">m</span> <span class="id">sp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INCR</span>: <span class="id">Ple</span> <span class="id">bound</span>' <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BELOW</span>: <span class="id">bc_below</span> <span class="id">bc</span>' <span class="id">bound</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCinvalid</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>': <span class="id">bc</span>' <span class="id">sp</span> = <span class="id">BCstack</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SAME</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>' -&gt; <span class="id">b</span> &lt;&gt; <span class="id">sp</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">bc</span>' <span class="id">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GE</span>: <span class="id">genv_match</span> <span class="id">bc</span>' <span class="id">ge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AN</span>: <span class="id">VA.ge</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">pc</span> (<span class="id">VA.State</span> (<span class="id">AE.set</span> <span class="id">res</span> (<span class="id">Ifptr</span> <span class="id">Nonstack</span>) <span class="id">ae</span>) (<span class="id">mafter_private_call</span> <span class="id">am</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EM</span>: <span class="id">ematch</span> <span class="id">bc</span>' <span class="id">e</span> <span class="id">ae</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">CONTENTS</span>: <span class="id">bmatch</span> <span class="id">bc</span>' <span class="id">m</span> <span class="id">sp</span> <span class="id">am</span>.(<span class="id">am_stack</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> (<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> :: <span class="id">stk</span>) <span class="id">m</span> <span class="id">bound</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">sound_state_base</span>: <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">sound_regular_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">bc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">s</span> <span class="id">m</span> <span class="id">sp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AN</span>: (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EM</span>: <span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span> <span class="id">ae</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RO</span>: <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MM</span>: <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GE</span>: <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SP</span>: <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_state_base</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">sound_call_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">m</span> <span class="id">bc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">s</span> <span class="id">m</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> <span class="id">args</span> -&gt; <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">Vtop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RO</span>: <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MM</span>: <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">mtop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GE</span>: <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOSTK</span>: <span class="id">bc_nostack</span> <span class="id">bc</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_state_base</span> (<span class="id">Callstate</span> <span class="id">s</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">sound_return_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span> <span class="id">bc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">s</span> <span class="id">m</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RES</span>: <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> <span class="id">Vtop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RO</span>: <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MM</span>: <span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">mtop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GE</span>: <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NOSTK</span>: <span class="id">bc_nostack</span> <span class="id">bc</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_state_base</span> (<span class="id">Returnstate</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span>).<br/>
<br/>
<div class="doc">Properties of the <span class="bracket"><span class="id">sound_stack</span></span> invariant on call stacks. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_ext</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span> <span class="id">bytes</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCinvalid</span> -&gt; <span class="id">n</span> &gt;= 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.loadbytes</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">bytes</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">bytes</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span>' <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3032')">Proof.</div>
<div class="proofscript" id="proof3032">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">INV</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">sp</span> <span class="id">bound</span>') <span class="tactic">by</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_public_call</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">IHsound_stack</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">INV</span>. <span class="id">xomega</span>. <span class="tactic">rewrite</span> <span class="id">SAME</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">sp</span> <span class="id">bound</span>') <span class="tactic">by</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_private_call</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">IHsound_stack</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">INV</span>. <span class="id">xomega</span>. <span class="tactic">rewrite</span> <span class="id">SAME</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_ext</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">INV</span>. <span class="id">xomega</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCinvalid</span> -&gt; <span class="id">n</span> &gt;= 0 -&gt; <span class="id">Mem.loadbytes</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span> = <span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span>' <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3033')">Proof.</div>
<div class="proofscript" id="proof3033">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">sound_stack_ext</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_storev</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">addr</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">aaddr</span> <span class="id">stk</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.storev</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">addr</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">addr</span> <span class="id">aaddr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span>' <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3034')">Proof.</div>
<div class="proofscript" id="proof3034">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">addr</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">i</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eapply</span> <span class="id">pmatch_top</span>'; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_store_other</span>; <span class="tactic">eauto</span>. <span class="id">left</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_storebytes</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">bytes</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">aaddr</span> <span class="id">stk</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.storebytes</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) <span class="id">bytes</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) <span class="id">aaddr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span>' <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3035')">Proof.</div>
<div class="proofscript" id="proof3035">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Ptop</span>).<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eapply</span> <span class="id">pmatch_top</span>'; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_storebytes_other</span>; <span class="tactic">eauto</span>. <span class="id">left</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_free</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">stk</span> <span class="id">bound</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span>' <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3036')">Proof.</div>
<div class="proofscript" id="proof3036">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">sound_stack_ext</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_free_2</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_new_bound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">bound</span>',<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> <span class="id">bound</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3037')">Proof.</div>
<div class="proofscript" id="proof3037">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">sound_stack_public_call</span> <span class="kwd">with</span> (<span class="id">bound</span>' := <span class="id">bound</span>'0); <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">sound_stack_private_call</span> <span class="kwd">with</span> (<span class="id">bound</span>' := <span class="id">bound</span>'0); <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_stack_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> (<span class="id">bc1</span>: <span class="id">block_classification</span>),<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">bc1</span> <span class="id">b</span> = <span class="id">bc</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc1</span> <span class="id">stk</span> <span class="id">m</span> <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3038')">Proof.</div>
<div class="proofscript" id="proof3038">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">sp</span> <span class="id">bound</span>') <span class="tactic">by</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_public_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">sp</span> <span class="id">bound</span>') <span class="tactic">by</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_private_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<h2> Preservation of the semantic invariant by one step of execution </h2>
<br/>
<span class="kwd">Lemma</span> <span class="id">sound_succ_state</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">instr</span> <span class="id">ae</span>' <span class="id">am</span>'  <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span>' <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;(<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">instr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">pc</span>' (<span class="id">successors_instr</span> <span class="id">instr</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">VA.State</span> <span class="id">ae</span>' <span class="id">am</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">e</span>' <span class="id">ae</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">am</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_stack</span> <span class="id">bc</span> <span class="id">s</span> <span class="id">m</span>' <span class="id">sp</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sound_state_base</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' <span class="id">e</span>' <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3039')">Proof.</div>
<div class="proofscript" id="proof3039">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">analyze_succ</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">ae</span>'' &amp; <span class="id">am</span>'' &amp; <span class="id">AN</span> &amp; <span class="id">EM</span> &amp; <span class="id">MM</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">sound_step_base</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">t</span> <span class="id">st</span>', <span class="id">RTL.step</span> <span class="id">ge</span> <span class="id">st</span> <span class="id">t</span> <span class="id">st</span>' -&gt; <span class="id">sound_state_base</span> <span class="id">st</span> -&gt; <span class="id">sound_state_base</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3040')">Proof.</div>
<div class="proofscript" id="proof3040">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">SOUND</span>; <span class="id">inv</span> <span class="id">SOUND</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;nop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;op&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ematch_update</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">eval_static_operation_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;load&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ematch_update</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">loadv_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;store&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>. <span class="tactic">intros</span> <span class="id">VMADDR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">storev_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">eapply</span> <span class="id">romatch_store</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_storev</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TR</span>: <span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">transfer_call</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">args</span> <span class="id">res</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer_call</span>, <span class="id">analyze_call</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">pincl</span> (<span class="id">am_nonstack</span> <span class="id">am</span>) <span class="id">Nonstack</span> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">forallb</span> (<span class="kwd">fun</span> <span class="id">av</span> =&gt; <span class="id">vpincl</span> <span class="id">av</span> <span class="id">Nonstack</span>) (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>)) <span class="id">eqn</span>:<span class="id">NOLEAK</span>.<br/>
+ <span class="comment">(*&nbsp;private&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">InvBooleans</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">analyze_successor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">TR</span>. <span class="tactic">intros</span> <span class="id">SUCC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">hide_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">pincl_ge</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_call_state</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">sound_stack_private_call</span> <span class="kwd">with</span> (<span class="id">bound</span>' := <span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">bc</span>' := <span class="id">bc</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">r</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">D</span> <span class="kwd">with</span> (<span class="id">areg</span> <span class="id">ae</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">forallb_forall</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">vpincl_ge</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
+ <span class="comment">(*&nbsp;public&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">analyze_successor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">TR</span>. <span class="tactic">intros</span> <span class="id">SUCC</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">anonymize_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_call_state</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">sound_stack_public_call</span> <span class="kwd">with</span> (<span class="id">bound</span>' := <span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">bc</span>' := <span class="id">bc</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">r</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">D</span> <span class="kwd">with</span> (<span class="id">areg</span> <span class="id">ae</span> <span class="id">r</span>). <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;tailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">anonymize_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_call_state</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.nextblock_free</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_new_bound</span> <span class="kwd">with</span> <span class="id">stk</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_free</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">C</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">r</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">D</span> <span class="kwd">with</span> (<span class="id">areg</span> <span class="id">ae</span> <span class="id">r</span>). <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">romatch_free</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_free</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;builtin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SPVALID</span>: <span class="id">Plt</span> <span class="id">sp0</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TR</span>: <span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">transfer_builtin</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;The&nbsp;default&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DEFAULT</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transfer</span> <span class="id">f</span> <span class="id">rm</span> <span class="id">pc</span> <span class="id">ae</span> <span class="id">am</span> = <span class="id">transfer_builtin_default</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">args</span> <span class="id">res</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_state_base</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">vres</span> <span class="id">rs</span>) <span class="id">m</span>')).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">transfer_builtin_default</span>, <span class="id">analyze_call</span>; <span class="tactic">intros</span> <span class="id">TR</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">aargs</span> := <span class="id">map</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span>) <span class="id">args</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ARGS</span>: <span class="id">list_forall2</span> (<span class="id">vmatch</span> <span class="id">bc</span>) <span class="id">vargs</span> <span class="id">aargs</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">abuiltin_args_sound</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">pincl</span> (<span class="id">am_nonstack</span> <span class="id">am</span>) <span class="id">Nonstack</span> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">forallb</span> (<span class="kwd">fun</span> <span class="id">av</span> =&gt; <span class="id">vpincl</span> <span class="id">av</span> <span class="id">Nonstack</span>) <span class="id">aargs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eqn</span>: <span class="id">NOLEAK</span>.<br/>
* <span class="comment">(*&nbsp;private&nbsp;builtin&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">InvBooleans</span>. <span class="tactic">rewrite</span> <span class="id">forallb_forall</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">hide_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">pincl_ge</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc1</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_match</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_forall2_in_l</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">av</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">D</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>. <span class="tactic">apply</span> <span class="id">vpincl_ge</span>. <span class="tactic">apply</span> <span class="id">H3</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc2</span> &amp; <span class="id">J</span> &amp; <span class="id">K</span> &amp; <span class="id">L</span> &amp; <span class="id">M</span> &amp; <span class="id">N</span> &amp; <span class="id">O</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">return_from_private_call</span> <span class="id">bc</span> <span class="id">bc2</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">K</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">K</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m</span>. <span class="tactic">eapply</span> <span class="id">mmatch_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Q</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc3</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span> &amp; <span class="id">W</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span> &amp; <span class="id">Z</span> &amp; <span class="id">AA</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span> <span class="kwd">with</span> (<span class="id">bc</span> := <span class="id">bc3</span>); <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Q</span>. <span class="tactic">red</span>. <span class="tactic">eapply</span> <span class="id">Plt_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">AA</span>.<br/>
* <span class="comment">(*&nbsp;public&nbsp;builtin&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">anonymize_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc1</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_match</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_forall2_in_l</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">av</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>). <span class="tactic">eapply</span> <span class="id">D</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc2</span> &amp; <span class="id">J</span> &amp; <span class="id">K</span> &amp; <span class="id">L</span> &amp; <span class="id">M</span> &amp; <span class="id">N</span> &amp; <span class="id">O</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">return_from_public_call</span> <span class="id">bc</span> <span class="id">bc2</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">K</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">K</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc3</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span> &amp; <span class="id">W</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span> &amp; <span class="id">Z</span> &amp; <span class="id">AA</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span> <span class="kwd">with</span> (<span class="id">bc</span> := <span class="id">bc3</span>); <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Q</span>. <span class="tactic">red</span>. <span class="tactic">eapply</span> <span class="id">Plt_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">AA</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer_builtin</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ef</span>; <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;volatile&nbsp;load&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">abuiltin_arg_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">VM1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;* <span class="comment">(*&nbsp;true&nbsp;volatile&nbsp;access&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">V</span>: <span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">Ifptr</span> <span class="id">Glob</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">H4</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">constructor</span>. <span class="id">econstructor</span>. <span class="tactic">eapply</span> <span class="id">GE</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">va_strict</span> <span class="id">tt</span>). <span class="tactic">apply</span> <span class="id">vmatch_lub_r</span>. <span class="tactic">apply</span> <span class="id">vnormalize_sound</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">vnormalize_sound</span>. <span class="tactic">eapply</span> <span class="id">vmatch_ge</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;* <span class="comment">(*&nbsp;normal&nbsp;memory&nbsp;access&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadv_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">V</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">va_strict</span> <span class="id">tt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">vmatch_lub_l</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">vnormalize_cast</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">vmatch_top</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;volatile&nbsp;store&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H4</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">abuiltin_arg_sound</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">intros</span> <span class="id">VM1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">abuiltin_arg_sound</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H2</span>. <span class="tactic">intros</span> <span class="id">VM2</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H9</span>.<br/>
&nbsp;&nbsp;* <span class="comment">(*&nbsp;true&nbsp;volatile&nbsp;access&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mmatch_lub_l</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="comment">(*&nbsp;normal&nbsp;memory&nbsp;access&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mmatch_lub_r</span>. <span class="tactic">eapply</span> <span class="id">storev_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">romatch_store</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_storev</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;memcpy&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H4</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">abuiltin_arg_sound</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">intros</span> <span class="id">VM1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">abuiltin_arg_sound</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H2</span>. <span class="tactic">intros</span> <span class="id">VM2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">storebytes_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">loadbytes_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">romatch_storebytes</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_storebytes</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;annot&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
+ <span class="comment">(*&nbsp;annot&nbsp;val&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">abuiltin_arg_sound</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;debug&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">set_builtin_res_sound</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;cond&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;jumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_succ_state</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">list_nth_z_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">anonymize_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_return_state</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.nextblock_free</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_new_bound</span> <span class="kwd">with</span> <span class="id">stk</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_stack_free</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">C</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>. <span class="tactic">eapply</span> <span class="id">mmatch_below</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">or</span>; <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">D</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">romatch_free</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">mmatch_free</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">allocate_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">analyze_entrypoint</span> <span class="id">rm</span> <span class="id">f</span> <span class="id">args</span> <span class="id">m</span>' <span class="id">bc</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">ae</span> &amp; <span class="id">am</span> &amp; <span class="id">AN</span> &amp; <span class="id">EM</span> &amp; <span class="id">MM</span>').<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Mem.alloc_result</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_alloc_unchanged</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">F</span>. <span class="id">erewrite</span> <span class="id">Mem.alloc_result</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_match</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span> &amp; <span class="id">K</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_new_bound</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_inv</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STK</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;from&nbsp;public&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">return_from_public_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">rewrite</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc1</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)#<span class="id">pc</span> <span class="kwd">as</span> [ |<span class="id">ae</span>' <span class="id">am</span>'] <span class="id">eqn</span>:<span class="id">EQ</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">AN</span>; <span class="tactic">try</span> <span class="id">contradiction</span>. <span class="tactic">destruct</span> <span class="id">AN</span> <span class="kwd">as</span> [<span class="id">A1</span> <span class="id">A2</span>].<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_regular_state</span> <span class="kwd">with</span> (<span class="id">bc</span> := <span class="id">bc1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ematch_ge</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">ematch_update</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;from&nbsp;private&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">return_from_private_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">rewrite</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bc1</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">analyze</span> <span class="id">rm</span> <span class="id">f</span>)#<span class="id">pc</span> <span class="kwd">as</span> [ |<span class="id">ae</span>' <span class="id">am</span>'] <span class="id">eqn</span>:<span class="id">EQ</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">AN</span>; <span class="tactic">try</span> <span class="id">contradiction</span>. <span class="tactic">destruct</span> <span class="id">AN</span> <span class="kwd">as</span> [<span class="id">A1</span> <span class="id">A2</span>].<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sound_regular_state</span> <span class="kwd">with</span> (<span class="id">bc</span> := <span class="id">bc1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sound_stack_exten</span> <span class="kwd">with</span> <span class="id">bc</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ematch_ge</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">ematch_update</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SOUNDNESS</span>.<br/>
<br/>
<h2> Extension to separate compilation </h2>
<br/>
<div class="doc">Following Kang et al, POPL 2016, we now extend the results above 
  to the case where only one compilation unit is analyzed, and not the
  whole program.  </div>
<br/>
<span class="kwd">Section</span> <span class="id">LINKING</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">sound_state</span>: <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">sound_state_intro</span>: <span class="kwd">forall</span> <span class="id">st</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">cunit</span>, <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt; <span class="id">sound_state_base</span> <span class="id">cunit</span> <span class="id">ge</span> <span class="id">st</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">st</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">sound_step</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">t</span> <span class="id">st</span>', <span class="id">RTL.step</span> <span class="id">ge</span> <span class="id">st</span> <span class="id">t</span> <span class="id">st</span>' -&gt; <span class="id">sound_state</span> <span class="id">st</span> -&gt; <span class="id">sound_state</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3041')">Proof.</div>
<div class="proofscript" id="proof3041">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">sound_step_base</span>; <span class="tactic">eauto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">sound_state_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">cunit</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">st</span> -&gt; <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt; <span class="id">sound_state_base</span> <span class="id">cunit</span> <span class="id">ge</span> <span class="id">st</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3042')">Proof.</div>
<div class="proofscript" id="proof3042">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">eauto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">LINKING</span>.<br/>
<br/>
<h2> Soundness of the initial memory abstraction </h2>
<br/>
<span class="kwd">Section</span> <span class="id">INITIAL</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">program</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">initial_block_classification</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.init_mem</span> <span class="id">prog</span> = <span class="id">Some</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">bc_below</span> <span class="id">bc</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc_nostack</span> <span class="id">bc</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">id</span>, <span class="id">bc</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span> -&gt; <span class="id">bc</span> <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3043')">Proof.</div>
<div class="proofscript" id="proof3043">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">f</span> := <span class="kwd">fun</span> <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>) <span class="kwd">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span> <span class="kwd">with</span> <span class="id">None</span> =&gt; <span class="id">BCother</span> | <span class="id">Some</span> <span class="id">id</span> =&gt; <span class="id">BCglob</span> <span class="id">id</span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">BCinvalid</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_glob</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">id</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCglob</span> <span class="id">id</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b1</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b1</span>) <span class="kwd">as</span> [<span class="id">id1</span>|] <span class="id">eqn</span>:<span class="id">I1</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b2</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b2</span>) <span class="kwd">as</span> [<span class="id">id2</span>|] <span class="id">eqn</span>:<span class="id">I2</span>; <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.invert_find_symbol</span>. <span class="id">eexact</span> <span class="id">I1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.invert_find_symbol</span>. <span class="id">eexact</span> <span class="id">I2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">F_stack</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">BCstack</span> -&gt; <span class="id">f</span> <span class="id">b2</span> = <span class="id">BCstack</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">f</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b1</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b1</span>); <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">bc</span> := <span class="id">BC</span> <span class="id">f</span> <span class="id">F_stack</span> <span class="id">F_glob</span>). <span class="tactic">unfold</span> <span class="id">f</span> <span class="kwd">in</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>; <span class="id">splitall</span>.<br/>
- <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_symb_range</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Genv.find_invert_symbol</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">Genv.invert_find_symbol</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">rewrite</span> ! <span class="id">pred_dec_true</span> <span class="tactic">by</span> <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span>); <span class="tactic">split</span>; <span class="tactic">congruence</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">Genv.init_mem_genv_next</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
- <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span>) <span class="kwd">as</span> [<span class="id">id</span>' | ] <span class="id">eqn</span>:<span class="id">IS</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv.invert_find_symbol</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">ge</span>; <span class="id">erewrite</span> <span class="id">Genv.init_mem_genv_next</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>) <span class="id">b</span>); <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">INIT</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">bc</span>: <span class="id">block_classification</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">GMATCH</span>: <span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_summary</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Glob</span> (<span class="id">ab_summary</span> <span class="id">ab</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Glob</span> (<span class="id">ab_summary</span> (<span class="id">store_init_data</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">id</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3044')">Proof.</div>
<div class="proofscript" id="proof3044">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DFL</span>: <span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">av</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vge</span> (<span class="id">Ifptr</span> <span class="id">Glob</span>) <span class="id">av</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Glob</span> (<span class="id">ab_summary</span> (<span class="id">ablock_store</span> <span class="id">chunk</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">av</span>))).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">vplub</span>; <span class="tactic">destruct</span> <span class="id">av</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">plub_least</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">plub_least</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">propagate_float_constants</span> <span class="id">tt</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">propagate_float_constants</span> <span class="id">tt</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">DFL</span>. <span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_list_summary</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">idl</span> <span class="id">ab</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Glob</span> (<span class="id">ab_summary</span> <span class="id">ab</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">pge</span> <span class="id">Glob</span> (<span class="id">ab_summary</span> (<span class="id">store_init_data_list</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">idl</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3045')">Proof.</div>
<div class="proofscript" id="proof3045">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">idl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">IHidl</span>. <span class="tactic">apply</span> <span class="id">store_init_data_summary</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">id</span> <span class="id">m</span>' <span class="id">ab</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.store_init_data</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span> (<span class="id">store_init_data</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">id</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3046')">Proof.</div>
<div class="proofscript" id="proof3046">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">id</span>; <span class="tactic">try</span> (<span class="tactic">eapply</span> <span class="id">ablock_store_sound</span>; <span class="tactic">eauto</span>; <span class="id">constructor</span>).<br/>
- <span class="comment">(*&nbsp;float32&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">propagate_float_constants</span> <span class="id">tt</span>); <span class="tactic">eapply</span> <span class="id">ablock_store_sound</span>; <span class="tactic">eauto</span>; <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;float64&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">propagate_float_constants</span> <span class="id">tt</span>); <span class="tactic">eapply</span> <span class="id">ablock_store_sound</span>; <span class="tactic">eauto</span>; <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;space&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;addrof&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>) <span class="kwd">as</span> [<span class="id">b</span>'|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ablock_store_sound</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">GMATCH</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_list_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">idl</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">m</span>' <span class="id">ab</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.store_init_data_list</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">idl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span> (<span class="id">store_init_data_list</span> <span class="id">ab</span> <span class="id">p</span> <span class="id">idl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3047')">Proof.</div>
<div class="proofscript" id="proof3047">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">idl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Genv.store_init_data</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:<span class="id">SI</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHidl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">store_init_data_sound</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_other</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">id</span> <span class="id">m</span>' <span class="id">ab</span> <span class="id">b</span>',<br/>
&nbsp;&nbsp;<span class="id">Genv.store_init_data</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">b</span>' &lt;&gt; <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span>' <span class="id">ab</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3048')">Proof.</div>
<div class="proofscript" id="proof3048">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">bmatch_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">id</span>; <span class="tactic">try</span> (<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_store_other</span>; <span class="tactic">eauto</span>; <span class="tactic">fail</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_store_other</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_init_data_list_other</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">ab</span> <span class="id">idl</span> <span class="id">m</span> <span class="id">p</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Genv.store_init_data_list</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">idl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">b</span>' &lt;&gt; <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span>' <span class="id">ab</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3049')">Proof.</div>
<div class="proofscript" id="proof3049">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">idl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.store_init_data</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:<span class="id">SI</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHidl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">store_init_data_other</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_zeros_same</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">m</span> <span class="id">b</span> <span class="id">pos</span> <span class="id">n</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">store_zeros</span> <span class="id">m</span> <span class="id">b</span> <span class="id">pos</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">smatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">p</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3050')">Proof.</div>
<div class="proofscript" id="proof3050">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">n</span>. <span class="id">functional</span> <span class="tactic">induction</span> (<span class="id">store_zeros</span> <span class="id">m</span> <span class="id">b</span> <span class="id">pos</span> <span class="id">n</span>); <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">IHo</span>; <span class="tactic">eauto</span>. <span class="id">change</span> <span class="id">p</span> <span class="kwd">with</span> (<span class="id">vplub</span> (<span class="id">I</span> <span class="id">Int.zero</span>) <span class="id">p</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">smatch_store</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_zeros_other</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span>' <span class="id">ab</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">n</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">store_zeros</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">b</span>' &lt;&gt; <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span>' <span class="id">b</span>' <span class="id">ab</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3051')">Proof.</div>
<div class="proofscript" id="proof3051">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">n</span>. <span class="id">functional</span> <span class="tactic">induction</span> (<span class="id">store_zeros</span> <span class="id">m</span> <span class="id">b</span> <span class="id">p</span> <span class="id">n</span>); <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">IHo</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">bmatch_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_store_other</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">initial_mem_match</span> (<span class="id">bc</span>: <span class="id">block_classification</span>) (<span class="id">m</span>: <span class="id">mem</span>) (<span class="id">g</span>: <span class="id">genv</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">g</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">Genv.find_var_info</span> <span class="id">g</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">v</span>.(<span class="id">gvar_volatile</span>) = <span class="id">false</span> -&gt; <span class="id">v</span>.(<span class="id">gvar_readonly</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">store_init_data_list</span> (<span class="id">ablock_init</span> <span class="id">Pbot</span>) 0 <span class="id">v</span>.(<span class="id">gvar_init</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_global_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">g</span> <span class="id">idg</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Genv.genv_next</span> <span class="id">g</span> = <span class="id">Mem.nextblock</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">initial_mem_match</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">g</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.alloc_global</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">idg</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">initial_mem_match</span> <span class="id">bc</span> <span class="id">m</span>' (<span class="id">Genv.add_global</span> <span class="id">g</span> <span class="id">idg</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3052')">Proof.</div>
<div class="proofscript" id="proof3052">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">idg</span> <span class="kwd">as</span> [<span class="id">id1</span> [<span class="id">fd</span> | <span class="id">gv</span>]]; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m</span> 0 1) <span class="kwd">as</span> [<span class="id">m1</span> <span class="id">b1</span>] <span class="id">eqn</span>:<span class="id">ALLOC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_symbol</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_var_info</span>, <span class="id">Genv.find_def</span> <span class="kwd">in</span> <span class="id">H3</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gss</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">g</span>)) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_symb_range</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>). <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">red</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b</span> &lt;&gt; <span class="id">b1</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Mem.valid_not_valid_diff</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">Mem.loadbytes</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">n0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_drop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_alloc_unchanged</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">set</span> (<span class="id">sz</span> := <span class="id">init_data_list_size</span> (<span class="id">gvar_init</span> <span class="id">gv</span>)) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m</span> 0 <span class="id">sz</span>) <span class="kwd">as</span> [<span class="id">m1</span> <span class="id">b1</span>] <span class="id">eqn</span>:<span class="id">ALLOC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">store_zeros</span> <span class="id">m1</span> <span class="id">b1</span> 0 <span class="id">sz</span>) <span class="kwd">as</span> [<span class="id">m2</span> | ] <span class="id">eqn</span>:<span class="id">STZ</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.store_init_data_list</span> <span class="id">ge</span> <span class="id">m2</span> <span class="id">b1</span> 0 (<span class="id">gvar_init</span> <span class="id">gv</span>)) <span class="kwd">as</span> [<span class="id">m3</span> | ] <span class="id">eqn</span>:<span class="id">SIDL</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_symbol</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.find_var_info</span>, <span class="id">Genv.find_def</span> <span class="kwd">in</span> <span class="id">H3</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>).<br/>
+ <span class="tactic">injection</span> <span class="id">H2</span>; <span class="tactic">clear</span> <span class="id">H2</span>; <span class="tactic">intro</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ</span>, <span class="id">PTree.gss</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">injection</span> <span class="id">H3</span>; <span class="tactic">clear</span> <span class="id">H3</span>; <span class="tactic">intros</span> <span class="id">EQ</span>'; <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b</span> = <span class="id">b1</span>). { <span class="id">erewrite</span> <span class="id">Mem.alloc_result</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">EQ</span>. <span class="tactic">subst</span> <span class="id">b</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">store_init_data_list_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ablock_init_sound</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">store_zeros_same</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_alloc_same</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ</span>; <span class="tactic">subst</span> <span class="id">v</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_alloc_same</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_drop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="id">right</span>; <span class="id">right</span>. <span class="tactic">unfold</span> <span class="id">Genv.perm_globvar</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>, <span class="id">H5</span>. <span class="id">constructor</span>.<br/>
+ <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">g</span>)) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_symb_range</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>). <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">red</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b</span> &lt;&gt; <span class="id">b1</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Mem.valid_not_valid_diff</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">store_init_data_list_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">store_zeros_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">bmatch_inv</span> <span class="kwd">with</span> <span class="id">m</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_alloc_unchanged</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_drop</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_globals_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">gl</span> <span class="id">m</span> <span class="id">g</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Genv.genv_next</span> <span class="id">g</span> = <span class="id">Mem.nextblock</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">initial_mem_match</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">g</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.alloc_globals</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">gl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">initial_mem_match</span> <span class="id">bc</span> <span class="id">m</span>' (<span class="id">Genv.add_globals</span> <span class="id">g</span> <span class="id">gl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3053')">Proof.</div>
<div class="proofscript" id="proof3053">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">gl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Genv.alloc_global</span> <span class="id">ge</span> <span class="id">m</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:<span class="id">AG</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHgl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">Genv.alloc_global_nextblock</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_global_match</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">romem_consistent</span> (<span class="id">defmap</span>: <span class="id">PTree.t</span> (<span class="id">globdef</span> <span class="id">fundef</span> <span class="id">unit</span>)) (<span class="id">rm</span>: <span class="id">romem</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ab</span>,<br/>
&nbsp;&nbsp;<span class="id">rm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">ab</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">defmap</span>!<span class="id">id</span> = <span class="id">Some</span> (<span class="id">Gvar</span> <span class="id">v</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">v</span>.(<span class="id">gvar_readonly</span>) = <span class="id">true</span><br/>
&nbsp;&nbsp;/\ <span class="id">v</span>.(<span class="id">gvar_volatile</span>) = <span class="id">false</span><br/>
&nbsp;&nbsp;/\ <span class="id">definitive_initializer</span> <span class="id">v</span>.(<span class="id">gvar_init</span>) = <span class="id">true</span><br/>
&nbsp;&nbsp;/\ <span class="id">ab</span> = <span class="id">store_init_data_list</span> (<span class="id">ablock_init</span> <span class="id">Pbot</span>) 0 <span class="id">v</span>.(<span class="id">gvar_init</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_global_consistent</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">dm</span> <span class="id">rm</span> <span class="id">idg</span>,<br/>
&nbsp;&nbsp;<span class="id">romem_consistent</span> <span class="id">dm</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romem_consistent</span> (<span class="id">PTree.set</span> (<span class="id">fst</span> <span class="id">idg</span>) (<span class="id">snd</span> <span class="id">idg</span>) <span class="id">dm</span>) (<span class="id">alloc_global</span> <span class="id">rm</span> <span class="id">idg</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3054')">Proof.</div>
<div class="proofscript" id="proof3054">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">idg</span> <span class="kwd">as</span> [<span class="id">id1</span> [<span class="id">f1</span> | <span class="id">v1</span>]]; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.grspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">id</span> <span class="id">id1</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <br/>
- <span class="tactic">destruct</span> (<span class="id">gvar_readonly</span> <span class="id">v1</span> &amp;&amp; <span class="id">negb</span> (<span class="id">gvar_volatile</span> <span class="id">v1</span>) &amp;&amp; <span class="id">definitive_initializer</span> (<span class="id">gvar_init</span> <span class="id">v1</span>)) <span class="id">eqn</span>:<span class="id">RO</span>.<br/>
+ <span class="id">InvBooleans</span>. <span class="tactic">rewrite</span> <span class="id">negb_true_iff</span> <span class="kwd">in</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>).<br/>
* <span class="id">inv</span> <span class="id">H0</span>. <span class="id">exists</span> <span class="id">v1</span>; <span class="tactic">auto</span>.<br/>
* <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">PTree.grspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">id</span> <span class="id">id1</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">romem_for_consistent</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span>, <span class="id">romem_consistent</span> (<span class="id">prog_defmap</span> <span class="id">cunit</span>) (<span class="id">romem_for</span> <span class="id">cunit</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3055')">Proof.</div>
<div class="proofscript" id="proof3055">
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">REC</span>: <span class="kwd">forall</span> <span class="id">l</span> <span class="id">dm</span> <span class="id">rm</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">romem_consistent</span> <span class="id">dm</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">romem_consistent</span> (<span class="id">fold_left</span> (<span class="kwd">fun</span> <span class="id">m</span> <span class="id">idg</span> =&gt; <span class="id">PTree.set</span> (<span class="id">fst</span> <span class="id">idg</span>) (<span class="id">snd</span> <span class="id">idg</span>) <span class="id">m</span>) <span class="id">l</span> <span class="id">dm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">fold_left</span> <span class="id">alloc_global</span> <span class="id">l</span> <span class="id">rm</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">IHl</span>. <span class="tactic">apply</span> <span class="id">alloc_global_consistent</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">REC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">romem_for_consistent_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span>, <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt; <span class="id">romem_consistent</span> (<span class="id">prog_defmap</span> <span class="id">prog</span>) (<span class="id">romem_for</span> <span class="id">cunit</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3056')">Proof.</div>
<div class="proofscript" id="proof3056">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">romem_for_consistent</span> <span class="id">cunit</span>); <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">DM</span> &amp; <span class="id">RO</span> &amp; <span class="id">VO</span> &amp; <span class="id">DEFN</span> &amp; <span class="id">AB</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap_linkorder</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span> <span class="id">DM</span>) <span class="kwd">as</span> (<span class="id">gd</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">gd</span> = <span class="id">Gvar</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">Q</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">info1</span>, <span class="id">info2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>; <span class="tactic">discriminate</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">gd</span>. <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">INIT</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">initial_mem_matches</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.init_mem</span> <span class="id">prog</span> = <span class="id">Some</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span><br/>
&nbsp;&nbsp;/\ <span class="id">bc_below</span> <span class="id">bc</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc_nostack</span> <span class="id">bc</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">cunit</span>, <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt; <span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> (<span class="id">romem_for</span> <span class="id">cunit</span>))<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span> -&gt; <span class="id">bc</span> <span class="id">b</span> &lt;&gt; <span class="id">BCinvalid</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3057')">Proof.</div>
<div class="proofscript" id="proof3057">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">initial_block_classification</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bc</span> &amp; <span class="id">GE</span> &amp; <span class="id">BELOW</span> &amp; <span class="id">NOSTACK</span> &amp; <span class="id">INV</span> &amp; <span class="id">VALID</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>; <span class="id">splitall</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">initial_mem_match</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">ge</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">alloc_globals_match</span> <span class="kwd">with</span> (<span class="id">m</span> := <span class="id">Mem.empty</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">unfold</span> <span class="id">Genv.find_symbol</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">B</span>: <span class="id">romem_consistent</span> (<span class="id">prog_defmap</span> <span class="id">prog</span>) (<span class="id">romem_for</span> <span class="id">cunit</span>)) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">romem_for_consistent_2</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">B</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">DM</span> &amp; <span class="id">RO</span> &amp; <span class="id">NVOL</span> &amp; <span class="id">DEFN</span> &amp; <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span> <span class="kwd">in</span> <span class="id">DM</span>. <span class="tactic">destruct</span> <span class="id">DM</span> <span class="kwd">as</span> (<span class="id">b1</span> &amp; <span class="id">FS</span> &amp; <span class="id">FD</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_var_info_iff</span> <span class="kwd">in</span> <span class="id">FD</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b1</span> = <span class="id">b</span>). { <span class="tactic">apply</span> <span class="id">INV</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">ge</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">subst</span> <span class="id">ab</span>. <span class="tactic">apply</span> <span class="id">store_init_data_list_summary</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">subst</span> <span class="id">ab</span>. <span class="tactic">eapply</span> <span class="id">A</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.init_mem_characterization</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">Q</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.perm_globvar</span> <span class="kwd">in</span> <span class="id">V</span>; <span class="tactic">rewrite</span> <span class="id">RO</span>, <span class="id">NVOL</span> <span class="kwd">in</span> <span class="id">V</span>. <span class="id">inv</span> <span class="id">V</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">INITIAL</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Axioms</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">sound_initial</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">prog</span> <span class="id">st</span>, <span class="id">initial_state</span> <span class="id">prog</span> <span class="id">st</span> -&gt; <span class="id">sound_state</span> <span class="id">prog</span> <span class="id">st</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3058')">Proof.</div>
<div class="proofscript" id="proof3058">
&nbsp;&nbsp;<span class="tactic">destruct</span> 1.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">initial_mem_matches</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bc</span> &amp; <span class="id">GE</span> &amp; <span class="id">BELOW</span> &amp; <span class="id">NOSTACK</span> &amp; <span class="id">RM</span> &amp; <span class="id">VALID</span>).<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">sound_call_state</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">RM</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">mmatch_inj_top</span> <span class="kwd">with</span> <span class="id">m0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">inj_of_bc</span> <span class="id">bc</span>) <span class="kwd">with</span> (<span class="id">Mem.flat_inj</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.initmem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="tactic">extensionality</span>; <span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span>; <span class="tactic">intros</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">x</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inj_of_bc_valid</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">inj_of_bc</span>. <span class="id">erewrite</span> <span class="id">bc_below_invalid</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">exact</span> <span class="id">GE</span>.<br/>
- <span class="tactic">exact</span> <span class="id">NOSTACK</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">areg_sound</span> <span class="id">aregs_sound</span>: <span class="id">va</span>.<br/>
<br/>
<h1> Interface with other optimizations </h1>
<br/>
<span class="kwd">Ltac</span> <span class="id">InvSoundState</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H1</span>: <span class="id">sound_state</span> ?<span class="id">prog</span> ?<span class="id">st</span>, <span class="id">H2</span>: <span class="id">linkorder</span> ?<span class="id">cunit</span> ?<span class="id">prog</span> |- <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">S</span> := <span class="tactic">fresh</span> "<span class="id">S</span>" <span class="kwd">in</span> <span class="tactic">generalize</span> (<span class="id">sound_state_inv</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span> <span class="id">H2</span>); <span class="tactic">intros</span> <span class="id">S</span>; <span class="id">inv</span> <span class="id">S</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">avalue</span> (<span class="id">a</span>: <span class="id">VA.t</span>) (<span class="id">r</span>: <span class="id">reg</span>) : <span class="id">aval</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">Vbot</span><br/>
&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> =&gt; <span class="id">AE.get</span> <span class="id">r</span> <span class="id">ae</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">avalue_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span> <span class="id">prog</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">prog</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">e</span>#<span class="id">r</span> (<span class="id">avalue</span> (<span class="id">analyze</span> (<span class="id">romem_for</span> <span class="id">cunit</span>) <span class="id">f</span>)!!<span class="id">pc</span> <span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3059')">Proof.</div>
<div class="proofscript" id="proof3059">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">InvSoundState</span>. <span class="id">exists</span> <span class="id">bc</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">AN</span>. <span class="tactic">apply</span> <span class="id">EM</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">aaddr</span> (<span class="id">a</span>: <span class="id">VA.t</span>) (<span class="id">r</span>: <span class="id">reg</span>) : <span class="id">aptr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">Pbot</span><br/>
&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> =&gt; <span class="id">aptr_of_aval</span> (<span class="id">AE.get</span> <span class="id">r</span> <span class="id">ae</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">aaddr_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span> <span class="id">prog</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span> <span class="id">r</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">prog</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>#<span class="id">r</span> = <span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> (<span class="id">aaddr</span> (<span class="id">analyze</span> (<span class="id">romem_for</span> <span class="id">cunit</span>) <span class="id">f</span>)!!<span class="id">pc</span> <span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3060')">Proof.</div>
<div class="proofscript" id="proof3060">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">InvSoundState</span>. <span class="id">exists</span> <span class="id">bc</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">aaddr</span>; <span class="tactic">rewrite</span> <span class="id">AN</span>. <span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">EM</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">aaddressing</span> (<span class="id">a</span>: <span class="id">VA.t</span>) (<span class="id">addr</span>: <span class="id">addressing</span>) (<span class="id">args</span>: <span class="id">list</span> <span class="id">reg</span>) : <span class="id">aptr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">Pbot</span><br/>
&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> =&gt; <span class="id">aptr_of_aval</span> (<span class="id">eval_static_addressing</span> <span class="id">addr</span> (<span class="id">aregs</span> <span class="id">ae</span> <span class="id">args</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">aaddressing_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span> <span class="id">prog</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">prog</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_addressing</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">addr</span> <span class="id">e</span>##<span class="id">args</span> = <span class="id">Some</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> (<span class="id">aaddressing</span> (<span class="id">analyze</span> (<span class="id">romem_for</span> <span class="id">cunit</span>) <span class="id">f</span>)!!<span class="id">pc</span> <span class="id">addr</span> <span class="id">args</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3061')">Proof.</div>
<div class="proofscript" id="proof3061">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">InvSoundState</span>. <span class="id">exists</span> <span class="id">bc</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">aaddressing</span>. <span class="tactic">rewrite</span> <span class="id">AN</span>. <span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
Qed.</div>
<br/>
<div class="doc">This is a less precise version of <span class="bracket"><span class="id">abuiltin_arg</span></span>, where memory
    contents are not taken into account. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">aaddr_arg</span> (<span class="id">a</span>: <span class="id">VA.t</span>) (<span class="id">ba</span>: <span class="id">builtin_arg</span> <span class="id">reg</span>) : <span class="id">aptr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">VA.Bot</span> =&gt; <span class="id">Pbot</span><br/>
&nbsp;&nbsp;| <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ba</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">BA</span> <span class="id">r</span> =&gt; <span class="id">aptr_of_aval</span> (<span class="id">AE.get</span> <span class="id">r</span> <span class="id">ae</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">BA_addrstack</span> <span class="id">ofs</span> =&gt; <span class="id">Stk</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">BA_addrglobal</span> <span class="id">id</span> <span class="id">ofs</span> =&gt; <span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">Ptop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">aaddr_arg_sound_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> <span class="id">m</span> <span class="id">rm</span> <span class="id">am</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">romatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">rm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mmatch</span> <span class="id">bc</span> <span class="id">m</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> : <span class="id">positive</span> =&gt; <span class="id">rs</span> # <span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">a</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> (<span class="id">aaddr_arg</span> (<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span>) <span class="id">a</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3062')">Proof.</div>
<div class="proofscript" id="proof3062">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pmatch_ge</span> <span class="kwd">with</span> (<span class="id">aptr_of_aval</span> (<span class="id">abuiltin_arg</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">rm</span> <span class="id">a</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">pge_top</span>); <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">pge_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>. <span class="tactic">eapply</span> <span class="id">abuiltin_arg_sound</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">aaddr_arg_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span> <span class="id">prog</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">sound_state</span> <span class="id">prog</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">e</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>) (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">e</span>#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">a</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> (<span class="id">aaddr_arg</span> (<span class="id">analyze</span> (<span class="id">romem_for</span> <span class="id">cunit</span>) <span class="id">f</span>)!!<span class="id">pc</span> <span class="id">a</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">genv_match</span> <span class="id">bc</span> (<span class="id">Genv.globalenv</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3063')">Proof.</div>
<div class="proofscript" id="proof3063">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">InvSoundState</span>. <span class="tactic">rewrite</span> <span class="id">AN</span>. <span class="id">exists</span> <span class="id">bc</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">aaddr_arg_sound_1</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
