<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Unusedglobproof</title>
<meta name="description" content="Documentation of Coq module Unusedglobproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Unusedglobproof</h1>
<div class="coq">
<br/>
<div class="doc">Elimination of unreferenced static definitions </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSets</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Ordered</span> <span class="id">Iteration</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Globalenvs</span> <span class="id">Events</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Registers</span> <span class="id">RTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Unusedglob</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">ISF</span> := <span class="id">FSetFacts.Facts</span>(<span class="id">IS</span>).<br/>
<span class="kwd">Module</span> <span class="id">ISP</span> := <span class="id">FSetProperties.Properties</span>(<span class="id">IS</span>).<br/>
<br/>
<h1> Relational specification of the transformation </h1>
<br/>
<div class="doc">The transformed program is obtained from the original program
  by keeping only the global definitions that belong to a given
  set <span class="bracket"><span class="id">u</span></span> of names.  </div>
<br/>
<span class="kwd">Record</span> <span class="id">match_prog_1</span> (<span class="id">u</span>: <span class="id">IS.t</span>) (<span class="id">p</span> <span class="id">tp</span>: <span class="id">program</span>) : <span class="kwd">Prop</span> := {<br/>
&nbsp;&nbsp;<span class="id">match_prog_main</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tp</span>.(<span class="id">prog_main</span>) = <span class="id">p</span>.(<span class="id">prog_main</span>);<br/>
&nbsp;&nbsp;<span class="id">match_prog_public</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tp</span>.(<span class="id">prog_public</span>) = <span class="id">p</span>.(<span class="id">prog_public</span>);<br/>
&nbsp;&nbsp;<span class="id">match_prog_def</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">prog_defmap</span> <span class="id">tp</span>)!<span class="id">id</span> = <span class="kwd">if</span> <span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span> <span class="kwd">then</span> (<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> <span class="kwd">else</span> <span class="id">None</span>;<br/>
&nbsp;&nbsp;<span class="id">match_prog_unique</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">prog_defs_names</span> <span class="id">tp</span>)<br/>
}.<br/>
<br/>
<div class="doc">This set <span class="bracket"><span class="id">u</span></span> (as "used") must be closed under references, and
  contain the entry point and the public identifiers of the program. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">ref_function</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">pc</span> <span class="id">i</span>, <span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span> /\ <span class="id">In</span> <span class="id">id</span> (<span class="id">ref_instruction</span> <span class="id">i</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ref_fundef</span> (<span class="id">fd</span>: <span class="id">fundef</span>) (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">fd</span> <span class="kwd">with</span> <span class="id">Internal</span> <span class="id">f</span> =&gt; <span class="id">ref_function</span> <span class="id">f</span> <span class="id">id</span> | <span class="id">External</span> <span class="id">ef</span> =&gt; <span class="id">False</span> <span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ref_init</span> (<span class="id">il</span>: <span class="id">list</span> <span class="id">init_data</span>) (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>, <span class="id">In</span> (<span class="id">Init_addrof</span> <span class="id">id</span> <span class="id">ofs</span>) <span class="id">il</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ref_def</span> (<span class="id">gd</span>: <span class="id">globdef</span> <span class="id">fundef</span> <span class="id">unit</span>) (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">gd</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Gfun</span> <span class="id">fd</span> =&gt; <span class="id">ref_fundef</span> <span class="id">fd</span> <span class="id">id</span><br/>
&nbsp;&nbsp;| <span class="id">Gvar</span> <span class="id">gv</span> =&gt; <span class="id">ref_init</span> <span class="id">gv</span>.(<span class="id">gvar_init</span>) <span class="id">id</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">valid_used_set</span> (<span class="id">p</span>: <span class="id">program</span>) (<span class="id">u</span>: <span class="id">IS.t</span>) : <span class="kwd">Prop</span> := {<br/>
&nbsp;&nbsp;<span class="id">used_closed</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">gd</span> <span class="id">id</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">u</span> -&gt; (<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span>' <span class="id">u</span>;<br/>
&nbsp;&nbsp;<span class="id">used_main</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">p</span>.(<span class="id">prog_main</span>) <span class="id">u</span>;<br/>
&nbsp;&nbsp;<span class="id">used_public</span>: <span class="kwd">forall</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> <span class="id">p</span>.(<span class="id">prog_public</span>) -&gt; <span class="id">IS.In</span> <span class="id">id</span> <span class="id">u</span>;<br/>
&nbsp;&nbsp;<span class="id">used_defined</span>: <span class="kwd">forall</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">u</span> -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">prog_defs_names</span> <span class="id">p</span>) \/ <span class="id">id</span> = <span class="id">p</span>.(<span class="id">prog_main</span>)<br/>
}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span> <span class="id">tp</span>: <span class="id">program</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">u</span>: <span class="id">IS.t</span>, <span class="id">valid_used_set</span> <span class="id">p</span> <span class="id">u</span> /\ <span class="id">match_prog_1</span> <span class="id">u</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<h1> Properties of the static analysis </h1>
<br/>
<div class="doc">Monotonic evolution of the workset. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">workset_incl</span> (<span class="id">w1</span> <span class="id">w2</span>: <span class="id">workset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">workset_incl_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">SEEN</span>: <span class="id">IS.Subset</span> <span class="id">w1</span>.(<span class="id">w_seen</span>) <span class="id">w2</span>.(<span class="id">w_seen</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TODO</span>: <span class="id">List.incl</span> <span class="id">w1</span>.(<span class="id">w_todo</span>) <span class="id">w2</span>.(<span class="id">w_todo</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRACK</span>: <span class="kwd">forall</span> <span class="id">id</span>, <span class="id">IS.In</span> <span class="id">id</span> <span class="id">w2</span>.(<span class="id">w_seen</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">w1</span>.(<span class="id">w_seen</span>) \/ <span class="id">List.In</span> <span class="id">id</span> <span class="id">w2</span>.(<span class="id">w_todo</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">workset_incl</span> <span class="id">w1</span> <span class="id">w2</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_workset_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">w1</span> <span class="id">w2</span> <span class="id">id</span>, <span class="id">workset_incl</span> <span class="id">w1</span> <span class="id">w2</span> -&gt; <span class="id">IS.In</span> <span class="id">id</span> <span class="id">w1</span> -&gt; <span class="id">IS.In</span> <span class="id">id</span> <span class="id">w2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3325')">Proof.</div>
<div class="proofscript" id="proof3325">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">workset_incl_refl</span>: <span class="kwd">forall</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> <span class="id">w</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3326')">Proof.</div>
<div class="proofscript" id="proof3326">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">workset_incl_trans</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">w1</span> <span class="id">w2</span> <span class="id">w3</span>, <span class="id">workset_incl</span> <span class="id">w1</span> <span class="id">w2</span> -&gt; <span class="id">workset_incl</span> <span class="id">w2</span> <span class="id">w3</span> -&gt; <span class="id">workset_incl</span> <span class="id">w1</span> <span class="id">w3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3327')">Proof.</div>
<div class="proofscript" id="proof3327">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>, <span class="id">H0</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">edestruct</span> <span class="id">TRACK0</span>; <span class="tactic">eauto</span>. <span class="id">edestruct</span> <span class="id">TRACK</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_workset_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> (<span class="id">add_workset</span> <span class="id">id</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3328')">Proof.</div>
<div class="proofscript" id="proof3328">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_workset</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">w</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
- <span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
- <span class="tactic">split</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">IS.add_2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id</span> <span class="id">id0</span>); <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">IS.add_3</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">addlist_workset_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> (<span class="id">addlist_workset</span> <span class="id">l</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3329')">Proof.</div>
<div class="proofscript" id="proof3329">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">workset_incl_trans</span>. <span class="tactic">apply</span> <span class="id">add_workset_incl</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_ref_function_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> (<span class="id">add_ref_function</span> <span class="id">f</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3330')">Proof.</div>
<div class="proofscript" id="proof3330">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_function</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PTree_Properties.fold_rec</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">workset_incl_trans</span> <span class="kwd">with</span> <span class="id">a</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_instruction</span>. <span class="tactic">apply</span> <span class="id">addlist_workset_incl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_ref_globvar_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">gv</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> (<span class="id">add_ref_globvar</span> <span class="id">gv</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3331')">Proof.</div>
<div class="proofscript" id="proof3331">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_globvar</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">w</span>. <span class="tactic">induction</span> (<span class="id">gvar_init</span> <span class="id">gv</span>); <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">workset_incl_trans</span>; [ | <span class="tactic">eauto</span> ].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_init_data</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; (<span class="tactic">apply</span> <span class="id">workset_incl_refl</span> || <span class="tactic">apply</span> <span class="id">add_workset_incl</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_ref_definition_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">pm</span> <span class="id">id</span> <span class="id">w</span>, <span class="id">workset_incl</span> <span class="id">w</span> (<span class="id">add_ref_definition</span> <span class="id">pm</span> <span class="id">id</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3332')">Proof.</div>
<div class="proofscript" id="proof3332">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_definition</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">pm</span>!<span class="id">id</span>) <span class="kwd">as</span> [[[] | ? ] | ].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">add_ref_function_incl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">add_ref_globvar_incl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">initial_workset_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span>, <span class="id">workset_incl</span> {| <span class="id">w_seen</span> := <span class="id">IS.empty</span>; <span class="id">w_todo</span> := <span class="id">nil</span> |} (<span class="id">initial_workset</span> <span class="id">p</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3333')">Proof.</div>
<div class="proofscript" id="proof3333">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">initial_workset</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">workset_incl_trans</span>. 2: <span class="tactic">apply</span> <span class="id">add_workset_incl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> {| <span class="id">w_seen</span> := <span class="id">IS.empty</span>; <span class="id">w_todo</span> := <span class="id">nil</span> |}. <span class="tactic">induction</span> (<span class="id">prog_public</span> <span class="id">p</span>); <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">workset_incl_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">workset_incl_trans</span>. <span class="tactic">apply</span> <span class="id">add_workset_incl</span>. <span class="tactic">apply</span> <span class="id">IHl</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Soundness properties for functions that add identifiers to the workset </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_add_workset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> (<span class="id">w</span>: <span class="id">workset</span>), <span class="id">IS.In</span> <span class="id">id</span> (<span class="id">add_workset</span> <span class="id">id</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3334')">Proof.</div>
<div class="proofscript" id="proof3334">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_workset</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">w</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IS.mem_2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">IS.add_1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_addlist_workset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l</span> (<span class="id">w</span>: <span class="id">workset</span>),<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> <span class="id">l</span> -&gt; <span class="id">IS.In</span> <span class="id">id</span> (<span class="id">addlist_workset</span> <span class="id">l</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3335')">Proof.</div>
<div class="proofscript" id="proof3335">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">subst</span> <span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">seen_workset_incl</span>. <span class="tactic">apply</span> <span class="id">addlist_workset_incl</span>. <span class="tactic">apply</span> <span class="id">seen_add_workset</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_add_ref_function</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">f</span> <span class="id">w</span>,<br/>
&nbsp;&nbsp;<span class="id">ref_function</span> <span class="id">f</span> <span class="id">id</span> -&gt; <span class="id">IS.In</span> <span class="id">id</span> (<span class="id">add_ref_function</span> <span class="id">f</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3336')">Proof.</div>
<div class="proofscript" id="proof3336">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">w</span>. <span class="tactic">unfold</span> <span class="id">ref_function</span>, <span class="id">add_ref_function</span>. <span class="tactic">apply</span> <span class="id">PTree_Properties.fold_rec</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> (<span class="id">pc</span> &amp; <span class="id">i</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">pc</span>, <span class="id">i</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> (<span class="id">pc</span> &amp; <span class="id">i</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> (<span class="id">pc</span> &amp; <span class="id">i</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">pc</span> <span class="id">k</span>).<br/>
&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">A</span>. <span class="tactic">unfold</span> <span class="id">add_ref_instruction</span>. <span class="tactic">apply</span> <span class="id">seen_addlist_workset</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">unfold</span> <span class="id">add_ref_instruction</span>. <span class="tactic">eapply</span> <span class="id">seen_workset_incl</span>. <span class="tactic">apply</span> <span class="id">addlist_workset_incl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="id">exists</span> <span class="id">pc</span>, <span class="id">i</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_add_ref_definition</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">pm</span> <span class="id">id</span> <span class="id">gd</span> <span class="id">id</span>' <span class="id">w</span>,<br/>
&nbsp;&nbsp;<span class="id">pm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span>' -&gt; <span class="id">IS.In</span> <span class="id">id</span>' (<span class="id">add_ref_definition</span> <span class="id">pm</span> <span class="id">id</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3337')">Proof.</div>
<div class="proofscript" id="proof3337">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_definition</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">destruct</span> <span class="id">gd</span> <span class="kwd">as</span> [[<span class="id">f</span>|<span class="id">ef</span>]|<span class="id">gv</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">seen_add_ref_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> (<span class="id">ofs</span> &amp; <span class="id">IN</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_ref_globvar</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">l</span> (<span class="id">w</span>: <span class="id">workset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span>' <span class="id">w</span> \/ <span class="id">In</span> (<span class="id">Init_addrof</span> <span class="id">id</span>' <span class="id">ofs</span>) <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span>' (<span class="id">fold_left</span> <span class="id">add_ref_init_data</span> <span class="id">l</span> <span class="id">w</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">seen_workset_incl</span>. <span class="tactic">apply</span> <span class="id">add_workset_incl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>; <span class="id">left</span>; <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">seen_add_workset</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_main_initial_workset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span>, <span class="id">IS.In</span> <span class="id">p</span>.(<span class="id">prog_main</span>) (<span class="id">initial_workset</span> <span class="id">p</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3338')">Proof.</div>
<div class="proofscript" id="proof3338">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">seen_add_workset</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">seen_public_initial_workset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">id</span>, <span class="id">In</span> <span class="id">id</span> <span class="id">p</span>.(<span class="id">prog_public</span>) -&gt; <span class="id">IS.In</span> <span class="id">id</span> (<span class="id">initial_workset</span> <span class="id">p</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3339')">Proof.</div>
<div class="proofscript" id="proof3339">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">initial_workset</span>. <span class="tactic">eapply</span> <span class="id">seen_workset_incl</span>. <span class="tactic">apply</span> <span class="id">add_workset_incl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">l</span> (<span class="id">w</span>: <span class="id">workset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">w</span> \/ <span class="id">In</span> <span class="id">id</span> <span class="id">l</span> -&gt; <span class="id">IS.In</span> <span class="id">id</span> (<span class="id">fold_left</span> (<span class="kwd">fun</span> <span class="id">w</span> <span class="id">id</span> =&gt; <span class="id">add_workset</span> <span class="id">id</span> <span class="id">w</span>) <span class="id">l</span> <span class="id">w</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">seen_workset_incl</span>. <span class="tactic">apply</span> <span class="id">add_workset_incl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">apply</span> <span class="id">seen_add_workset</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of the transformation with respect to the relational specification </h1>
<br/>
<div class="doc">Correctness of the dependency graph traversal. </div>
<br/>
<span class="kwd">Section</span> <span class="id">ANALYSIS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">p</span>: <span class="id">program</span>.<br/>
<span class="kwd">Let</span> <span class="id">pm</span> := <span class="id">prog_defmap</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">workset_invariant</span> (<span class="id">w</span>: <span class="id">workset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">gd</span> <span class="id">id</span>',<br/>
&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">w</span> -&gt; ~<span class="id">List.In</span> <span class="id">id</span> (<span class="id">w_todo</span> <span class="id">w</span>) -&gt; <span class="id">pm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span>' <span class="id">w</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">used_set_closed</span> (<span class="id">u</span>: <span class="id">IS.t</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">gd</span> <span class="id">id</span>',<br/>
&nbsp;&nbsp;<span class="id">IS.In</span> <span class="id">id</span> <span class="id">u</span> -&gt; <span class="id">pm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span>' -&gt; <span class="id">IS.In</span> <span class="id">id</span>' <span class="id">u</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">iter_step_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">w</span>,<br/>
&nbsp;&nbsp;<span class="id">workset_invariant</span> <span class="id">w</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">iter_step</span> <span class="id">pm</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">inl</span> <span class="id">u</span> =&gt; <span class="id">used_set_closed</span> <span class="id">u</span><br/>
&nbsp;&nbsp;| <span class="id">inr</span> <span class="id">w</span>' =&gt; <span class="id">workset_invariant</span> <span class="id">w</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3340')">Proof.</div>
<div class="proofscript" id="proof3340">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">iter_step</span>, <span class="id">workset_invariant</span>, <span class="id">used_set_closed</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">w_todo</span> <span class="id">w</span>) <span class="kwd">as</span> [ | <span class="id">id</span> <span class="id">rem</span> ]; <span class="tactic">intros</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">set</span> (<span class="id">w</span>' := {| <span class="id">w_seen</span> := <span class="id">w</span>.(<span class="id">w_seen</span>); <span class="id">w_todo</span> := <span class="id">rem</span> |}) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">add_ref_definition_incl</span> <span class="id">pm</span> <span class="id">id</span> <span class="id">w</span>').<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id</span> <span class="id">id0</span>).<br/>
&nbsp;&nbsp;+ <span class="tactic">subst</span> <span class="id">id0</span>. <span class="tactic">eapply</span> <span class="id">seen_add_ref_definition</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">TRACK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">SEEN</span>. <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (~ <span class="id">In</span> <span class="id">id0</span> <span class="id">rem</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id">change</span> <span class="id">rem</span> <span class="kwd">with</span> (<span class="id">w_todo</span> <span class="id">w</span>'). <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">H1</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">used_globals_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">u</span>, <span class="id">used_globals</span> <span class="id">p</span> <span class="id">pm</span> = <span class="id">Some</span> <span class="id">u</span> -&gt; <span class="id">used_set_closed</span> <span class="id">u</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3341')">Proof.</div>
<div class="proofscript" id="proof3341">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">used_globals</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">PrimIter.iterate_prop</span> <span class="kwd">with</span> (<span class="id">P</span> := <span class="id">workset_invariant</span>); <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">iter_step_invariant</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">initial_workset_incl</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">edestruct</span> <span class="id">TRACK</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="id">eelim</span> <span class="id">IS.empty_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">used_globals_incl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">u</span>, <span class="id">used_globals</span> <span class="id">p</span> <span class="id">pm</span> = <span class="id">Some</span> <span class="id">u</span> -&gt; <span class="id">IS.Subset</span> (<span class="id">initial_workset</span> <span class="id">p</span>) <span class="id">u</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3342')">Proof.</div>
<div class="proofscript" id="proof3342">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">used_globals</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">PrimIter.iterate_prop</span> <span class="kwd">with</span> (<span class="id">P</span> := <span class="kwd">fun</span> (<span class="id">w</span>: <span class="id">workset</span>) =&gt; <span class="id">IS.Subset</span> (<span class="id">initial_workset</span> <span class="id">p</span>) <span class="id">w</span>); <span class="tactic">eauto</span>.<br/>
- <span class="id">fold</span> <span class="id">pm</span>; <span class="tactic">unfold</span> <span class="id">iter_step</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">w_todo</span> <span class="id">a</span>) <span class="kwd">as</span> [ | <span class="id">id</span> <span class="id">rem</span> ].<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">add_ref_definition_incl</span> <span class="id">pm</span> <span class="id">id</span> {| <span class="id">w_seen</span> := <span class="id">a</span>; <span class="id">w_todo</span> := <span class="id">rem</span> |}).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Corollary</span> <span class="id">used_globals_valid</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">u</span>,<br/>
&nbsp;&nbsp;<span class="id">used_globals</span> <span class="id">p</span> <span class="id">pm</span> = <span class="id">Some</span> <span class="id">u</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">IS.for_all</span> (<span class="id">global_defined</span> <span class="id">p</span> <span class="id">pm</span>) <span class="id">u</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p</span> <span class="id">u</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3343')">Proof.</div>
<div class="proofscript" id="proof3343">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">constructor</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">used_globals_sound</span>; <span class="tactic">eauto</span>. <br/>
- <span class="tactic">eapply</span> <span class="id">used_globals_incl</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">seen_main_initial_workset</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">used_globals_incl</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">seen_public_initial_workset</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">ISF.for_all_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
+ <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">global_defined</span> <span class="kwd">in</span> <span class="id">H1</span>. <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">pm</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">g</span>|] <span class="id">eqn</span>:<span class="id">E</span>.<br/>
* <span class="id">left</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>,<span class="id">g</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>. <span class="tactic">apply</span> <span class="id">in_prog_defmap</span>; <span class="tactic">auto</span>.<br/>
* <span class="id">InvBooleans</span>; <span class="tactic">auto</span>.<br/>
+ <span class="id">hnf</span>. <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">ANALYSIS</span>.<br/>
<br/>
<div class="doc">Properties of the elimination of unused global definitions. </div>
<br/>
<span class="kwd">Section</span> <span class="id">TRANSFORMATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">p</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">used</span>: <span class="id">IS.t</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">add_def</span> (<span class="id">m</span>: <span class="id">prog_map</span>) <span class="id">idg</span> := <span class="id">PTree.set</span> (<span class="id">fst</span> <span class="id">idg</span>) (<span class="id">snd</span> <span class="id">idg</span>) <span class="id">m</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_globdefs_accu</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">defs</span> <span class="id">accu1</span> <span class="id">accu2</span> <span class="id">u</span>,<br/>
&nbsp;&nbsp;<span class="id">filter_globdefs</span> <span class="id">u</span> (<span class="id">accu1</span> ++ <span class="id">accu2</span>) <span class="id">defs</span> = <span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">accu1</span> <span class="id">defs</span> ++ <span class="id">accu2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3344')">Proof.</div>
<div class="proofscript" id="proof3344">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">defs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">gd</span>]. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">IHdefs</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_globdefs_nil</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">u</span> <span class="id">accu</span> <span class="id">defs</span>,<br/>
&nbsp;&nbsp;<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">accu</span> <span class="id">defs</span> = <span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> <span class="id">defs</span> ++ <span class="id">accu</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3345')">Proof.</div>
<div class="proofscript" id="proof3345">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">filter_globdefs_accu</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_globdefs_map_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l</span> <span class="id">u</span> <span class="id">m1</span>,<br/>
&nbsp;&nbsp;<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m1</span>!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">fold_left</span> <span class="id">add_def</span> (<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> <span class="id">l</span>) <span class="id">m1</span>)!<span class="id">id</span> = <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3346')">Proof.</div>
<div class="proofscript" id="proof3346">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | [<span class="id">id1</span> <span class="id">gd1</span>] <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id1</span> <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">filter_globdefs_nil</span>. <span class="tactic">rewrite</span> <span class="id">fold_left_app</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_def</span> <span class="tactic">at</span> 1. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISF.remove_b</span>. <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_globdefs_map_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l</span> <span class="id">u</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m1</span>!<span class="id">id</span> = <span class="id">m2</span>!<span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">fold_left</span> <span class="id">add_def</span> (<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> <span class="id">l</span>) <span class="id">m1</span>)!<span class="id">id</span> = (<span class="id">fold_left</span> <span class="id">add_def</span> (<span class="id">List.rev</span> <span class="id">l</span>) <span class="id">m2</span>)!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3347')">Proof.</div>
<div class="proofscript" id="proof3347">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | [<span class="id">id1</span> <span class="id">gd1</span>] <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">fold_left_app</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id1</span> <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">filter_globdefs_nil</span>. <span class="tactic">rewrite</span> <span class="id">fold_left_app</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_def</span> <span class="tactic">at</span> 1 3. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IS.mem_1</span>. <span class="tactic">apply</span> <span class="id">IS.remove_2</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">IS.mem_2</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">unfold</span> <span class="id">add_def</span> <span class="tactic">at</span> 2. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">apply</span> <span class="id">IHl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_globdefs_map</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">u</span> <span class="id">defs</span>,<br/>
&nbsp;&nbsp;(<span class="id">PTree_Properties.of_list</span> (<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> (<span class="id">List.rev</span> <span class="id">defs</span>)))! <span class="id">id</span> =<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span> <span class="kwd">then</span> (<span class="id">PTree_Properties.of_list</span> <span class="id">defs</span>)!<span class="id">id</span> <span class="kwd">else</span> <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3348')">Proof.</div>
<div class="proofscript" id="proof3348">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">PTree_Properties.of_list</span>. <span class="id">fold</span> <span class="id">prog_map</span>. <span class="tactic">unfold</span> <span class="id">PTree.elt</span>. <span class="id">fold</span> <span class="id">add_def</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
- <span class="id">erewrite</span> <span class="id">filter_globdefs_map_2</span>. <span class="tactic">rewrite</span> <span class="id">List.rev_involutive</span>. <span class="tactic">reflexivity</span>. <br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">filter_globdefs_map_1</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">PTree.gempty</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_globdefs_domain</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l</span> <span class="id">u</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> (<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> <span class="id">l</span>)) -&gt; <span class="id">IS.In</span> <span class="id">id</span> <span class="id">u</span> /\ <span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3349')">Proof.</div>
<div class="proofscript" id="proof3349">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | [<span class="id">id1</span> <span class="id">gd1</span>] <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">tauto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id1</span> <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">MEM</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">filter_globdefs_nil</span>, <span class="id">map_app</span>, <span class="id">in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">ISF.remove_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">try</span> <span class="tactic">tauto</span>. <span class="tactic">subst</span> <span class="id">id1</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">IS.mem_2</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">apply</span> <span class="id">IHl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">filter_globdefs_unique_names</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">u</span>, <span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> (<span class="id">filter_globdefs</span> <span class="id">u</span> <span class="id">nil</span> <span class="id">l</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3350')">Proof.</div>
<div class="proofscript" id="proof3350">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | [<span class="id">id1</span> <span class="id">gd1</span>] <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id1</span> <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">MEM</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">filter_globdefs_nil</span>, <span class="id">map_app</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_norepet_append</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">simpl</span>; <span class="tactic">tauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">tauto</span>. <span class="tactic">subst</span> <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">filter_globdefs_domain</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">ISF.remove_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">TRANSFORMATION</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transform_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3351')">Proof.</div>
<div class="proofscript" id="proof3351">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transform_program</span>; <span class="tactic">intros</span> <span class="id">p</span> <span class="id">tp</span> <span class="id">TR</span>. <span class="tactic">set</span> (<span class="id">pm</span> := <span class="id">prog_defmap</span> <span class="id">p</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">used_globals</span> <span class="id">p</span> <span class="id">pm</span>) <span class="kwd">as</span> [<span class="id">u</span>|] <span class="id">eqn</span>:<span class="id">U</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.for_all</span> (<span class="id">global_defined</span> <span class="id">p</span> <span class="id">pm</span>) <span class="id">u</span>) <span class="id">eqn</span>:<span class="id">DEF</span>; <span class="id">inv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">u</span>; <span class="tactic">split</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">used_globals_valid</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">prog_defmap</span>; <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">filter_globdefs_map</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">filter_globdefs_unique_names</span>. <br/>
Qed.</div>
<br/>
<h1> Semantic preservation </h1>
<br/>
<span class="kwd">Section</span> <span class="id">SOUNDNESS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">p</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tp</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">used</span>: <span class="id">IS.t</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">USED_VALID</span>: <span class="id">valid_used_set</span> <span class="id">p</span> <span class="id">used</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog_1</span> <span class="id">used</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">p</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tp</span>.<br/>
<span class="kwd">Let</span> <span class="id">pm</span> := <span class="id">prog_defmap</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">kept</span> (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> := <span class="id">IS.In</span> <span class="id">id</span> <span class="id">used</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">kept_closed</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">gd</span> <span class="id">id</span>',<br/>
&nbsp;&nbsp;<span class="id">kept</span> <span class="id">id</span> -&gt; <span class="id">pm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span>' -&gt; <span class="id">kept</span> <span class="id">id</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3352')">Proof.</div>
<div class="proofscript" id="proof3352">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">used_closed</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kept_main</span>:<br/>
&nbsp;&nbsp;<span class="id">kept</span> <span class="id">p</span>.(<span class="id">prog_main</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3353')">Proof.</div>
<div class="proofscript" id="proof3353">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kept_public</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">In</span> <span class="id">id</span> <span class="id">p</span>.(<span class="id">prog_public</span>) -&gt; <span class="id">kept</span> <span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3354')">Proof.</div>
<div class="proofscript" id="proof3354">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">used_public</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Relating <span class="bracket"><span class="id">Genv.find_symbol</span></span> operations in the original and transformed program </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transform_find_symbol_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">kept</span> <span class="id">id</span> -&gt; <span class="id">exists</span> <span class="id">b</span>', <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3355')">Proof.</div>
<div class="proofscript" id="proof3355">
&nbsp;&nbsp;<span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">g</span>, (<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">g</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">prog_defmap_dom</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_symbol_inversion</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">g</span> &amp; <span class="id">P</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv.find_symbol_exists</span> <span class="kwd">with</span> <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_prog_defmap</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">match_prog_def</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">IS.mem_1</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transform_find_symbol_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">kept</span> <span class="id">id</span> /\ <span class="id">exists</span> <span class="id">b</span>', <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3356')">Proof.</div>
<div class="proofscript" id="proof3356">
&nbsp;&nbsp;<span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">g</span>, (<span class="id">prog_defmap</span> <span class="id">tp</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">g</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">prog_defmap_dom</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_symbol_inversion</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">g</span> &amp; <span class="id">P</span>).<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">match_prog_def</span> <span class="kwd">in</span> <span class="id">P</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used</span>) <span class="id">eqn</span>:<span class="id">U</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">IS.mem_2</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Genv.find_symbol_exists</span> <span class="kwd">with</span> <span class="id">g</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_prog_defmap</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Injections that preserve used globals. </div>
<br/>
<span class="kwd">Record</span> <span class="id">meminj_preserves_globals</span> (<span class="id">f</span>: <span class="id">meminj</span>) : <span class="kwd">Prop</span> := {<br/>
&nbsp;&nbsp;<span class="id">symbols_inject_1</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">delta</span> = 0 /\ <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>';<br/>
&nbsp;&nbsp;<span class="id">symbols_inject_2</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">kept</span> <span class="id">id</span> -&gt; <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>', <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>' /\ <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', 0);<br/>
&nbsp;&nbsp;<span class="id">symbols_inject_3</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>, <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> /\ <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', 0);<br/>
&nbsp;&nbsp;<span class="id">defs_inject</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span> <span class="id">gd</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Genv.find_def</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_def</span> <span class="id">tge</span> <span class="id">b</span>' = <span class="id">Some</span> <span class="id">gd</span> /\ <span class="id">delta</span> = 0 /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>);<br/>
&nbsp;&nbsp;<span class="id">defs_rev_inject</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span> <span class="id">gd</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Genv.find_def</span> <span class="id">tge</span> <span class="id">b</span>' = <span class="id">Some</span> <span class="id">gd</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_def</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">gd</span> /\ <span class="id">delta</span> = 0<br/>
}.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">init_meminj</span> : <span class="id">meminj</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">b</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">id</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">b</span>' =&gt; <span class="id">Some</span> (<span class="id">b</span>', 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">init_meminj_eq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">b</span>',<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">init_meminj</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', 0).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3357')">Proof.</div>
<div class="proofscript" id="proof3357">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">init_meminj</span>. <span class="id">erewrite</span> <span class="id">Genv.find_invert_symbol</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">init_meminj_invert</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">init_meminj</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">delta</span> = 0 /\ <span class="id">exists</span> <span class="id">id</span>, <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> /\ <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3358')">Proof.</div>
<div class="proofscript" id="proof3358">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">init_meminj</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.invert_symbol</span> <span class="id">ge</span> <span class="id">b</span>) <span class="kwd">as</span> [<span class="id">id</span>|] <span class="id">eqn</span>:<span class="id">S</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>''|] <span class="id">eqn</span>:<span class="id">F</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">id</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">Genv.invert_find_symbol</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_meminj_preserves_globals</span>:<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">init_meminj</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3359')">Proof.</div>
<div class="proofscript" id="proof3359">
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id1</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">id1</span> = <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> (<span class="id">Genv.genv_vars_inj</span> <span class="id">ge</span>); <span class="tactic">eauto</span>). <span class="tactic">subst</span> <span class="id">id1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="id">exploit</span> <span class="id">transform_find_symbol_1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">F</span>). <span class="id">exists</span> <span class="id">b</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">init_meminj_eq</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">transform_find_symbol_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">K</span> &amp; <span class="id">b</span> &amp; <span class="id">F</span>). <br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">init_meminj_eq</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">kept</span> <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">transform_find_symbol_2</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">pm</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">pm</span>; <span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span>. <span class="id">exists</span> <span class="id">b</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">prog_defmap</span> <span class="id">tp</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span>).<br/>
&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">match_prog_def</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">IS.mem_1</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H3</span> <span class="kwd">as</span> (<span class="id">b1</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">tge</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">replace</span> <span class="id">b</span>' <span class="kwd">with</span> <span class="id">b1</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">kept_closed</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">prog_defmap</span> <span class="id">tp</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span>. <span class="id">exists</span> <span class="id">b</span>'; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">match_prog_def</span> <span class="kwd">in</span> <span class="id">H1</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> (<span class="id">b1</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">ge</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">replace</span> <span class="id">b</span> <span class="kwd">with</span> <span class="id">b1</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">globals_symbols_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span>, <span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt; <span class="id">symbols_inject</span> <span class="id">j</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3360')">Proof.</div>
<div class="proofscript" id="proof3360">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">E1</span>: <span class="id">Genv.genv_public</span> <span class="id">ge</span> = <span class="id">p</span>.(<span class="id">prog_public</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Genv.globalenv_public</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">E2</span>: <span class="id">Genv.genv_public</span> <span class="id">tge</span> = <span class="id">p</span>.(<span class="id">prog_public</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">tge</span>; <span class="tactic">rewrite</span> <span class="id">Genv.globalenv_public</span>. <span class="tactic">eapply</span> <span class="id">match_prog_public</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; [|<span class="tactic">split</span>;[|<span class="tactic">split</span>]]; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">Genv.public_symbol</span>; <span class="tactic">rewrite</span> <span class="id">E1</span>, <span class="id">E2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>'|] <span class="id">eqn</span>:<span class="id">TFS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">FS</span> &amp; <span class="id">INJ</span>). <span class="tactic">rewrite</span> <span class="id">FS</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">in_dec</span> <span class="id">ident_eq</span> <span class="id">id</span> (<span class="id">prog_public</span> <span class="id">p</span>)); <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">kept_public</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">TFS</span>' &amp; <span class="id">INJ</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">symbols_inject_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">unfold</span> <span class="id">Genv.public_symbol</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">E1</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">in_dec</span> <span class="id">ident_eq</span> <span class="id">id</span> (<span class="id">prog_public</span> <span class="id">p</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">kept_public</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>); <span class="id">exists</span> <span class="id">b</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Genv.block_is_volatile</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_var_info</span> <span class="id">ge</span> <span class="id">b1</span>) <span class="kwd">as</span> [<span class="id">gv</span>|] <span class="id">eqn</span>:<span class="id">V1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_var_info_iff</span> <span class="kwd">in</span> <span class="id">V1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">defs_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_var_info_iff</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">rewrite</span> <span class="id">A</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_var_info</span> <span class="id">tge</span> <span class="id">b2</span>) <span class="kwd">as</span> [<span class="id">gv</span>|] <span class="id">eqn</span>:<span class="id">V2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_var_info_iff</span> <span class="kwd">in</span> <span class="id">V2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">defs_rev_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span>). <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_var_info_iff</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbol_address_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">id</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt; <span class="id">kept</span> <span class="id">id</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">Genv.symbol_address</span> <span class="id">ge</span> <span class="id">id</span> <span class="id">ofs</span>) (<span class="id">Genv.symbol_address</span> <span class="id">tge</span> <span class="id">id</span> <span class="id">ofs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3361')">Proof.</div>
<div class="proofscript" id="proof3361">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">TFS</span> &amp; <span class="id">INJ</span>). <span class="tactic">rewrite</span> <span class="id">TFS</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Semantic preservation </div>
<br/>
<span class="kwd">Definition</span> <span class="id">regset_inject</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">rs</span> <span class="id">rs</span>': <span class="id">regset</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">rs</span>#<span class="id">r</span> <span class="id">rs</span>'#<span class="id">r</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">regs_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>', <span class="id">regset_inject</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt; <span class="kwd">forall</span> <span class="id">l</span>, <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">rs</span>##<span class="id">l</span> <span class="id">rs</span>'##<span class="id">l</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3362')">Proof.</div>
<div class="proofscript" id="proof3362">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>. <span class="id">constructor</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_reg_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' <span class="id">r</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt; <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">f</span> (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">v</span>) (<span class="id">rs</span>'#<span class="id">r</span> &lt;- <span class="id">v</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3363')">Proof.</div>
<div class="proofscript" id="proof3363">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Regmap.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_res_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' <span class="id">res</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt; <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">f</span> (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">v</span> <span class="id">rs</span>) (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">v</span>' <span class="id">rs</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3364')">Proof.</div>
<div class="proofscript" id="proof3364">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">res</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">set_reg_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">regset_inject_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">f</span>' <span class="id">rs</span> <span class="id">rs</span>', <span class="id">regset_inject</span> <span class="id">f</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt; <span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt; <span class="id">regset_inject</span> <span class="id">f</span>' <span class="id">rs</span> <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3365')">Proof.</div>
<div class="proofscript" id="proof3365">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">val_inject_incr</span> <span class="kwd">with</span> <span class="id">f</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">regset_undef_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">regset_inject</span> <span class="id">f</span> (<span class="id">Regmap.init</span> <span class="id">Vundef</span>) (<span class="id">Regmap.init</span> <span class="id">Vundef</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3366')">Proof.</div>
<div class="proofscript" id="proof3366">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_regs_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">args</span> <span class="id">args</span>', <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">args</span> <span class="id">args</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">params</span>,<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">f</span> (<span class="id">init_regs</span> <span class="id">args</span> <span class="id">params</span>) (<span class="id">init_regs</span> <span class="id">args</span>' <span class="id">params</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3367')">Proof.</div>
<div class="proofscript" id="proof3367">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">params</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">regset_undef_inject</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stacks</span> (<span class="id">j</span>: <span class="id">meminj</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">block</span> -&gt; <span class="id">block</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stacks_nil</span>: <span class="kwd">forall</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>) <span class="id">bound</span> -&gt; <span class="id">Ple</span> (<span class="id">Genv.genv_next</span> <span class="id">tge</span>) <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_stacks_cons</span>: <span class="kwd">forall</span> <span class="id">res</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">s</span> <span class="id">tsp</span> <span class="id">trs</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">sp</span> <span class="id">tsp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">KEPT</span>: <span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_function</span> <span class="id">f</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SPINJ</span>: <span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">tsp</span>, 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REGINJ</span>: <span class="id">regset_inject</span> <span class="id">j</span> <span class="id">rs</span> <span class="id">trs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BELOW</span>: <span class="id">Plt</span> <span class="id">sp</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TBELOW</span>: <span class="id">Plt</span> <span class="id">tsp</span> <span class="id">tbound</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> (<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> :: <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">tsp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">trs</span> :: <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">bound</span> <span class="id">tbound</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_preserves_globals</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3368')">Proof.</div>
<div class="proofscript" id="proof3368">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>', <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span>, <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">b1</span> = <span class="id">None</span> -&gt; <span class="id">j</span>' <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt; <span class="id">Ple</span> <span class="id">bound</span> <span class="id">b1</span> /\ <span class="id">Ple</span> <span class="id">tbound</span> <span class="id">b2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span>' <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3369')">Proof.</div>
<div class="proofscript" id="proof3369">
&nbsp;&nbsp;<span class="tactic">induction</span> 2; <span class="tactic">intros</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">SAME</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">Plt</span> <span class="id">b</span> (<span class="id">Genv.genv_next</span> <span class="id">ge</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">j</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">j</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b1</span> <span class="id">delta1</span>] | ] <span class="id">eqn</span>: <span class="id">J</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> (<span class="id">Plt_strict</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Plt_Ple_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SAME</span>': <span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">Plt</span> <span class="id">b</span>' (<span class="id">Genv.genv_next</span> <span class="id">tge</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">j</span> <span class="id">b</span> = <span class="id">Some</span> (<span class="id">b</span>', <span class="id">delta</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">j</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b1</span> <span class="id">delta1</span>] | ] <span class="id">eqn</span>: <span class="id">J</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> (<span class="id">Plt_strict</span> <span class="id">b</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Plt_Ple_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.  <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">symbols_inject_1</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_symb_range</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">symbols_inject_3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">defs_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">SAME</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eapply</span> <span class="id">defs_rev_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">SAME</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.genv_defs_range</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHmatch_stacks</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">split</span>; <span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Plt_Ple</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regset_inject_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_bound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">bound</span>' <span class="id">tbound</span>',<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> <span class="id">bound</span>' -&gt; <span class="id">Ple</span> <span class="id">tbound</span> <span class="id">tbound</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">bound</span>' <span class="id">tbound</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3370')">Proof.</div>
<div class="proofscript" id="proof3370">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_Ple_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_Ple_trans</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_regular</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">ts</span> <span class="id">tsp</span> <span class="id">trs</span> <span class="id">tm</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> <span class="id">sp</span> <span class="id">tsp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">KEPT</span>: <span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_function</span> <span class="id">f</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SPINJ</span>: <span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">tsp</span>, 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REGINJ</span>: <span class="id">regset_inject</span> <span class="id">j</span> <span class="id">rs</span> <span class="id">trs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEMINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">ts</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">tsp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">trs</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">m</span> <span class="id">ts</span> <span class="id">targs</span> <span class="id">tm</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">KEPT</span>: <span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_fundef</span> <span class="id">fd</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGINJ</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">targs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEMINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Callstate</span> <span class="id">s</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">ts</span> <span class="id">fd</span> <span class="id">targs</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">res</span> <span class="id">m</span> <span class="id">ts</span> <span class="id">tres</span> <span class="id">tm</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">s</span> <span class="id">ts</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RESINJ</span>: <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">res</span> <span class="id">tres</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEMINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Returnstate</span> <span class="id">s</span> <span class="id">res</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">ts</span> <span class="id">tres</span> <span class="id">tm</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">external_call_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ef</span> <span class="id">vargs</span> <span class="id">m1</span> <span class="id">t</span> <span class="id">vres</span> <span class="id">m2</span> <span class="id">f</span> <span class="id">m1</span>' <span class="id">vargs</span>',<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">external_call</span> <span class="id">ef</span> <span class="id">ge</span> <span class="id">vargs</span> <span class="id">m1</span> <span class="id">t</span> <span class="id">vres</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m1</span> <span class="id">m1</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">vargs</span> <span class="id">vargs</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">f</span>', <span class="id">exists</span> <span class="id">vres</span>', <span class="id">exists</span> <span class="id">m2</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">external_call</span> <span class="id">ef</span> <span class="id">tge</span> <span class="id">vargs</span>' <span class="id">m1</span>' <span class="id">t</span> <span class="id">vres</span>' <span class="id">m2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span>' <span class="id">vres</span> <span class="id">vres</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f</span>' <span class="id">m2</span> <span class="id">m2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Mem.unchanged_on</span> (<span class="id">loc_unmapped</span> <span class="id">f</span>) <span class="id">m1</span> <span class="id">m2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Mem.unchanged_on</span> (<span class="id">loc_out_of_reach</span> <span class="id">f</span> <span class="id">m1</span>) <span class="id">m1</span>' <span class="id">m2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">inject_separated</span> <span class="id">f</span> <span class="id">f</span>' <span class="id">m1</span> <span class="id">m1</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3371')">Proof.</div>
<div class="proofscript" id="proof3371">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">external_call_mem_inject_gen</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">globals_symbols_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ros</span> <span class="id">rs</span> <span class="id">fd</span> <span class="id">trs</span>,<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">rs</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">ros</span> <span class="kwd">with</span> <span class="id">inl</span> <span class="id">r</span> =&gt; <span class="id">regset_inject</span> <span class="id">j</span> <span class="id">rs</span> <span class="id">trs</span> | <span class="id">inr</span> <span class="id">id</span> =&gt; <span class="id">kept</span> <span class="id">id</span> <span class="kwd">end</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">trs</span> = <span class="id">Some</span> <span class="id">fd</span> /\ (<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_fundef</span> <span class="id">fd</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3372')">Proof.</div>
<div class="proofscript" id="proof3372">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ros</span> <span class="kwd">as</span> [<span class="id">r</span>|<span class="id">id</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="id">exploit</span> <span class="id">Genv.find_funct_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">R</span>). <span class="tactic">rewrite</span> <span class="id">R</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_find_funct_ptr</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">r</span>). <span class="tactic">rewrite</span> <span class="id">R</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.  <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">defs_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">A</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">tb</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="tactic">rewrite</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.  <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">defs_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">A</span>. <br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_builtin_arg_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">j</span> <span class="id">rs</span>' <span class="id">sp</span>' <span class="id">m</span>' <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', 0) -&gt;<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">j</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">In</span> <span class="id">id</span> (<span class="id">globals_of_builtin_arg</span> <span class="id">a</span>) -&gt; <span class="id">kept</span> <span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">tge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">m</span>' <span class="id">a</span> <span class="id">v</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3373')">Proof.</div>
<div class="proofscript" id="proof3373">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">SP</span> <span class="id">GL</span> <span class="id">RS</span> <span class="id">MI</span> <span class="id">K</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">K</span>.<br/>
- <span class="id">exists</span> <span class="id">rs</span>'#<span class="id">x</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">exploit</span> <span class="id">Mem.load_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Zplus_0_r</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>. <span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">Senv.symbol_address</span> <span class="id">ge</span> <span class="id">id</span> <span class="id">ofs</span>) (<span class="id">Senv.symbol_address</span> <span class="id">tge</span> <span class="id">id</span> <span class="id">ofs</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">Senv.symbol_address</span>; <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">rewrite</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Senv.symbol_address</span>; <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">rewrite</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">IHeval_builtin_arg1</span> <span class="kwd">as</span> (<span class="id">v1</span>' &amp; <span class="id">A1</span> &amp; <span class="id">B1</span>); <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHeval_builtin_arg2</span> <span class="kwd">as</span> (<span class="id">v2</span>' &amp; <span class="id">A2</span> &amp; <span class="id">B2</span>); <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Val.longofwords</span> <span class="id">v1</span>' <span class="id">v2</span>'); <span class="tactic">split</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.longofwords_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_builtin_args_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">j</span> <span class="id">rs</span>' <span class="id">sp</span>' <span class="id">m</span>' <span class="id">al</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', 0) -&gt;<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">regset_inject</span> <span class="id">j</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">In</span> <span class="id">id</span> (<span class="id">globals_of_builtin_args</span> <span class="id">al</span>) -&gt; <span class="id">kept</span> <span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">tge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>) (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">m</span>' <span class="id">al</span> <span class="id">vl</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">vl</span> <span class="id">vl</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3374')">Proof.</div>
<div class="proofscript" id="proof3374">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
- <span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>; <span class="id">constructor</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_builtin_arg_inject</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>. <span class="tactic">intros</span> (<span class="id">v1</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHlist_forall2</span> <span class="kwd">as</span> (<span class="id">vl</span>' &amp; <span class="id">C</span> &amp; <span class="id">D</span>); <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">v1</span>' :: <span class="id">vl</span>'); <span class="tactic">split</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">step_simulation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">step</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">S1</span> <span class="id">S1</span>'),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">S2</span>', <span class="id">step</span> <span class="id">tge</span> <span class="id">S1</span>' <span class="id">t</span> <span class="id">S2</span>' /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">S2</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3375')">Proof.</div>
<div class="proofscript" id="proof3375">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">MS</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;nop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Inop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;op&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">tsp</span> <span class="id">Ptrofs.zero</span>) <span class="id">op</span> <span class="id">trs</span>##<span class="id">args</span> <span class="id">tm</span> = <span class="id">Some</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">tv</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">eval_operation_inj</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>) (<span class="id">m1</span> := <span class="id">m</span>) (<span class="id">sp1</span> := <span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) (<span class="id">vl1</span> := <span class="id">rs</span>##<span class="id">args</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.different_pointers_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">symbol_address_inject</span>. <span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">exists</span> <span class="id">pc</span>, (<span class="id">Iop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">res</span> <span class="id">pc</span>'); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">tv</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_Iop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_reg_inject</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;load&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">ta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">tsp</span> <span class="id">Ptrofs.zero</span>) <span class="id">addr</span> <span class="id">trs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">ta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">a</span> <span class="id">ta</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">eval_addressing_inj</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>) (<span class="id">sp1</span> := <span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) (<span class="id">vl1</span> := <span class="id">rs</span>##<span class="id">args</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">symbol_address_inject</span>. <span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">exists</span> <span class="id">pc</span>, (<span class="id">Iload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">pc</span>'); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">ta</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">tv</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_Iload</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_reg_inject</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;store&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">ta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">tsp</span> <span class="id">Ptrofs.zero</span>) <span class="id">addr</span> <span class="id">trs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">ta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">a</span> <span class="id">ta</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">eval_addressing_inj</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>) (<span class="id">sp1</span> := <span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) (<span class="id">vl1</span> := <span class="id">rs</span>##<span class="id">args</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">symbol_address_inject</span>. <span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">exists</span> <span class="id">pc</span>, (<span class="id">Istore</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">pc</span>'); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">ta</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_mapped_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">tm</span>' &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_Istore</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_inject</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ros</span> <span class="kwd">as</span> [<span class="id">r</span>|<span class="id">id</span>]. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">sp0</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">tsp</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;tailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_inject</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ros</span> <span class="kwd">as</span> [<span class="id">r</span>|<span class="id">id</span>]. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> ! <span class="id">Zplus_0_r</span>. <span class="tactic">intros</span> (<span class="id">tm</span>' &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_bound</span> <span class="kwd">with</span> <span class="id">stk</span> <span class="id">tsp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span>' <span class="id">stk</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">tm</span>' <span class="id">tsp</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;builtin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_builtin_args_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">KEPT</span>. <span class="tactic">red</span>. <span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">vargs</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">tv</span> &amp; <span class="id">tm</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ibuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_regular</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">G</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">sp0</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">tsp</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_res_inject</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">regset_inject_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;cond&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">C</span>: <span class="id">eval_condition</span> <span class="id">cond</span> <span class="id">trs</span>##<span class="id">args</span> <span class="id">tm</span> = <span class="id">Some</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">eval_condition_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">regs_inject</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icond</span> <span class="kwd">with</span> (<span class="id">pc</span>' := <span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">ifso</span> <span class="kwd">else</span> <span class="id">ifnot</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;jumptbl&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">REGINJ</span> <span class="id">arg</span>); <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">intros</span> <span class="id">INJ</span>; <span class="id">inv</span> <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ijumptable</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> ! <span class="id">Zplus_0_r</span>. <span class="tactic">intros</span> (<span class="id">tm</span>' &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ireturn</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_bound</span> <span class="kwd">with</span> <span class="id">stk</span> <span class="id">tsp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m</span>' <span class="id">stk</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_Ple</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">tm</span>' <span class="id">tsp</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">or</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_parallel_inject</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">tm</span>' &amp; <span class="id">tstk</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">STK</span>: <span class="id">stk</span> = <span class="id">Mem.nextblock</span> <span class="id">m</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TSTK</span>: <span class="id">tstk</span> = <span class="id">Mem.nextblock</span> <span class="id">tm</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">STACKS</span>': <span class="id">match_stacks</span> <span class="id">j</span>' <span class="id">s</span> <span class="id">ts</span> <span class="id">stk</span> <span class="id">tstk</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> <span class="id">STK</span>, <span class="id">TSTK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b1</span> <span class="id">stk</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b1</span>. <span class="tactic">rewrite</span> <span class="id">F</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">split</span>; <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">G</span> <span class="kwd">in</span> <span class="id">H1</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_regular</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">init_regs_inject</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">val_inject_list_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">tres</span> &amp; <span class="id">tm</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_return</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_bound</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">G</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_return</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_reg_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Relating initial memory states </div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_meminj_invert_strong</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">init_meminj</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">delta</span> = 0 /\<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">id</span> <span class="id">gd</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span><br/>
&nbsp;&nbsp;/\ <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Genv.find_def</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">gd</span><br/>
&nbsp;&nbsp;/\ <span class="id">Genv.find_def</span> <span class="id">tge</span> <span class="id">b</span>' = <span class="id">Some</span> <span class="id">gd</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">i</span>, <span class="id">ref_def</span> <span class="id">gd</span> <span class="id">i</span> -&gt; <span class="id">kept</span> <span class="id">i</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3376')">Proof.</div>
<div class="proofscript" id="proof3376">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">gd</span>, (<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">gd</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">prog_defmap_dom</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_symbol_inversion</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">gd</span> <span class="id">DM</span>]. <span class="tactic">rewrite</span> <span class="id">Genv.find_def_symbol</span> <span class="kwd">in</span> <span class="id">DM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">DM</span> <span class="kwd">as</span> (<span class="id">b</span>'' &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="id">fold</span> <span class="id">ge</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">rewrite</span> <span class="id">P</span> <span class="kwd">in</span> <span class="id">B</span>; <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">ge</span> <span class="kwd">in</span> <span class="id">Q</span>. <span class="id">exploit</span> <span class="id">defs_inject</span>. <span class="tactic">apply</span> <span class="id">init_meminj_preserves_globals</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">X</span> &amp; <span class="id">_</span> &amp; <span class="id">Y</span>). <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">id</span>, <span class="id">gd</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">INIT_MEM</span>.<br/>
<br/>
<span class="kwd">Variables</span> <span class="id">m</span> <span class="id">tm</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">IM</span>: <span class="id">Genv.init_mem</span> <span class="id">p</span> = <span class="id">Some</span> <span class="id">m</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TIM</span>: <span class="id">Genv.init_mem</span> <span class="id">tp</span> = <span class="id">Some</span> <span class="id">tm</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bytes_of_init_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">il</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">ref_init</span> <span class="id">il</span> <span class="id">id</span> -&gt; <span class="id">kept</span> <span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">memval_inject</span> <span class="id">init_meminj</span>) (<span class="id">Genv.bytes_of_init_data_list</span> <span class="id">ge</span> <span class="id">il</span>) (<span class="id">Genv.bytes_of_init_data_list</span> <span class="id">tge</span> <span class="id">il</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3377')">Proof.</div>
<div class="proofscript" id="proof3377">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span> <span class="kwd">as</span> [ | <span class="id">i1</span> <span class="id">il</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="tactic">apply</span> <span class="id">list_forall2_app</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">i1</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">inj_bytes_inject</span>). <br/>
&nbsp;&nbsp;<span class="tactic">induction</span> (<span class="id">Z.to_nat</span> <span class="id">z</span>); <span class="tactic">simpl</span>; <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">FS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">kept</span> <span class="id">i</span>). { <span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">red</span>. <span class="id">exists</span> <span class="id">i0</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>. <span class="tactic">apply</span> <span class="id">init_meminj_preserves_globals</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">b</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">inj_value_inject</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">Ptrofs.add_zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">i</span>) <span class="kwd">as</span> [<span class="id">b</span>'|] <span class="id">eqn</span>:<span class="id">FS</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_3</span>. <span class="tactic">apply</span> <span class="id">init_meminj_preserves_globals</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">repeat_Undef_inject_self</span>.<br/>
+ <span class="tactic">apply</span> <span class="id">IHil</span>. <span class="tactic">intros</span> <span class="id">id</span> [<span class="id">ofs</span> <span class="id">IN</span>]. <span class="tactic">apply</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">ofs</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">Mem_getN_forall2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">P</span>: <span class="id">memval</span> -&gt; <span class="id">memval</span> -&gt; <span class="kwd">Prop</span>) <span class="id">c1</span> <span class="id">c2</span> <span class="id">i</span> <span class="id">n</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">P</span> (<span class="id">Mem.getN</span> <span class="id">n</span> <span class="id">p</span> <span class="id">c1</span>) (<span class="id">Mem.getN</span> <span class="id">n</span> <span class="id">p</span> <span class="id">c2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">p</span> &lt;= <span class="id">i</span> -&gt; <span class="id">i</span> &lt; <span class="id">p</span> + <span class="id">Z.of_nat</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">P</span> (<span class="id">ZMap.get</span> <span class="id">i</span> <span class="id">c1</span>) (<span class="id">ZMap.get</span> <span class="id">i</span> <span class="id">c2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3378')">Proof.</div>
<div class="proofscript" id="proof3378">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="tactic">simpl</span> <span class="id">Mem.getN</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">omegaContradiction</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">inj_S</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">i</span> <span class="id">p0</span>).<br/>
+ <span class="tactic">congruence</span>.<br/>
+ <span class="tactic">apply</span> <span class="id">IHn</span> <span class="kwd">with</span> (<span class="id">p0</span> + 1); <span class="tactic">auto</span>. <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_mem_inj_1</span>:<br/>
&nbsp;&nbsp;<span class="id">Mem.mem_inj</span> <span class="id">init_meminj</span> <span class="id">m</span> <span class="id">tm</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3379')">Proof.</div>
<div class="proofscript" id="proof3379">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert_strong</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">gd</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">p</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">tp</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gd</span> <span class="kwd">as</span> [<span class="id">f</span>|<span class="id">v</span>].<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q1</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">auto</span>.<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span> &amp; <span class="id">R2</span> &amp; <span class="id">S2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span> &amp; <span class="id">R1</span> &amp; <span class="id">S1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q1</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P2</span>. <span class="tactic">omega</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">delta</span>. <span class="tactic">apply</span> <span class="id">Zdivide_0</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert_strong</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">gd</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">p</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">tp</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gd</span> <span class="kwd">as</span> [<span class="id">f</span>|<span class="id">v</span>].<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q1</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span> &amp; <span class="id">R2</span> &amp; <span class="id">S2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span> &amp; <span class="id">R1</span> &amp; <span class="id">S1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q1</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NO</span>: <span class="id">gvar_volatile</span> <span class="id">v</span> = <span class="id">false</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">Genv.perm_globvar</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> (<span class="id">gvar_volatile</span> <span class="id">v</span>); <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>. }<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Mem.loadbytes</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">S1</span> <span class="id">NO</span>). <span class="tactic">unfold</span> <span class="id">Mem.loadbytes</span>. <span class="tactic">destruct</span> <span class="id">Mem.range_perm_dec</span>; <span class="tactic">intros</span> <span class="id">E1</span>; <span class="id">inv</span> <span class="id">E1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">S2</span> <span class="id">NO</span>). <span class="tactic">unfold</span> <span class="id">Mem.loadbytes</span>. <span class="tactic">destruct</span> <span class="id">Mem.range_perm_dec</span>; <span class="tactic">intros</span> <span class="id">E2</span>; <span class="id">inv</span> <span class="id">E2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Zplus_0_r</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem_getN_forall2</span> <span class="kwd">with</span> (<span class="id">p</span> := 0) (<span class="id">n</span> := <span class="id">nat_of_Z</span> (<span class="id">init_data_list_size</span> (<span class="id">gvar_init</span> <span class="id">v</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>, <span class="id">H4</span>. <span class="tactic">apply</span> <span class="id">bytes_of_init_inject</span>. <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">omega</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">nat_of_Z_eq</span> <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">init_data_list_size_pos</span>). <span class="tactic">omega</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_mem_inj_2</span>:<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">init_meminj</span> <span class="id">m</span> <span class="id">tm</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3380')">Proof.</div>
<div class="proofscript" id="proof3380">
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">apply</span> <span class="id">init_mem_inj_1</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">init_meminj</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>]|] <span class="id">eqn</span>:<span class="id">INJ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H</span>. <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.find_symbol_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.find_symbol_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">init_meminj_invert</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">intros</span> (<span class="id">A1</span> &amp; <span class="id">id1</span> &amp; <span class="id">B1</span> &amp; <span class="id">C1</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">init_meminj_invert</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">intros</span> (<span class="id">A2</span> &amp; <span class="id">id2</span> &amp; <span class="id">B2</span> &amp; <span class="id">C2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id1</span> <span class="id">id2</span>). <span class="tactic">congruence</span>. <span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">Genv.global_addresses_distinct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <span class="tactic">subst</span> <span class="id">delta</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">omega</span>. <span class="tactic">generalize</span> (<span class="id">Ptrofs.unsigned_range_2</span> <span class="id">ofs</span>). <span class="tactic">omega</span>.<br/>
- <span class="id">exploit</span> <span class="id">init_meminj_invert_strong</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">A</span> &amp; <span class="id">id</span> &amp; <span class="id">gd</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">p</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">Genv.init_mem_characterization_gen</span> <span class="id">tp</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gd</span> <span class="kwd">as</span> [<span class="id">f</span>|<span class="id">v</span>].<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q2</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">subst</span>. <span class="tactic">replace</span> <span class="id">ofs</span> <span class="kwd">with</span> 0 <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">Mem.perm_cur</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">intros</span> (<span class="id">P2</span> &amp; <span class="id">Q2</span> &amp; <span class="id">R2</span> &amp; <span class="id">S2</span>) (<span class="id">P1</span> &amp; <span class="id">Q1</span> &amp; <span class="id">R1</span> &amp; <span class="id">S1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Q2</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">apply</span> <span class="id">Mem.perm_cur</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_implies</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">P1</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">INIT_MEM</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_mem_exists</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>, <span class="id">Genv.init_mem</span> <span class="id">p</span> = <span class="id">Some</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>, <span class="id">Genv.init_mem</span> <span class="id">tp</span> = <span class="id">Some</span> <span class="id">tm</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3381')">Proof.</div>
<div class="proofscript" id="proof3381">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Genv.init_mem_exists</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">P</span>: (<span class="id">prog_defmap</span> <span class="id">tp</span>)!<span class="id">id</span> = <span class="id">Some</span> (<span class="id">Gvar</span> <span class="id">v</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">prog_defmap_norepet</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_prog_unique</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_prog_def</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">TRANSF</span>) <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used</span>) <span class="id">eqn</span>:<span class="id">U</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.init_mem_inversion</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">in_prog_defmap</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">AL</span> <span class="id">FV</span>].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">FV</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">FS</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transform_find_symbol_1</span> <span class="kwd">with</span> <span class="id">b</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">kept_closed</span> <span class="kwd">with</span> <span class="id">id</span> (<span class="id">Gvar</span> <span class="id">v</span>). <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IS.mem_2</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">red</span>. <span class="tactic">red</span>. <span class="id">exists</span> <span class="id">o</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">init_mem_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.init_mem</span> <span class="id">p</span> = <span class="id">Some</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">f</span> <span class="id">tm</span>, <span class="id">Genv.init_mem</span> <span class="id">tp</span> = <span class="id">Some</span> <span class="id">tm</span> /\ <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> /\ <span class="id">meminj_preserves_globals</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3382')">Proof.</div>
<div class="proofscript" id="proof3382">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">init_mem_exists</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span> <span class="id">INIT</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">init_meminj</span>, <span class="id">tm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">init_mem_inj_2</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">init_meminj_preserves_globals</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span>, <span class="id">initial_state</span> <span class="id">p</span> <span class="id">S1</span> -&gt; <span class="id">exists</span> <span class="id">S2</span>, <span class="id">initial_state</span> <span class="id">tp</span> <span class="id">S2</span> /\ <span class="id">match_states</span> <span class="id">S1</span> <span class="id">S2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3383')">Proof.</div>
<div class="proofscript" id="proof3383">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">exploit</span> <span class="id">init_mem_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">j</span> &amp; <span class="id">tm</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">symbols_inject_2</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">kept_main</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">intros</span> (<span class="id">tb</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">H2</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">defs_inject</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">Q</span>. <span class="tactic">exact</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">R</span> &amp; <span class="id">S</span> &amp; <span class="id">T</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Genv.find_funct_ptr_iff</span> <span class="kwd">in</span> <span class="id">R</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">nil</span> <span class="id">f</span> <span class="id">nil</span> <span class="id">tm</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">tge</span>. <span class="id">erewrite</span> <span class="id">match_prog_main</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">Genv.init_mem_genv_next</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">Genv.init_mem_genv_next</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">S2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">S1</span> <span class="id">S2</span> -&gt; <span class="id">final_state</span> <span class="id">S1</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">S2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3384')">Proof.</div>
<div class="proofscript" id="proof3384">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">STACKS</span>. <span class="id">inv</span> <span class="id">RESINJ</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_correct_1</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">semantics</span> <span class="id">p</span>) (<span class="id">semantics</span> <span class="id">tp</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3385')">Proof.</div>
<div class="proofscript" id="proof3385">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_step</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">globals_symbols_inject</span>. <span class="tactic">apply</span> <span class="id">init_meminj_preserves_globals</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">exact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_final_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">step_simulation</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SOUNDNESS</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span> -&gt; <span class="id">forward_simulation</span> (<span class="id">semantics</span> <span class="id">p</span>) (<span class="id">semantics</span> <span class="id">tp</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3386')">Proof.</div>
<div class="proofscript" id="proof3386">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">p</span> <span class="id">tp</span> (<span class="id">used</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).  <span class="tactic">apply</span> <span class="id">transf_program_correct_1</span> <span class="kwd">with</span> <span class="id">used</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Commutation with linking </h1>
<br/>
<span class="kwd">Remark</span> <span class="id">link_def_either</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">gd1</span> <span class="id">gd2</span> <span class="id">gd</span>: <span class="id">globdef</span> <span class="id">fundef</span> <span class="id">unit</span>),<br/>
&nbsp;&nbsp;<span class="id">link_def</span> <span class="id">gd1</span> <span class="id">gd2</span> = <span class="id">Some</span> <span class="id">gd</span> -&gt; <span class="id">gd</span> = <span class="id">gd1</span> \/ <span class="id">gd</span> = <span class="id">gd2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3387')">Proof with</div>
<div class="proofscript" id="proof3387">
 (<span class="tactic">try</span> <span class="tactic">discriminate</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">gd</span>.<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Linker_def</span> <span class="id">Linker_fundef</span> <span class="id">Linker_varinit</span> <span class="id">Linker_vardef</span> <span class="id">Linker_unit</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gd1</span> <span class="kwd">as</span> [<span class="id">f1</span>|<span class="id">v1</span>], <span class="id">gd2</span> <span class="kwd">as</span> [<span class="id">f2</span>|<span class="id">v2</span>]...<br/>
&nbsp;Two&nbsp;fundefs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f1</span> <span class="kwd">as</span> [<span class="id">f1</span>|<span class="id">ef1</span>], <span class="id">f2</span> <span class="kwd">as</span> [<span class="id">f2</span>|<span class="id">ef2</span>]; <span class="tactic">simpl</span>...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ef2</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ef1</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">external_function_eq</span> <span class="id">ef1</span> <span class="id">ef2</span>); <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Two&nbsp;vardefs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">link_vardef</span>. <span class="tactic">destruct</span> <span class="id">v1</span> <span class="kwd">as</span> [<span class="id">info1</span> <span class="id">init1</span> <span class="id">ro1</span> <span class="id">vo1</span>], <span class="id">v2</span> <span class="kwd">as</span> [<span class="id">info2</span> <span class="id">init2</span> <span class="id">ro2</span> <span class="id">vo2</span>]; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link_varinit</span> <span class="id">init1</span> <span class="id">init2</span>) <span class="kwd">as</span> [<span class="id">init</span>|] <span class="id">eqn</span>:<span class="id">LI</span>...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eqb</span> <span class="id">ro1</span> <span class="id">ro2</span>) <span class="id">eqn</span>:<span class="id">RO</span>...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eqb</span> <span class="id">vo1</span> <span class="id">vo2</span>) <span class="id">eqn</span>:<span class="id">VO</span>...<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">info1</span>, <span class="id">info2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EITHER</span>: <span class="id">init</span> = <span class="id">init1</span> \/ <span class="id">init</span> = <span class="id">init2</span>).<br/>
&nbsp;&nbsp;{ <span class="id">revert</span> <span class="id">LI</span>. <span class="tactic">unfold</span> <span class="id">link_varinit</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_init</span> <span class="id">init1</span>), (<span class="id">classify_init</span> <span class="id">init2</span>); <span class="tactic">intro</span> <span class="id">EQ</span>; <span class="id">inv</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">sz</span> (<span class="id">Z.max</span> <span class="id">sz0</span> 0 + 0)); <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">sz</span> (<span class="id">init_data_list_size</span> <span class="id">il</span>)); <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">sz</span> (<span class="id">init_data_list_size</span> <span class="id">il</span>)); <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eqb_prop</span> <span class="kwd">in</span> <span class="id">RO</span>. <span class="tactic">apply</span> <span class="id">eqb_prop</span> <span class="kwd">in</span> <span class="id">VO</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">EQ</span>; <span class="id">inv</span> <span class="id">EQ</span>. <span class="tactic">destruct</span> <span class="id">EITHER</span>; <span class="tactic">subst</span> <span class="id">init</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">used_not_defined</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">used</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p</span> <span class="id">used</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used</span> = <span class="id">false</span> \/ <span class="id">id</span> = <span class="id">prog_main</span> <span class="id">p</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3388')">Proof.</div>
<div class="proofscript" id="proof3388">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used</span>) <span class="id">eqn</span>:<span class="id">M</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">used_defined</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">IS.mem_2</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>]; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">prog_defmap_dom</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> [<span class="id">g</span> <span class="id">E</span>]; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">used_not_defined_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">used</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p</span> <span class="id">used</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">id</span> &lt;&gt; <span class="id">prog_main</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">prog_defmap</span> <span class="id">p</span>)!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;~<span class="id">IS.In</span> <span class="id">id</span> <span class="id">used</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3389')">Proof.</div>
<div class="proofscript" id="proof3389">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">used_not_defined</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">IS.mem_1</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">link_valid_used_set</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p1</span> <span class="id">p2</span> <span class="id">p</span> <span class="id">used1</span> <span class="id">used2</span>,<br/>
&nbsp;&nbsp;<span class="id">link</span> <span class="id">p1</span> <span class="id">p2</span> = <span class="id">Some</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p1</span> <span class="id">used1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p2</span> <span class="id">used2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valid_used_set</span> <span class="id">p</span> (<span class="id">IS.union</span> <span class="id">used1</span> <span class="id">used2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3390')">Proof.</div>
<div class="proofscript" id="proof3390">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">used2</span>; <span class="tactic">intros</span> <span class="id">L</span> <span class="id">V1</span> <span class="id">V2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link_prog_inv</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">L</span>) <span class="kwd">as</span> (<span class="id">X</span> &amp; <span class="id">Y</span> &amp; <span class="id">Z</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Z</span>; <span class="tactic">clear</span> <span class="id">Z</span>; <span class="id">constructor</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">ISF.union_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">ISF.union_iff</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">prog_defmap_elements</span>, <span class="id">PTree.gcombine</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p1</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd1</span>|] <span class="id">eqn</span>:<span class="id">GD1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p2</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd2</span>|] <span class="id">eqn</span>:<span class="id">GD2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
+ <span class="comment">(*&nbsp;common&nbsp;definition&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Y</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">PUB1</span> &amp; <span class="id">PUB2</span> &amp; <span class="id">_</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">link_def_either</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">EQ</span>|<span class="id">EQ</span>]; <span class="tactic">subst</span> <span class="id">gd</span>.<br/>
* <span class="id">left</span>. <span class="tactic">eapply</span> <span class="id">used_closed</span>. <span class="id">eexact</span> <span class="id">V1</span>. <span class="tactic">eapply</span> <span class="id">used_public</span>. <span class="id">eexact</span> <span class="id">V1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>. <br/>
* <span class="id">right</span>. <span class="tactic">eapply</span> <span class="id">used_closed</span>. <span class="id">eexact</span> <span class="id">V2</span>. <span class="tactic">eapply</span> <span class="id">used_public</span>. <span class="id">eexact</span> <span class="id">V2</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;left&nbsp;definition&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">ISP.In_dec</span> <span class="id">id</span> <span class="id">used1</span>).<br/>
* <span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">used_closed</span>; <span class="tactic">eauto</span>.<br/>
* <span class="tactic">assert</span> (<span class="id">IS.In</span> <span class="id">id</span> <span class="id">used2</span>) <span class="tactic">by</span> <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">used_defined</span>. <span class="id">eexact</span> <span class="id">V2</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">prog_defmap_dom</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">g</span> <span class="id">E</span>]; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">rewrite</span> <span class="id">A</span>, &lt;- <span class="id">X</span>. <span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;right&nbsp;definition&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">ISP.In_dec</span> <span class="id">id</span> <span class="id">used2</span>).<br/>
* <span class="id">right</span>; <span class="tactic">eapply</span> <span class="id">used_closed</span>; <span class="tactic">eauto</span>.<br/>
* <span class="tactic">assert</span> (<span class="id">IS.In</span> <span class="id">id</span> <span class="id">used1</span>) <span class="tactic">by</span> <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">used_defined</span>. <span class="id">eexact</span> <span class="id">V1</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">prog_defmap_dom</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">g</span> <span class="id">E</span>]; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">rewrite</span> <span class="id">A</span>, <span class="id">X</span>. <span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;no&nbsp;definition&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">ISF.union_iff</span>; <span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">simpl</span>. <span class="tactic">intros</span> <span class="id">id</span>. <span class="tactic">rewrite</span> <span class="id">in_app_iff</span>, <span class="id">ISF.union_iff</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>]; [<span class="id">left</span>|<span class="id">right</span>]; <span class="tactic">eapply</span> <span class="id">used_public</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">ISF.union_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id</span> (<span class="id">prog_main</span> <span class="id">p1</span>)).<br/>
+ <span class="id">right</span>; <span class="tactic">assumption</span>.<br/>
+ <span class="tactic">assert</span> (<span class="id">E</span>: <span class="id">exists</span> <span class="id">g</span>, <span class="id">link_prog_merge</span> (<span class="id">prog_defmap</span> <span class="id">p1</span>)!<span class="id">id</span> (<span class="id">prog_defmap</span> <span class="id">p2</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">g</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p1</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd1</span>|] <span class="id">eqn</span>:<span class="id">GD1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p2</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd2</span>|] <span class="id">eqn</span>:<span class="id">GD2</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">Y</span> <span class="kwd">with</span> <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="id">exists</span> <span class="id">gd1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="id">exists</span> <span class="id">gd2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">used_not_defined_2</span> <span class="kwd">in</span> <span class="id">GD1</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">used_not_defined_2</span> <span class="kwd">in</span> <span class="id">GD2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">E</span> <span class="kwd">as</span> [<span class="id">g</span> <span class="id">LD</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">unfold</span> <span class="id">prog_defs_names</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">g</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gcombine</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">link_match_program</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p1</span> <span class="id">p2</span> <span class="id">tp1</span> <span class="id">tp2</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">link</span> <span class="id">p1</span> <span class="id">p2</span> = <span class="id">Some</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_prog</span> <span class="id">p1</span> <span class="id">tp1</span> -&gt; <span class="id">match_prog</span> <span class="id">p2</span> <span class="id">tp2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tp</span>, <span class="id">link</span> <span class="id">tp1</span> <span class="id">tp2</span> = <span class="id">Some</span> <span class="id">tp</span> /\ <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3391')">Proof.</div>
<div class="proofscript" id="proof3391">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> (<span class="id">used1</span> &amp; <span class="id">A1</span> &amp; <span class="id">B1</span>). <span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> (<span class="id">used2</span> &amp; <span class="id">A2</span> &amp; <span class="id">B2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link_prog_inv</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> (<span class="id">U</span> &amp; <span class="id">V</span> &amp; <span class="id">W</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <br/>
- <span class="tactic">apply</span> <span class="id">link_prog_succeeds</span>.<br/>
+ <span class="tactic">rewrite</span> (<span class="id">match_prog_main</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B1</span>), (<span class="id">match_prog_main</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B2</span>). <span class="tactic">auto</span>.<br/>
+ <span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_prog_def</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B1</span>) <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_prog_def</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B2</span>) <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span>) <span class="id">eqn</span>:<span class="id">U1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span>) <span class="id">eqn</span>:<span class="id">U2</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">V</span> <span class="kwd">as</span> (<span class="id">X</span> &amp; <span class="id">Y</span> &amp; <span class="id">gd</span> &amp; <span class="id">Z</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> (<span class="id">match_prog_public</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B1</span>); <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> (<span class="id">match_prog_public</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
- <span class="id">exists</span> (<span class="id">IS.union</span> <span class="id">used1</span> <span class="id">used2</span>); <span class="tactic">split</span>.<br/>
+ <span class="tactic">eapply</span> <span class="id">link_valid_used_set</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">W</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
* <span class="tactic">eapply</span> <span class="id">match_prog_main</span>; <span class="tactic">eauto</span>.<br/>
* <span class="tactic">rewrite</span> (<span class="id">match_prog_public</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B1</span>), (<span class="id">match_prog_public</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B2</span>). <span class="tactic">auto</span>.<br/>
* <span class="tactic">rewrite</span> ! <span class="id">prog_defmap_elements</span>, !<span class="id">PTree.gcombine</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_prog_def</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B1</span> <span class="id">id</span>), (<span class="id">match_prog_def</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B2</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISF.union_b</span>.<br/>
{<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p1</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd1</span>|] <span class="id">eqn</span>:<span class="id">GD1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_defmap</span> <span class="id">p2</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">gd2</span>|] <span class="id">eqn</span>:<span class="id">GD2</span>.<br/>
- <span class="comment">(*&nbsp;both&nbsp;defined&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">V</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">PUB1</span> &amp; <span class="id">PUB2</span> &amp; <span class="id">_</span>). <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EQ1</span>: <span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span> = <span class="id">true</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">IS.mem_1</span>; <span class="tactic">eapply</span> <span class="id">used_public</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EQ2</span>: <span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span> = <span class="id">true</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">IS.mem_1</span>; <span class="tactic">eapply</span> <span class="id">used_public</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ1</span>, <span class="id">EQ2</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;left&nbsp;defined&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">used_not_defined</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>, <span class="id">orb_false_r</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span>) <span class="kwd">with</span> <span class="id">true</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">IS.mem_1</span>. <span class="tactic">rewrite</span> <span class="id">A</span>, &lt;- <span class="id">U</span>. <span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;right&nbsp;defined&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">used_not_defined</span>. <span class="id">eexact</span> <span class="id">A1</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>, <span class="id">orb_false_l</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span>) <span class="kwd">with</span> <span class="id">true</span>. <span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">IS.mem_1</span>. <span class="tactic">rewrite</span> <span class="id">A</span>, <span class="id">U</span>. <span class="tactic">eapply</span> <span class="id">used_main</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;none&nbsp;defined&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used1</span>), (<span class="id">IS.mem</span> <span class="id">id</span> <span class="id">used2</span>); <span class="tactic">auto</span>.<br/>
}<br/>
* <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_keys_norepet</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Instance</span> <span class="id">TransfSelectionLink</span> : <span class="id">TransfLink</span> <span class="id">match_prog</span> := <span class="id">link_match_program</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
