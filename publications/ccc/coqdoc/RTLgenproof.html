<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module RTLgenproof</title>
<meta name="description" content="Documentation of Coq module RTLgenproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module RTLgenproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for RTL generation. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Smallstep</span> <span class="id">Globalenvs</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Switch</span> <span class="id">Registers</span> <span class="id">Cminor</span> <span class="id">Op</span> <span class="id">CminorSel</span> <span class="id">RTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">RTLgen</span> <span class="id">RTLgenspec</span>.<br/>
<br/>
<h1> Correspondence between Cminor environments and RTL register sets </h1>
<br/>
<div class="doc">A compilation environment (mapping) is well-formed if
  the following properties hold:
<ul>
<li>
 Two distinct Cminor local variables are mapped to distinct pseudo-registers.
</li>
<li>
 A Cminor local variable and a let-bound variable are mapped to
  distinct pseudo-registers.
</li>
</ul>
</div>
<br/>
<span class="kwd">Record</span> <span class="id">map_wf</span> (<span class="id">m</span>: <span class="id">mapping</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_map_wf</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_wf_inj</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id1</span> <span class="id">id2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span>.(<span class="id">map_vars</span>)!<span class="id">id1</span> = <span class="id">Some</span> <span class="id">r</span> -&gt; <span class="id">m</span>.(<span class="id">map_vars</span>)!<span class="id">id2</span> = <span class="id">Some</span> <span class="id">r</span> -&gt; <span class="id">id1</span> = <span class="id">id2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_wf_disj</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span>.(<span class="id">map_vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">r</span> -&gt; <span class="id">In</span> <span class="id">r</span> <span class="id">m</span>.(<span class="id">map_letvars</span>) -&gt; <span class="id">False</span>)<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_mapping_wf</span>:<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">init_mapping</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2512')">Proof.</div>
<div class="proofscript" id="proof2512">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">init_mapping</span>; <span class="tactic">split</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">r</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_var_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">map</span> <span class="id">name</span> <span class="id">r</span> <span class="id">map</span>' <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">add_var</span> <span class="id">map</span> <span class="id">name</span> <span class="id">s1</span> = <span class="id">OK</span> (<span class="id">r</span>,<span class="id">map</span>') <span class="id">s2</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt; <span class="id">map_valid</span> <span class="id">map</span> <span class="id">s1</span> -&gt; <span class="id">map_wf</span> <span class="id">map</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2513')">Proof.</div>
<div class="proofscript" id="proof2513">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mk_map_wf</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">r0</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id1</span> <span class="id">name</span>); <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id2</span> <span class="id">name</span>).<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">elimtype</span> <span class="id">False</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">valid_fresh_absurd</span> <span class="kwd">with</span> <span class="id">r0</span> <span class="id">s1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">id2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">elimtype</span> <span class="id">False</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">valid_fresh_absurd</span> <span class="kwd">with</span> <span class="id">r0</span> <span class="id">s1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">id1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">r0</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">name</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">valid_fresh_absurd</span> <span class="kwd">with</span> <span class="id">r0</span> <span class="id">s1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="id">right</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_vars_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">names</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">map</span> <span class="id">map</span>' <span class="id">rl</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">add_vars</span> <span class="id">map</span> <span class="id">names</span> <span class="id">s1</span> = <span class="id">OK</span> (<span class="id">rl</span>,<span class="id">map</span>') <span class="id">s2</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt; <span class="id">map_valid</span> <span class="id">map</span> <span class="id">s1</span> -&gt; <span class="id">map_wf</span> <span class="id">map</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2514')">Proof.</div>
<div class="proofscript" id="proof2514">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">names</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">add_vars_valid</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_var_wf</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_letvar_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt; ~<span class="id">reg_in_map</span> <span class="id">map</span> <span class="id">r</span> -&gt; <span class="id">map_wf</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2515')">Proof.</div>
<div class="proofscript" id="proof2515">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">add_letvar</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">H1</span>; <span class="tactic">intro</span>. <span class="tactic">subst</span> <span class="id">r0</span>. <span class="tactic">elim</span> <span class="id">H0</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">An RTL register environment matches a CminorSel local environment and
  let-environment if the value of every local or let-bound variable in
  the CminorSel environments is identical to the value of the
  corresponding pseudo-register in the RTL register environment. </div>
<br/>
<span class="kwd">Record</span> <span class="id">match_env</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">map</span>: <span class="id">mapping</span>) (<span class="id">e</span>: <span class="id">env</span>) (<span class="id">le</span>: <span class="id">letenv</span>) (<span class="id">rs</span>: <span class="id">regset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_match_env</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_vars</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">exists</span> <span class="id">r</span>, <span class="id">map</span>.(<span class="id">map_vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">r</span> /\ <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>#<span class="id">r</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_letvars</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">le</span> <span class="id">rs</span>##(<span class="id">map</span>.(<span class="id">map_letvars</span>))<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_find_var</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">id</span> <span class="id">v</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map</span>.(<span class="id">map_vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>#<span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2516')">Proof.</div>
<div class="proofscript" id="proof2516">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">r</span>' [<span class="id">EQ</span>' <span class="id">RS</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">r</span> <span class="kwd">with</span> <span class="id">r</span>'. <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_find_letvar</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">idx</span> <span class="id">v</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">List.nth_error</span> <span class="id">le</span> <span class="id">idx</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">List.nth_error</span> <span class="id">map</span>.(<span class="id">map_letvars</span>) <span class="id">idx</span> = <span class="id">Some</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>#<span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2517')">Proof.</div>
<div class="proofscript" id="proof2517">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_letvars</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">H</span>. <span class="id">revert</span> <span class="id">le</span> <span class="id">H0</span> <span class="id">H1</span>. <span class="tactic">generalize</span> (<span class="id">map_letvars</span> <span class="id">map</span>). <span class="tactic">clear</span> <span class="id">map</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">idx</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">le</span>; <span class="tactic">inversion</span> <span class="id">H0</span>. <span class="tactic">subst</span> <span class="id">v1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">inversion</span> <span class="id">H1</span>. <span class="tactic">subst</span> <span class="id">r0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H2</span>. <span class="tactic">subst</span> <span class="id">v2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">destruct</span> <span class="id">le</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHidx</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, (<span class="id">reg_in_map</span> <span class="id">map</span> <span class="id">r</span>) -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2518')">Proof.</div>
<div class="proofscript" id="proof2518">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">mk_match_env</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_vars0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">r</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">r</span>; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">rs</span>'##(<span class="id">map_letvars</span> <span class="id">map</span>)) <span class="kwd">with</span> (<span class="id">rs</span> ## (<span class="id">map_letvars</span> <span class="id">map</span>)). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_map_exten</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H0</span>. <span class="id">right</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching between environments is preserved when an unmapped register
  (not corresponding to any Cminor variable) is assigned in the RTL
  execution. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_update_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;~(<span class="id">reg_in_map</span> <span class="id">map</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">v</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2519')">Proof.</div>
<div class="proofscript" id="proof2519">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_env_invariant</span> <span class="kwd">with</span> <span class="id">rs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">case</span> (<span class="id">Reg.eq</span> <span class="id">r</span> <span class="id">r0</span>); <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">r0</span>; <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Regmap.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">match_env_update_temp</span>: <span class="id">rtlg</span>.<br/>
<br/>
<div class="doc">Matching between environments is preserved by simultaneous
  assignment to a Cminor local variable (in the Cminor environments)
  and to the corresponding RTL pseudo-register (in the RTL register
  environment). </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_update_var</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">id</span> <span class="id">r</span> <span class="id">v</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map</span>.(<span class="id">map_vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span> <span class="id">e</span>) <span class="id">le</span> (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">tv</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2520')">Proof.</div>
<div class="proofscript" id="proof2520">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H0</span>. <span class="tactic">inversion</span> <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">mk_match_env</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span>' <span class="id">v</span>'. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span>' <span class="id">id</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id</span>'. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">exists</span> <span class="id">r</span>; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">r</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">r</span>'; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">r</span>'. <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">list_map_exten</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">PMap.gso</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">x</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">A variant of <span class="bracket"><span class="id">match_env_update_var</span></span> where a variable is optionally
  assigned to, depending on the <span class="bracket"><span class="id">dst</span></span> parameter. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_update_dest</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">dst</span> <span class="id">r</span> <span class="id">v</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">reg_map_ok</span> <span class="id">map</span> <span class="id">r</span> <span class="id">dst</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> (<span class="id">set_optvar</span> <span class="id">dst</span> <span class="id">v</span> <span class="id">e</span>) <span class="id">le</span> (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">tv</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2521')">Proof.</div>
<div class="proofscript" id="proof2521">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_update_temp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_update_var</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">match_env_update_dest</span>: <span class="id">rtlg</span>.<br/>
<br/>
<div class="doc">A variant of <span class="bracket"><span class="id">match_env_update_var</span></span> corresponding to the assignment
  of the result of a builtin. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_update_res</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">res</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">tres</span> <span class="id">tv</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tr_builtin_res</span> <span class="id">map</span> <span class="id">res</span> <span class="id">tres</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> (<span class="id">set_builtin_res</span> <span class="id">res</span> <span class="id">v</span> <span class="id">e</span>) <span class="id">le</span> (<span class="id">regmap_setres</span> <span class="id">tres</span> <span class="id">tv</span> <span class="id">rs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2522')">Proof.</div>
<div class="proofscript" id="proof2522">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">match_env_update_var</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">match_env_update_temp</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching and <span class="bracket"><span class="kwd">let</span></span>-bound variables. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_bind_letvar</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>#<span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>) <span class="id">e</span> (<span class="id">v</span> :: <span class="id">le</span>) <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2523')">Proof.</div>
<div class="proofscript" id="proof2523">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">add_letvar</span>. <span class="tactic">apply</span> <span class="id">mk_match_env</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_unbind_letvar</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>) <span class="id">e</span> (<span class="id">v</span> :: <span class="id">le</span>) <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2524')">Proof.</div>
<div class="proofscript" id="proof2524">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_letvar</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>. <span class="tactic">inversion</span> <span class="id">me_letvars0</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching between initial environments. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_empty</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map</span>,<br/>
&nbsp;&nbsp;<span class="id">map</span>.(<span class="id">map_letvars</span>) = <span class="id">nil</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> (<span class="id">PTree.empty</span> <span class="id">val</span>) <span class="id">nil</span> (<span class="id">Regmap.init</span> <span class="id">Vundef</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2525')">Proof.</div>
<div class="proofscript" id="proof2525">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">mk_match_env</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The assignment of function arguments to local variables (on the Cminor
  side) and pseudo-registers (on the RTL side) preserves matching
  between environments. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_set_params_init_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">il</span> <span class="id">rl</span> <span class="id">s1</span> <span class="id">map2</span> <span class="id">s2</span> <span class="id">vl</span> <span class="id">tvl</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">add_vars</span> <span class="id">init_mapping</span> <span class="id">il</span> <span class="id">s1</span> = <span class="id">OK</span> (<span class="id">rl</span>, <span class="id">map2</span>) <span class="id">s2</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">tvl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map2</span> (<span class="id">set_params</span> <span class="id">vl</span> <span class="id">il</span>) <span class="id">nil</span> (<span class="id">init_regs</span> <span class="id">tvl</span> <span class="id">rl</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">reg_fresh</span> <span class="id">r</span> <span class="id">s2</span> -&gt; (<span class="id">init_regs</span> <span class="id">tvl</span> <span class="id">rl</span>)#<span class="id">r</span> = <span class="id">Vundef</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2526')">Proof.</div>
<div class="proofscript" id="proof2526">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">match_env_empty</span>. <span class="tactic">auto</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">Regmap.gi</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">add_vars_valid</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">init_mapping_valid</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">add_var_valid</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>' <span class="id">B</span>']. <span class="tactic">clear</span> <span class="id">B</span>'.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [ | <span class="id">v1</span> <span class="id">tv1</span> <span class="id">vs</span> <span class="id">tvs</span>].<br/>
&nbsp;vl&nbsp;=&nbsp;nil&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IHil</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">_</span> <span class="id">EQ</span>) <span class="kwd">as</span> [<span class="id">ME</span> <span class="id">UNDEF</span>]. <span class="id">constructor</span>. <span class="id">inv</span> <span class="id">ME</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">init_regs</span> <span class="id">nil</span> <span class="id">x</span>) <span class="kwd">with</span> (<span class="id">Regmap.init</span> <span class="id">Vundef</span>) <span class="kwd">in</span> <span class="id">me_vars0</span>, <span class="id">me_letvars0</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span> <span class="id">v</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">x1</span>; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Regmap.gi</span>.<br/>
&nbsp;vl&nbsp;=&nbsp;v1&nbsp;::&nbsp;vs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IHil</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ</span> <span class="id">H0</span>) <span class="kwd">as</span> [<span class="id">ME</span> <span class="id">UNDEF</span>]. <span class="id">inv</span> <span class="id">ME</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span> <span class="id">v</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H1</span>. <span class="id">exists</span> <span class="id">x1</span>; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="id">eexists</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">r</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">r</span>'; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">valid_fresh_different</span> <span class="kwd">with</span> <span class="id">s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">B</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">map_letvars</span> <span class="id">x0</span>). <span class="tactic">auto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">me_letvars0</span>. <span class="tactic">inversion</span> <span class="id">me_letvars0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">apply</span> <span class="id">UNDEF</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">reg_fresh_decr</span> <span class="kwd">with</span> <span class="id">s2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sym_not_equal</span>. <span class="tactic">apply</span> <span class="id">valid_fresh_different</span> <span class="kwd">with</span> <span class="id">s2</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_set_locals</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">map1</span> <span class="id">s1</span>,<br/>
&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">il</span> <span class="id">rl</span> <span class="id">map2</span> <span class="id">s2</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map1</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">reg_fresh</span> <span class="id">r</span> <span class="id">s1</span> -&gt; <span class="id">rs</span>#<span class="id">r</span> = <span class="id">Vundef</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">add_vars</span> <span class="id">map1</span> <span class="id">il</span> <span class="id">s1</span> = <span class="id">OK</span> (<span class="id">rl</span>, <span class="id">map2</span>) <span class="id">s2</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map2</span> (<span class="id">set_locals</span> <span class="id">il</span> <span class="id">e</span>) <span class="id">le</span> <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2527')">Proof.</div>
<div class="proofscript" id="proof2527">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHil</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span> <span class="id">v</span>. <span class="tactic">simpl</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>). <span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x1</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">me_letvars</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_init_env_init_reg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">params</span> <span class="id">s0</span> <span class="id">rparams</span> <span class="id">map1</span> <span class="id">s1</span> <span class="id">i1</span> <span class="id">vars</span> <span class="id">rvars</span> <span class="id">map2</span> <span class="id">s2</span> <span class="id">i2</span> <span class="id">vparams</span> <span class="id">tvparams</span>,<br/>
&nbsp;&nbsp;<span class="id">add_vars</span> <span class="id">init_mapping</span> <span class="id">params</span> <span class="id">s0</span> = <span class="id">OK</span> (<span class="id">rparams</span>, <span class="id">map1</span>) <span class="id">s1</span> <span class="id">i1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">add_vars</span> <span class="id">map1</span> <span class="id">vars</span> <span class="id">s1</span> = <span class="id">OK</span> (<span class="id">rvars</span>, <span class="id">map2</span>) <span class="id">s2</span> <span class="id">i2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vparams</span> <span class="id">tvparams</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map2</span> (<span class="id">set_locals</span> <span class="id">vars</span> (<span class="id">set_params</span> <span class="id">vparams</span> <span class="id">params</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nil</span> (<span class="id">init_regs</span> <span class="id">tvparams</span> <span class="id">rparams</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2528')">Proof.</div>
<div class="proofscript" id="proof2528">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_set_params_init_regs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_set_locals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_vars_wf</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">init_mapping_wf</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">init_mapping_valid</span>.<br/>
Qed.</div>
<br/>
<h1> The simulation argument </h1>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Errors</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">CminorSel.program</span>) (<span class="id">tp</span>: <span class="id">RTL.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">Errors.OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transl_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2529')">Proof.</div>
<div class="proofscript" id="proof2529">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_transform_partial_program</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">CORRECTNESS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">CminorSel.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">RTL.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> : <span class="id">CminorSel.genv</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> : <span class="id">RTL.genv</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<div class="doc">Relationship between the global environments for the original
  CminorSel program and the generated RTL program. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">Genv.find_symbol_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">f</span>: <span class="id">CminorSel.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">Genv.find_funct_ptr_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">f</span>: <span class="id">CminorSel.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">Genv.find_funct_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_transl_function</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">f</span>: <span class="id">CminorSel.fundef</span>) (<span class="id">tf</span>: <span class="id">RTL.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">RTL.funsig</span> <span class="id">tf</span> = <span class="id">CminorSel.funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2530')">Proof.</div>
<div class="proofscript" id="proof2530">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">tf</span>. <span class="tactic">unfold</span> <span class="id">transl_fundef</span>, <span class="id">transf_partial_fundef</span>.<br/>
&nbsp;&nbsp;<span class="tactic">case</span> <span class="id">f</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reserve_labels</span> (<span class="id">fn_body</span> <span class="id">f0</span>) (<span class="id">PTree.empty</span> <span class="id">node</span>, <span class="id">init_state</span>)) <span class="kwd">as</span> [<span class="id">ngoto</span> <span class="id">s0</span>].<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">transl_fun</span> <span class="id">f0</span> <span class="id">ngoto</span> <span class="id">s0</span>); <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> (<span class="id">Genv.to_senv</span> <span class="id">ge</span>) (<span class="id">Genv.to_senv</span> <span class="id">tge</span>).<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">Genv.senv_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<div class="doc">Correctness of the code generated by <span class="bracket"><span class="id">add_move</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tr_move_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">ns</span> <span class="id">r2</span> <span class="id">nd</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">tr_move</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">ns</span> <span class="id">r1</span> <span class="id">nd</span> <span class="id">r2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">nd</span> <span class="id">rs</span>' <span class="id">m</span>) /\<br/>
&nbsp;&nbsp;<span class="id">rs</span>'#<span class="id">r2</span> = <span class="id">rs</span>#<span class="id">r1</span> /\<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">r</span> &lt;&gt; <span class="id">r2</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2531')">Proof.</div>
<div class="proofscript" id="proof2531">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs</span>#<span class="id">r2</span> &lt;- (<span class="id">rs</span>#<span class="id">r1</span>)); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Iop</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">Regmap.gss</span>. <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">Regmap.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Semantic preservation for the translation of expressions </h2>
<br/>
<span class="kwd">Section</span> <span class="id">CORRECTNESS_EXPR</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">e</span>: <span class="id">env</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<br/>
<div class="doc">The proof of semantic preservation for the translation of expressions
  is a simulation argument based on diagrams of the following form:
<pre>
                    I /\ P
    e, le, m, a ------------- State cs code sp ns rs tm
         ||                      |
         ||                      |*
         ||                      |
         \/                      v
    e, le, m, v ------------ State cs code sp nd rs' tm'
                    I /\ Q</pre>
  where <span class="bracket"><span class="id">tr_expr</span> <span class="id">code</span> <span class="id">map</span> <span class="id">pr</span> <span class="id">a</span> <span class="id">ns</span> <span class="id">nd</span> <span class="id">rd</span></span> is assumed to hold.
  The left vertical arrow represents an evaluation of the expression <span class="bracket"><span class="id">a</span></span>.
  The right vertical arrow represents the execution of zero, one or
  several instructions in the generated RTL flow graph <span class="bracket"><span class="id">code</span></span>.
  The invariant <span class="bracket"><span class="id">I</span></span> is the agreement between Cminor environments and
  RTL register environment, as captured by <span class="bracket"><span class="id">match_envs</span></span>.
  The precondition <span class="bracket"><span class="id">P</span></span> includes the well-formedness of the compilation
  environment <span class="bracket"><span class="id">mut</span></span>.
  The postconditions <span class="bracket"><span class="id">Q</span></span> state that in the final register environment
  <span class="bracket"><span class="id">rs</span>'</span>, register <span class="bracket"><span class="id">rd</span></span> contains value <span class="bracket"><span class="id">v</span></span>, and the registers in
  the set of preserved registers <span class="bracket"><span class="id">pr</span></span> are unchanged, as are the registers
  in the codomain of <span class="bracket"><span class="id">map</span></span>.
  We formalize this simulation property by the following predicate
  parameterized by the CminorSel evaluation (left arrow).  </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transl_expr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le</span>: <span class="id">letenv</span>) (<span class="id">a</span>: <span class="id">expr</span>) (<span class="id">v</span>: <span class="id">val</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">map</span> <span class="id">pr</span> <span class="id">ns</span> <span class="id">nd</span> <span class="id">rd</span> <span class="id">rs</span> <span class="id">dst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TE</span>: <span class="id">tr_expr</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">pr</span> <span class="id">a</span> <span class="id">ns</span> <span class="id">nd</span> <span class="id">rd</span> <span class="id">dst</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">tm</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">nd</span> <span class="id">rs</span>' <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">match_env</span> <span class="id">map</span> (<span class="id">set_optvar</span> <span class="id">dst</span> <span class="id">v</span> <span class="id">e</span>) <span class="id">le</span> <span class="id">rs</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>'#<span class="id">rd</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">pr</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>'.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transl_exprlist_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le</span>: <span class="id">letenv</span>) (<span class="id">al</span>: <span class="id">exprlist</span>) (<span class="id">vl</span>: <span class="id">list</span> <span class="id">val</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">map</span> <span class="id">pr</span> <span class="id">ns</span> <span class="id">nd</span> <span class="id">rl</span> <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TE</span>: <span class="id">tr_exprlist</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">pr</span> <span class="id">al</span> <span class="id">ns</span> <span class="id">nd</span> <span class="id">rl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">tm</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">nd</span> <span class="id">rs</span>' <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">rs</span>'##<span class="id">rl</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">pr</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>'.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transl_condexpr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le</span>: <span class="id">letenv</span>) (<span class="id">a</span>: <span class="id">condexpr</span>) (<span class="id">v</span>: <span class="id">bool</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">map</span> <span class="id">pr</span> <span class="id">ns</span> <span class="id">ntrue</span> <span class="id">nfalse</span> <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TE</span>: <span class="id">tr_condition</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">pr</span> <span class="id">a</span> <span class="id">ns</span> <span class="id">ntrue</span> <span class="id">nfalse</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">tm</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> (<span class="kwd">if</span> <span class="id">v</span> <span class="kwd">then</span> <span class="id">ntrue</span> <span class="kwd">else</span> <span class="id">nfalse</span>) <span class="id">rs</span>' <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">pr</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>'.<br/>
<br/>
<div class="doc">The correctness of the translation is a huge induction over
  the CminorSel evaluation derivation for the source program.  To keep
  the proof manageable, we put each case of the proof in a separate
  lemma.  There is one lemma for each CminorSel evaluation rule.
  It takes as hypotheses the premises of the CminorSel evaluation rule,
  plus the induction hypotheses, that is, the <span class="bracket"><span class="id">transl_expr_prop</span></span>, etc,
  corresponding to the evaluations of sub-expressions or sub-statements. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Evar_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">id</span> : <span class="id">positive</span>) (<span class="id">v</span>: <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">e</span> ! <span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Evar</span> <span class="id">id</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2532')">Proof.</div>
<div class="proofscript" id="proof2532">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_env_find_var</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">tr_move_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>'; <span class="id">exists</span> <span class="id">tm</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [[<span class="id">D</span> <span class="id">E</span>] | [<span class="id">D</span> <span class="id">E</span>]].<br/>
&nbsp;optimized&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">r</span> <span class="id">dst</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">Reg.eq</span> <span class="id">r</span> <span class="id">rd</span>). <span class="tactic">subst</span> <span class="id">r</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">match_env_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;general&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_invariant</span> <span class="kwd">with</span> (<span class="id">rs</span>#<span class="id">rd</span> &lt;- (<span class="id">rs</span>#<span class="id">r</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_update_dest</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">rd</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">C</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Eop_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">op</span> : <span class="id">operation</span>) (<span class="id">args</span> : <span class="id">exprlist</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vargs</span> : <span class="id">list</span> <span class="id">val</span>) (<span class="id">v</span> : <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">args</span> <span class="id">vargs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">args</span> <span class="id">vargs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">op</span> <span class="id">vargs</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Eop</span> <span class="id">op</span> <span class="id">args</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2533')">Proof.</div>
<div class="proofscript" id="proof2533">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;normal&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RR1</span> [<span class="id">RO1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">eval_operation_lessdef</span> <span class="kwd">as</span> [<span class="id">v</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs1</span>#<span class="id">rd</span> &lt;- <span class="id">v</span>'); <span class="id">exists</span> <span class="id">tm1</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_right</span>. <span class="id">eexact</span> <span class="id">EX1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (@<span class="id">eval_operation_preserved</span> <span class="id">CminorSel.fundef</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ge</span> <span class="id">tge</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;Result&nbsp;reg&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Eload_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">chunk</span> : <span class="id">memory_chunk</span>) (<span class="id">addr</span> : <span class="id">Op.addressing</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">args</span> : <span class="id">exprlist</span>) (<span class="id">vargs</span> : <span class="id">list</span> <span class="id">val</span>) (<span class="id">vaddr</span> <span class="id">v</span> : <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">args</span> <span class="id">vargs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">args</span> <span class="id">vargs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Op.eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">vargs</span> = <span class="id">Some</span> <span class="id">vaddr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.loadv</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">vaddr</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Eload</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2534')">Proof.</div>
<div class="proofscript" id="proof2534">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RES1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">eval_addressing_lessdef</span> <span class="kwd">as</span> [<span class="id">vaddr</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.loadv_extends</span> <span class="kwd">as</span> [<span class="id">v</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs1</span>#<span class="id">rd</span> &lt;- <span class="id">v</span>'); <span class="id">exists</span> <span class="id">tm1</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_right</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="tactic">eapply</span> <span class="id">exec_Iload</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">vaddr</span>'). <span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;Result&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Econdition_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">a</span>: <span class="id">condexpr</span>) (<span class="id">ifso</span> <span class="id">ifnot</span> : <span class="id">expr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">va</span> : <span class="id">bool</span>) (<span class="id">v</span> : <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">eval_condexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">ifso</span> <span class="kwd">else</span> <span class="id">ifnot</span>) <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">ifso</span> <span class="kwd">else</span> <span class="id">ifnot</span>) <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Econdition</span> <span class="id">a</span> <span class="id">ifso</span> <span class="id">ifnot</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2535')">Proof.</div>
<div class="proofscript" id="proof2535">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tr_expr</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">pr</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">ifso</span> <span class="kwd">else</span> <span class="id">ifnot</span>) (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">ntrue</span> <span class="kwd">else</span> <span class="id">nfalse</span>) <span class="id">nd</span> <span class="id">rd</span> <span class="id">dst</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">tm2</span> [<span class="id">EX2</span> [<span class="id">ME2</span> [<span class="id">RES2</span> [<span class="id">OTHER2</span> <span class="id">EXT2</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="id">eexact</span> <span class="id">EX2</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Result&nbsp;value&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">rs1</span>#<span class="id">r</span>); <span class="tactic">auto</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Elet_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">a1</span> <span class="id">a2</span> : <span class="id">expr</span>) (<span class="id">v1</span> <span class="id">v2</span> : <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a1</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> <span class="id">a1</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> (<span class="id">v1</span> :: <span class="id">le</span>) <span class="id">a2</span> <span class="id">v2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> (<span class="id">v1</span> :: <span class="id">le</span>) <span class="id">a2</span> <span class="id">v2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Elet</span> <span class="id">a1</span> <span class="id">a2</span>) <span class="id">v2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2536')">Proof.</div>
<div class="proofscript" id="proof2536">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RES1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">map_wf</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_letvar_wf</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_env_bind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">tm2</span> [<span class="id">EX2</span> [<span class="id">ME3</span> [<span class="id">RES2</span> [<span class="id">OTHER2</span> <span class="id">EXT2</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="id">eexact</span> <span class="id">EX2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">match_env_unbind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Result&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">rs1</span>#<span class="id">r0</span>); <span class="tactic">auto</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Eletvar_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">list</span> <span class="id">val</span>) (<span class="id">n</span> : <span class="id">nat</span>) (<span class="id">v</span> : <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">nth_error</span> <span class="id">le</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Eletvar</span> <span class="id">n</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2537')">Proof.</div>
<div class="proofscript" id="proof2537">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">tr_move_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">EX1</span> [<span class="id">RES1</span> <span class="id">OTHER1</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs1</span>; <span class="id">exists</span> <span class="id">tm</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">EX1</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [[<span class="id">A</span> <span class="id">B</span>] | [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">r</span> <span class="id">dst</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_invariant</span> <span class="kwd">with</span> <span class="id">rs</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">Reg.eq</span> <span class="id">r</span> <span class="id">rd</span>). <span class="tactic">subst</span> <span class="id">r</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_invariant</span> <span class="kwd">with</span> (<span class="id">rs</span>#<span class="id">rd</span> &lt;- (<span class="id">rs</span>#<span class="id">r</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_update_dest</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_find_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">rd</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;Result&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">RES1</span>. <span class="tactic">eapply</span> <span class="id">match_env_find_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [[<span class="id">A</span> <span class="id">B</span>] | [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Reg.eq</span> <span class="id">r0</span> <span class="id">rd</span>); <span class="tactic">subst</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">OTHER1</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">eval_builtin_args_trivial</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ge</span>: <span class="id">RTL.genv</span>) (<span class="id">rs</span>: <span class="id">regset</span>) <span class="id">sp</span> <span class="id">m</span> <span class="id">rl</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">List.map</span> (@<span class="id">BA</span> <span class="id">reg</span>) <span class="id">rl</span>) <span class="id">rs</span>##<span class="id">rl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2538')">Proof.</div>
<div class="proofscript" id="proof2538">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>.<br/>
- <span class="id">constructor</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Ebuiltin_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">ef</span> <span class="id">al</span> <span class="id">vl</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">external_call</span> <span class="id">ef</span> <span class="id">ge</span> <span class="id">vl</span> <span class="id">m</span> <span class="id">E0</span> <span class="id">v</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Ebuiltin</span> <span class="id">ef</span> <span class="id">al</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2539')">Proof.</div>
<div class="proofscript" id="proof2539">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RR1</span> [<span class="id">RO1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">tm2</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs1</span>#<span class="id">rd</span> &lt;- <span class="id">v</span>'); <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_right</span>. <span class="id">eexact</span> <span class="id">EX1</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">rs1</span>#<span class="id">rd</span> &lt;- <span class="id">v</span>') <span class="kwd">with</span> (<span class="id">regmap_setres</span> (<span class="id">BR</span> <span class="id">rd</span>) <span class="id">v</span>' <span class="id">rs1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ibuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_trivial</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;Result&nbsp;reg&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_Eexternal_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">id</span> <span class="id">sg</span> <span class="id">al</span> <span class="id">b</span> <span class="id">ef</span> <span class="id">vl</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> (<span class="id">External</span> <span class="id">ef</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">ef_sig</span> <span class="id">ef</span> = <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">external_call</span> <span class="id">ef</span> <span class="id">ge</span> <span class="id">vl</span> <span class="id">m</span> <span class="id">E0</span> <span class="id">v</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> (<span class="id">Eexternal</span> <span class="id">id</span> <span class="id">sg</span> <span class="id">al</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2540')">Proof.</div>
<div class="proofscript" id="proof2540">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RR1</span> [<span class="id">RO1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">tm2</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">P</span> <span class="id">Q</span>]]. <span class="id">inv</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs1</span>#<span class="id">rd</span> &lt;- <span class="id">v</span>'); <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">EX1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="tactic">eapply</span> <span class="id">exec_function_external</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">apply</span> <span class="id">exec_return</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">rtlg</span>.<br/>
&nbsp;Result&nbsp;reg&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_exprlist_Enil_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>),<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">Enil</span> <span class="id">nil</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2541')">Proof.</div>
<div class="proofscript" id="proof2541">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>; <span class="id">exists</span> <span class="id">tm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_exprlist_Econs_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">le</span> : <span class="id">letenv</span>) (<span class="id">a1</span> : <span class="id">expr</span>) (<span class="id">al</span> : <span class="id">exprlist</span>) (<span class="id">v1</span> : <span class="id">val</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">vl</span> : <span class="id">list</span> <span class="id">val</span>),<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a1</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> <span class="id">a1</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> (<span class="id">Econs</span> <span class="id">a1</span> <span class="id">al</span>) (<span class="id">v1</span> :: <span class="id">vl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2542')">Proof.</div>
<div class="proofscript" id="proof2542">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RES1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">tm2</span> [<span class="id">EX2</span> [<span class="id">ME2</span> [<span class="id">RES2</span> [<span class="id">OTHER2</span> <span class="id">EXT2</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="id">eexact</span> <span class="id">EX2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Results&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">OTHER2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">rs1</span>#<span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">OTHER2</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">OTHER1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_condexpr_CEcond_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">cond</span> <span class="id">al</span> <span class="id">vl</span> <span class="id">vb</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_condition</span> <span class="id">cond</span> <span class="id">vl</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> (<span class="id">CEcond</span> <span class="id">cond</span> <span class="id">al</span>) <span class="id">vb</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2543')">Proof.</div>
<div class="proofscript" id="proof2543">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RES1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs1</span>; <span class="id">exists</span> <span class="id">tm1</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="tactic">eapply</span> <span class="id">exec_Icond</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_condition_lessdef</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_condexpr_CEcondition_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_condexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_condexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">b</span> <span class="kwd">else</span> <span class="id">c</span>) <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">b</span> <span class="kwd">else</span> <span class="id">c</span>) <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> (<span class="id">CEcondition</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2544')">Proof.</div>
<div class="proofscript" id="proof2544">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tr_condition</span> (<span class="id">fn_code</span> <span class="id">f</span>) <span class="id">map</span> <span class="id">pr</span> (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">b</span> <span class="kwd">else</span> <span class="id">c</span>) (<span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">n2</span> <span class="kwd">else</span> <span class="id">n3</span>) <span class="id">ntrue</span> <span class="id">nfalse</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">tm2</span> [<span class="id">EX2</span> [<span class="id">ME2</span> [<span class="id">OTHER2</span> <span class="id">EXT2</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_trans</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="id">eexact</span> <span class="id">EX2</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">OTHER2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_condexpr_CElet_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">b</span> <span class="id">v1</span> <span class="id">v2</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_condexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> (<span class="id">v1</span> :: <span class="id">le</span>) <span class="id">b</span> <span class="id">v2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> (<span class="id">v1</span> :: <span class="id">le</span>) <span class="id">b</span> <span class="id">v2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> (<span class="id">CElet</span> <span class="id">a</span> <span class="id">b</span>) <span class="id">v2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2545')">Proof.</div>
<div class="proofscript" id="proof2545">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TE</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">tm1</span> [<span class="id">EX1</span> [<span class="id">ME1</span> [<span class="id">RES1</span> [<span class="id">OTHER1</span> <span class="id">EXT1</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">map_wf</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_letvar_wf</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_env_bind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">tm2</span> [<span class="id">EX2</span> [<span class="id">ME3</span> [<span class="id">OTHER2</span> <span class="id">EXT2</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="id">exists</span> <span class="id">tm2</span>.<br/>
&nbsp;Exec&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_plus_trans</span>. <span class="id">eexact</span> <span class="id">EX1</span>. <span class="id">eexact</span> <span class="id">EX2</span>. <span class="id">traceEq</span>.<br/>
&nbsp;Match-env&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">match_env_unbind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Other&nbsp;regs&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">OTHER2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;Mem&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_expr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">eval_expr_ind3</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Evar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eop_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eload_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Econdition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Elet_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eletvar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Ebuiltin_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eexternal_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Enil_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Econs_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcond_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcondition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CElet_correct</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_exprlist_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">eval_exprlist_ind3</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Evar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eop_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eload_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Econdition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Elet_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eletvar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Ebuiltin_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eexternal_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Enil_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Econs_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcond_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcondition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CElet_correct</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_condexpr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_condexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">v</span>.<br/>
<span class="kwd">Proof</span><br/>
&nbsp;&nbsp;(<span class="id">eval_condexpr_ind3</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Evar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eop_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eload_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Econdition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Elet_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eletvar_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Ebuiltin_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_expr_Eexternal_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Enil_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_exprlist_Econs_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcond_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CEcondition_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_condexpr_CElet_correct</span>).<br/>
<br/>
<div class="doc">Exit expressions. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">transl_exitexpr_prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le</span>: <span class="id">letenv</span>) (<span class="id">a</span>: <span class="id">exitexpr</span>) (<span class="id">x</span>: <span class="id">nat</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">map</span> <span class="id">ns</span> <span class="id">nexits</span> <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TE</span>: <span class="id">tr_exitexpr</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">a</span> <span class="id">ns</span> <span class="id">nexits</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">EXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nd</span>, <span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">tm</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">nd</span> <span class="id">rs</span>' <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">nth_error</span> <span class="id">nexits</span> <span class="id">x</span> = <span class="id">Some</span> <span class="id">nd</span><br/>
&nbsp;&nbsp;/\ <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">le</span> <span class="id">rs</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>'.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_exitexpr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">a</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exitexpr</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> <span class="id">a</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_exitexpr_prop</span> <span class="id">le</span> <span class="id">a</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2546')">Proof.</div>
<div class="proofscript" id="proof2546">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">TE</span>.<br/>
- <span class="comment">(*&nbsp;XEexit&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ns</span>, <span class="id">rs</span>, <span class="id">tm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;XEjumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">nd</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">rs1</span> &amp; <span class="id">tm1</span> &amp; <span class="id">EXEC1</span> &amp; <span class="id">ME1</span> &amp; <span class="id">RES1</span> &amp; <span class="id">PRES1</span> &amp; <span class="id">EXT1</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nd</span>, <span class="id">rs1</span>, <span class="id">tm1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_right</span>. <span class="id">eexact</span> <span class="id">EXEC1</span>. <span class="tactic">eapply</span> <span class="id">exec_Ijumptable</span>; <span class="tactic">eauto</span>. <span class="id">inv</span> <span class="id">RES1</span>; <span class="tactic">auto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;XEcondition&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_condexpr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">rs1</span> &amp; <span class="id">tm1</span> &amp; <span class="id">EXEC1</span> &amp; <span class="id">ME1</span> &amp; <span class="id">RES1</span> &amp; <span class="id">EXT1</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_exitexpr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (2 := <span class="kwd">if</span> <span class="id">va</span> <span class="kwd">then</span> <span class="id">n2</span> <span class="kwd">else</span> <span class="id">n3</span>). <span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">nd</span> &amp; <span class="id">rs2</span> &amp; <span class="id">tm2</span> &amp; <span class="id">EXEC2</span> &amp; <span class="id">EXIT2</span> &amp; <span class="id">ME2</span> &amp; <span class="id">EXT2</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nd</span>, <span class="id">rs2</span>, <span class="id">tm2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>. <span class="id">eexact</span> <span class="id">EXEC1</span>. <span class="id">eexact</span> <span class="id">EXEC2</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;XElet&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">rs1</span> &amp; <span class="id">tm1</span> &amp; <span class="id">EXEC1</span> &amp; <span class="id">ME1</span> &amp; <span class="id">RES1</span> &amp; <span class="id">PRES1</span> &amp; <span class="id">EXT1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">map_wf</span> (<span class="id">add_letvar</span> <span class="id">map</span> <span class="id">r</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_letvar_wf</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_exitexpr</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_env_bind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">nd</span> &amp; <span class="id">rs2</span> &amp; <span class="id">tm2</span> &amp; <span class="id">EXEC2</span> &amp; <span class="id">EXIT2</span> &amp; <span class="id">ME2</span> &amp; <span class="id">EXT2</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">nd</span>, <span class="id">rs2</span>, <span class="id">tm2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">EXEC1</span>. <span class="id">eexact</span> <span class="id">EXEC2</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">match_env_unbind_letvar</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Builtin arguments. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_exprlist_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">le</span> <span class="id">al1</span> <span class="id">vl1</span> <span class="id">al2</span> <span class="id">vl2</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> (<span class="id">exprlist_of_expr_list</span> <span class="id">al1</span>) <span class="id">vl1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> (<span class="id">exprlist_of_expr_list</span> <span class="id">al2</span>) <span class="id">vl2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">le</span> (<span class="id">exprlist_of_expr_list</span> (<span class="id">al1</span> ++ <span class="id">al2</span>)) (<span class="id">vl1</span> ++ <span class="id">vl2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2547')">Proof.</div>
<div class="proofscript" id="proof2547">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">al1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">vl1</span> <span class="id">al2</span> <span class="id">vl2</span> <span class="id">E1</span> <span class="id">E2</span>; <span class="id">inv</span> <span class="id">E1</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">simpl</span>. <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">invert_eval_builtin_arg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">nil</span> (<span class="id">exprlist_of_expr_list</span> (<span class="id">params_of_builtin_arg</span> <span class="id">a</span>)) <span class="id">vl</span><br/>
&nbsp;&nbsp;/\ <span class="id">Events.eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">v</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">fst</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">vl</span>)) <span class="id">v</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">vl</span>', <span class="id">convert_builtin_arg</span> <span class="id">a</span> (<span class="id">vl</span> ++ <span class="id">vl</span>') = (<span class="id">fst</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">vl</span>), <span class="id">vl</span>')).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2548')">Proof.</div>
<div class="proofscript" id="proof2548">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">intuition</span> <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">evalexpr</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">invert_eval_builtin_args</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">eval_builtin_arg</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>) <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">nil</span> (<span class="id">exprlist_of_expr_list</span> (<span class="id">params_of_builtin_args</span> <span class="id">al</span>)) <span class="id">vl</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Events.eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">v</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">convert_builtin_args</span> <span class="id">al</span> <span class="id">vl</span>') <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2549')">Proof.</div>
<div class="proofscript" id="proof2549">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>.<br/>
- <span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>; <span class="id">constructor</span>.<br/>
- <span class="id">exploit</span> <span class="id">invert_eval_builtin_arg</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">vl1</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHlist_forall2</span> <span class="kwd">as</span> (<span class="id">vl2</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">vl1</span> ++ <span class="id">vl2</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_exprlist_append</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">simpl</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_eval_builtin_arg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs</span> <span class="id">a</span> <span class="id">vl</span> <span class="id">rl</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">rs</span>##<span class="id">rl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Events.eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">v</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">fst</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">vl</span>)) <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Events.eval_builtin_arg</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">fst</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">rl</span>)) <span class="id">v</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">v</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.lessdef_list</span> (<span class="id">snd</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">vl</span>)) <span class="id">rs</span>##(<span class="id">snd</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">rl</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2550')">Proof.</div>
<div class="proofscript" id="proof2550">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">v</span>; <span class="tactic">intros</span> <span class="id">LD</span> <span class="id">EV</span>;<br/>
&nbsp;&nbsp;<span class="tactic">try</span> (<span class="id">now</span> (<span class="id">inv</span> <span class="id">EV</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>)).<br/>
- <span class="tactic">destruct</span> <span class="id">rl</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">EV</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">rs</span>#<span class="id">p</span>); <span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a1</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">a1</span>' <span class="id">vl1</span>] <span class="id">eqn</span>:<span class="id">CV1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a2</span> <span class="id">vl1</span>) <span class="kwd">as</span> [<span class="id">a2</span>' <span class="id">vl2</span>] <span class="id">eqn</span>:<span class="id">CV2</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a1</span> <span class="id">rl</span>) <span class="kwd">as</span> [<span class="id">a1</span>'' <span class="id">rl1</span>] <span class="id">eqn</span>:<span class="id">CV3</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a2</span> <span class="id">rl1</span>) <span class="kwd">as</span> [<span class="id">a2</span>'' <span class="id">rl2</span>] <span class="id">eqn</span>:<span class="id">CV4</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">EV</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHa1</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">CV1</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CV1</span>, <span class="id">CV3</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> (<span class="id">v1</span>' &amp; <span class="id">A1</span> &amp; <span class="id">B1</span> &amp; <span class="id">C1</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHa2</span>. <span class="id">eexact</span> <span class="id">C1</span>. <span class="tactic">rewrite</span> <span class="id">CV2</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CV2</span>, <span class="id">CV4</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> (<span class="id">v2</span>' &amp; <span class="id">A2</span> &amp; <span class="id">B2</span> &amp; <span class="id">C2</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Val.longofwords</span> <span class="id">v1</span>' <span class="id">v2</span>'); <span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Val.longofwords_lessdef</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_eval_builtin_args</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs</span> <span class="id">al</span> <span class="id">vl1</span> <span class="id">rl</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vl1</span> <span class="id">rs</span>##<span class="id">rl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Events.eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">v</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">convert_builtin_args</span> <span class="id">al</span> <span class="id">vl1</span>) <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Events.eval_builtin_args</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) <span class="id">sp</span> <span class="id">m</span> (<span class="id">convert_builtin_args</span> <span class="id">al</span> <span class="id">rl</span>) <span class="id">vl</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">vl</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2551')">Proof.</div>
<div class="proofscript" id="proof2551">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">al</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">vl</span>; <span class="tactic">intros</span> <span class="id">LD</span> <span class="id">EV</span>.<br/>
- <span class="id">inv</span> <span class="id">EV</span>. <span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>; <span class="id">constructor</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">vl1</span>) <span class="kwd">as</span> [<span class="id">a1</span>' <span class="id">vl2</span>] <span class="id">eqn</span>:<span class="id">CV1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">EV</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_eval_builtin_arg</span>. <span class="tactic">eauto</span>. <span class="id">instantiate</span> (2 := <span class="id">a</span>). <span class="tactic">rewrite</span> <span class="id">CV1</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CV1</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> (<span class="id">v1</span>' &amp; <span class="id">A1</span> &amp; <span class="id">B1</span> &amp; <span class="id">C1</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHal</span>. <span class="id">eexact</span> <span class="id">C1</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">vl</span>' &amp; <span class="id">A2</span> &amp; <span class="id">B2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">convert_builtin_arg</span> <span class="id">a</span> <span class="id">rl</span>) <span class="kwd">as</span> [<span class="id">a1</span>'' <span class="id">rl2</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">v1</span>' :: <span class="id">vl</span>'); <span class="tactic">split</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">CORRECTNESS_EXPR</span>.<br/>
<br/>
<h2> Measure over CminorSel states </h2>
<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">nat_scope</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">size_stmt</span> (<span class="id">s</span>: <span class="id">stmt</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Sskip</span> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id">Sseq</span> <span class="id">s1</span> <span class="id">s2</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s1</span> + <span class="id">size_stmt</span> <span class="id">s2</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">Sifthenelse</span> <span class="id">c</span> <span class="id">s1</span> <span class="id">s2</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s1</span> + <span class="id">size_stmt</span> <span class="id">s2</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">Sloop</span> <span class="id">s1</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s1</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">Sblock</span> <span class="id">s1</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s1</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">Sexit</span> <span class="id">n</span> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id">Slabel</span> <span class="id">lbl</span> <span class="id">s1</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s1</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; 1<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">size_cont</span> (<span class="id">k</span>: <span class="id">cont</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Kseq</span> <span class="id">s</span> <span class="id">k1</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s</span> + <span class="id">size_cont</span> <span class="id">k1</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">Kblock</span> <span class="id">k1</span> =&gt; (<span class="id">size_cont</span> <span class="id">k1</span> + 1)<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">measure_state</span> (<span class="id">S</span>: <span class="id">CminorSel.state</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">S</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CminorSel.State</span> <span class="id">_</span> <span class="id">s</span> <span class="id">k</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; (<span class="id">size_stmt</span> <span class="id">s</span> + <span class="id">size_cont</span> <span class="id">k</span>, <span class="id">size_stmt</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;| <span class="id">_</span>                           =&gt; (0, 0)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">lt_state</span> (<span class="id">S1</span> <span class="id">S2</span>: <span class="id">CminorSel.state</span>) :=<br/>
&nbsp;&nbsp;<span class="id">lex_ord</span> <span class="id">lt</span> <span class="id">lt</span> (<span class="id">measure_state</span> <span class="id">S1</span>) (<span class="id">measure_state</span> <span class="id">S2</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">lt_state_intro</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">s1</span> <span class="id">k1</span> <span class="id">sp1</span> <span class="id">e1</span> <span class="id">m1</span> <span class="id">f2</span> <span class="id">s2</span> <span class="id">k2</span> <span class="id">sp2</span> <span class="id">e2</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">size_stmt</span> <span class="id">s1</span> + <span class="id">size_cont</span> <span class="id">k1</span> &lt; <span class="id">size_stmt</span> <span class="id">s2</span> + <span class="id">size_cont</span> <span class="id">k2</span><br/>
&nbsp;&nbsp;\/ (<span class="id">size_stmt</span> <span class="id">s1</span> + <span class="id">size_cont</span> <span class="id">k1</span> = <span class="id">size_stmt</span> <span class="id">s2</span> + <span class="id">size_cont</span> <span class="id">k2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">size_stmt</span> <span class="id">s1</span> &lt; <span class="id">size_stmt</span> <span class="id">s2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">lt_state</span> (<span class="id">CminorSel.State</span> <span class="id">f1</span> <span class="id">s1</span> <span class="id">k1</span> <span class="id">sp1</span> <span class="id">e1</span> <span class="id">m1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">CminorSel.State</span> <span class="id">f2</span> <span class="id">s2</span> <span class="id">k2</span> <span class="id">sp2</span> <span class="id">e2</span> <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2552')">Proof.</div>
<div class="proofscript" id="proof2552">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">lt_state</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">right</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Ltac</span> <span class="id">Lt_state</span> :=<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">lt_state_intro</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Wellfounded</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">lt_state_wf</span>:<br/>
&nbsp;&nbsp;<span class="id">well_founded</span> <span class="id">lt_state</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2553')">Proof.</div>
<div class="proofscript" id="proof2553">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">lt_state</span>. <span class="tactic">apply</span> <span class="id">wf_inverse_image</span> <span class="kwd">with</span> (<span class="id">f</span> := <span class="id">measure_state</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wf_lex_ord</span>. <span class="tactic">apply</span> <span class="id">lt_wf</span>. <span class="tactic">apply</span> <span class="id">lt_wf</span>.<br/>
Qed.</div>
<br/>
<h2> Semantic preservation for the translation of statements </h2>
<br/>
<div class="doc">The simulation diagram for the translation of statements
  and functions is a "star" diagram of the form:
<pre>
           I                         I
     S1 ------- R1             S1 ------- R1
     |          |              |          |
   t |        + | t      or  t |        * | t    and |S2| &lt; |S1|
     v          v              v          |
     S2 ------- R2             S2 ------- R2
           I                         I</pre>
  where <span class="bracket"><span class="id">I</span></span> is the <span class="bracket"><span class="id">match_states</span></span> predicate defined below.  It includes:
<ul>
<li>
 Agreement between the Cminor statement under consideration and
  the current program point in the RTL control-flow graph,
  as captured by the <span class="bracket"><span class="id">tr_stmt</span></span> predicate.
</li>
<li>
 Agreement between the Cminor continuation and the RTL control-flow
  graph and call stack, as captured by the <span class="bracket"><span class="id">tr_cont</span></span> predicate below.
</li>
<li>
 Agreement between Cminor environments and RTL register environments,
  as captured by <span class="bracket"><span class="id">match_envs</span></span>.
</li>
</ul>
</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">tr_fun</span> (<span class="id">tf</span>: <span class="id">function</span>) (<span class="id">map</span>: <span class="id">mapping</span>) (<span class="id">f</span>: <span class="id">CminorSel.function</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ngoto</span>: <span class="id">labelmap</span>) (<span class="id">nret</span>: <span class="id">node</span>) (<span class="id">rret</span>: <span class="id">option</span> <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">tr_fun_intro</span>: <span class="kwd">forall</span> <span class="id">nentry</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rret</span> = <span class="id">ret_reg</span> <span class="id">f</span>.(<span class="id">CminorSel.fn_sig</span>) <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_stmt</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">f</span>.(<span class="id">fn_body</span>) <span class="id">nentry</span> <span class="id">nret</span> <span class="id">nil</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tf</span>.(<span class="id">fn_stacksize</span>) = <span class="id">f</span>.(<span class="id">fn_stackspace</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_fun</span> <span class="id">tf</span> <span class="id">map</span> <span class="id">f</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">tr_cont</span>: <span class="id">RTL.code</span> -&gt; <span class="id">mapping</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">CminorSel.cont</span> -&gt; <span class="id">node</span> -&gt; <span class="id">list</span> <span class="id">node</span> -&gt; <span class="id">labelmap</span> -&gt; <span class="id">node</span> -&gt; <span class="id">option</span> <span class="id">reg</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list</span> <span class="id">RTL.stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">tr_Kseq</span>: <span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">s</span> <span class="id">k</span> <span class="id">nd</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_stmt</span> <span class="id">c</span> <span class="id">map</span> <span class="id">s</span> <span class="id">nd</span> <span class="id">n</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">n</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> (<span class="id">Kseq</span> <span class="id">s</span> <span class="id">k</span>) <span class="id">nd</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">tr_Kblock</span>: <span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">nd</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">nd</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> (<span class="id">Kblock</span> <span class="id">k</span>) <span class="id">nd</span> (<span class="id">nd</span> :: <span class="id">nexits</span>) <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">tr_Kstop</span>: <span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">c</span>!<span class="id">nret</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">rret</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">Kstop</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">Kstop</span> <span class="id">nret</span> <span class="id">nil</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">tr_Kcall</span>: <span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">optid</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">k</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">c</span>!<span class="id">nret</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">rret</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> (<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">k</span>) <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> (<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">k</span>) <span class="id">nret</span> <span class="id">nil</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span><br/>
<br/>
<span class="kwd">with</span> <span class="id">match_stacks</span>: <span class="id">CminorSel.cont</span> -&gt; <span class="id">list</span> <span class="id">RTL.stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stacks_stop</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">Kstop</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">match_stacks_call</span>: <span class="kwd">forall</span> <span class="id">optid</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">k</span> <span class="id">r</span> <span class="id">tf</span> <span class="id">n</span> <span class="id">rs</span> <span class="id">cs</span> <span class="id">map</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">map_wf</span> <span class="id">map</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_fun</span> <span class="id">tf</span> <span class="id">map</span> <span class="id">f</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">nil</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reg_map_ok</span> <span class="id">map</span> <span class="id">r</span> <span class="id">optid</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">k</span> <span class="id">n</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> (<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">k</span>) (<span class="id">Stackframe</span> <span class="id">r</span> <span class="id">tf</span> <span class="id">sp</span> <span class="id">n</span> <span class="id">rs</span> :: <span class="id">cs</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">CminorSel.state</span> -&gt; <span class="id">RTL.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">tf</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">map</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TS</span>: <span class="id">tr_stmt</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">s</span> <span class="id">ns</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TF</span>: <span class="id">tr_fun</span> <span class="id">tf</span> <span class="id">map</span> <span class="id">f</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TK</span>: <span class="id">tr_cont</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) <span class="id">map</span> <span class="id">k</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map</span> <span class="id">e</span> <span class="id">nil</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">CminorSel.State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RTL.State</span> <span class="id">cs</span> <span class="id">tf</span> <span class="id">sp</span> <span class="id">ns</span> <span class="id">rs</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_callstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">args</span> <span class="id">targs</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">tf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TF</span>: <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MS</span>: <span class="id">match_stacks</span> <span class="id">k</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LD</span>: <span class="id">Val.lessdef_list</span> <span class="id">args</span> <span class="id">targs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">CminorSel.Callstate</span> <span class="id">f</span> <span class="id">args</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RTL.Callstate</span> <span class="id">cs</span> <span class="id">tf</span> <span class="id">targs</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_returnstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">tv</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MS</span>: <span class="id">match_stacks</span> <span class="id">k</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LD</span>: <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">tv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">tm</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">CminorSel.Returnstate</span> <span class="id">v</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RTL.Returnstate</span> <span class="id">cs</span> <span class="id">tv</span> <span class="id">tm</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> (<span class="id">call_cont</span> <span class="id">k</span>) <span class="id">cs</span> /\ <span class="id">c</span>!<span class="id">nret</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">rret</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2554')">Proof.</div>
<div class="proofscript" id="proof2554">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tr_cont_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">ncont</span> <span class="id">nexits</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> (<span class="id">call_cont</span> <span class="id">k</span>) <span class="id">nret</span> <span class="id">nil</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2555')">Proof.</div>
<div class="proofscript" id="proof2555">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tr_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">c</span> <span class="id">map</span> <span class="id">lbl</span> <span class="id">n</span> (<span class="id">ngoto</span>: <span class="id">labelmap</span>) <span class="id">nret</span> <span class="id">rret</span> <span class="id">s</span>' <span class="id">k</span>' <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">ngoto</span>!<span class="id">lbl</span> = <span class="id">Some</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">ns1</span> <span class="id">nd1</span> <span class="id">nexits1</span>,<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span> = <span class="id">Some</span> (<span class="id">s</span>', <span class="id">k</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">tr_stmt</span> <span class="id">c</span> <span class="id">map</span> <span class="id">s</span> <span class="id">ns1</span> <span class="id">nd1</span> <span class="id">nexits1</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span> <span class="id">nd1</span> <span class="id">nexits1</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ns2</span>, <span class="id">exists</span> <span class="id">nd2</span>, <span class="id">exists</span> <span class="id">nexits2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">c</span>!<span class="id">n</span> = <span class="id">Some</span>(<span class="id">Inop</span> <span class="id">ns2</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">tr_stmt</span> <span class="id">c</span> <span class="id">map</span> <span class="id">s</span>' <span class="id">ns2</span> <span class="id">nd2</span> <span class="id">nexits2</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span><br/>
&nbsp;&nbsp;/\ <span class="id">tr_cont</span> <span class="id">c</span> <span class="id">map</span> <span class="id">k</span>' <span class="id">nd2</span> <span class="id">nexits2</span> <span class="id">ngoto</span> <span class="id">nret</span> <span class="id">rret</span> <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2556')">Proof.</div>
<div class="proofscript" id="proof2556">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">s</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">nexits1</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s1</span> (<span class="id">Kseq</span> <span class="id">s2</span> <span class="id">k</span>)); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">IHs1</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">IHs2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s1</span> <span class="id">k</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">IHs1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">IHs2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H1</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHs</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHs</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">lbl</span> <span class="id">l</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n0</span> = <span class="id">n</span>). <span class="id">change</span> <span class="id">positive</span> <span class="kwd">with</span> <span class="id">node</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">n0</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ns1</span>; <span class="id">exists</span> <span class="id">nd1</span>; <span class="id">exists</span> <span class="id">nexits1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">eapply</span> <span class="id">IHs</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">CminorSel.step</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">R1</span>, <span class="id">match_states</span> <span class="id">S1</span> <span class="id">R1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">R2</span>,<br/>
&nbsp;&nbsp;(<span class="id">plus</span> <span class="id">RTL.step</span> <span class="id">tge</span> <span class="id">R1</span> <span class="id">t</span> <span class="id">R2</span> \/ (<span class="id">star</span> <span class="id">RTL.step</span> <span class="id">tge</span> <span class="id">R1</span> <span class="id">t</span> <span class="id">R2</span> /\ <span class="id">lt_state</span> <span class="id">S2</span> <span class="id">S1</span>))<br/>
&nbsp;&nbsp;/\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">R2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2557')">Proof.</div>
<div class="proofscript" id="proof2557">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">R1</span> <span class="id">MSTATE</span>; <span class="id">inv</span> <span class="id">MSTATE</span>.<br/>
<br/>
&nbsp;skip&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="id">inv</span> <span class="id">TK</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;skip&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="id">inv</span> <span class="id">TK</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
&nbsp;skip&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">fn_code</span> <span class="id">tf</span>)!<span class="id">ncont</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">rret</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_stacks</span> <span class="id">k</span> <span class="id">cs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TK</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">fn_stacksize</span> <span class="id">tf</span> = <span class="id">fn_stackspace</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TF</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Ireturn</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;assign&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
&nbsp;store&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>'' [<span class="id">tm</span>'' [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> [<span class="id">K</span> <span class="id">L</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">rs</span>''##<span class="id">rl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">rs</span>'' ## <span class="id">rl</span>) <span class="kwd">with</span> (<span class="id">rs</span>' ## <span class="id">rl</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_map_exten</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">K</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">eval_addressing_lessdef</span> <span class="kwd">as</span> [<span class="id">vaddr</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.storev_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>''' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="id">eexact</span> <span class="id">F</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Istore</span> <span class="kwd">with</span> (<span class="id">a</span> := <span class="id">vaddr</span>'). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;indirect&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">X</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>'' [<span class="id">tm</span>'' [<span class="id">E</span> [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> <span class="id">Y</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="id">eexact</span> <span class="id">E</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">J</span>. <span class="tactic">destruct</span> <span class="id">C</span>. <span class="tactic">eauto</span>. <span class="tactic">discriminate</span> <span class="id">P</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_transl_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;direct&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>'' [<span class="id">tm</span>'' [<span class="id">E</span> [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> <span class="id">Y</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_find_funct_ptr</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_transl_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;tailcall&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;indirect&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">X</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>'' [<span class="id">tm</span>'' [<span class="id">E</span> [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> <span class="id">Y</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_stacks_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">fn_stacksize</span> <span class="id">tf</span> = <span class="id">fn_stackspace</span> <span class="id">f</span>). <span class="id">inv</span> <span class="id">TF</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>''' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="id">eexact</span> <span class="id">E</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">J</span>. <span class="tactic">destruct</span> <span class="id">C</span>. <span class="tactic">eauto</span>. <span class="tactic">discriminate</span> <span class="id">P</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_transl_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;direct&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>'' [<span class="id">tm</span>'' [<span class="id">E</span> [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> <span class="id">Y</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_stacks_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">fn_stacksize</span> <span class="id">tf</span> = <span class="id">fn_stackspace</span> <span class="id">f</span>). <span class="id">inv</span> <span class="id">TF</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>''' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_find_funct_ptr</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_transl_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;builtin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">invert_eval_builtin_args</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">vparams</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">E</span> [<span class="id">F</span> [<span class="id">G</span> [<span class="id">J</span> <span class="id">K</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_eval_builtin_args</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">vargs</span>' &amp; <span class="id">U</span> &amp; <span class="id">V</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">eval_builtin_args_lessdef</span> <span class="id">_</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>) (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">vargs</span>'' &amp; <span class="id">X</span> &amp; <span class="id">Y</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Z</span>: <span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">vargs</span>'') <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Val.lessdef_list_trans</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">external_call_mem_extends</span> <span class="kwd">as</span> [<span class="id">tv</span> [<span class="id">tm</span>'' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ibuiltin</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_update_res</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_condexpr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">TS</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Inop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;exit&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="id">inv</span> <span class="id">TK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;exit&nbsp;block&nbsp;0&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="id">inv</span> <span class="id">TK</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;exit&nbsp;block&nbsp;n+1&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="id">inv</span> <span class="id">TK</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exitexpr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">nd</span> &amp; <span class="id">rs</span>' &amp; <span class="id">tm</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;return&nbsp;none&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_stacks_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">TF</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Ireturn</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;return&nbsp;some&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_stacks_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">TF</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.free_parallel_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>'' []]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">eapply</span> <span class="id">exec_Ireturn</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="id">Lt_state</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;goto&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TS</span>. <span class="tactic">inversion</span> <span class="id">TF</span>; <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">tr_find_label</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">tr_cont_call_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ns2</span> [<span class="id">nd2</span> [<span class="id">nexits2</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Inop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;internal&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TF</span>. <span class="id">exploit</span> <span class="id">transl_function_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">TRF</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">TRF</span>. <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span> (<span class="id">e</span> := <span class="id">set_locals</span> (<span class="id">fn_vars</span> <span class="id">f</span>) (<span class="id">set_params</span> <span class="id">vargs</span> (<span class="id">CminorSel.fn_params</span> <span class="id">f</span>))).<br/>
&nbsp;&nbsp;<span class="id">pose</span> (<span class="id">rs</span> := <span class="id">init_regs</span> <span class="id">targs</span> <span class="id">rparams</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ME</span>: <span class="id">match_env</span> <span class="id">map2</span> <span class="id">e</span> <span class="id">nil</span> <span class="id">rs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rs</span>, <span class="id">e</span>. <span class="tactic">eapply</span> <span class="id">match_init_env_init_reg</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MWF</span>: <span class="id">map_wf</span> <span class="id">map2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">map_valid</span> <span class="id">init_mapping</span> <span class="id">s0</span>) <span class="tactic">by</span> <span class="tactic">apply</span> <span class="id">init_mapping_valid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">add_vars_valid</span> (<span class="id">CminorSel.fn_params</span> <span class="id">f</span>)); <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_vars_wf</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">add_vars_wf</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">init_mapping_wf</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.alloc_extends</span> <span class="kwd">as</span> [<span class="id">tm</span>' []]; <span class="tactic">eauto</span>; <span class="tactic">try</span> <span class="tactic">apply</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">MS</span>; <span class="tactic">subst</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;external&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TF</span>.<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">external_call_mem_extends</span> <span class="kwd">as</span> [<span class="id">tvres</span> [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]]; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MS</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">apply</span> <span class="id">plus_one</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_update_dest</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span>, <span class="id">CminorSel.initial_state</span> <span class="id">prog</span> <span class="id">S</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">R</span>, <span class="id">RTL.initial_state</span> <span class="id">tprog</span> <span class="id">R</span> /\ <span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2558')">Proof.</div>
<div class="proofscript" id="proof2558">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">apply</span> (<span class="id">Genv.init_mem_transf_partial</span> <span class="id">TRANSL</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="kwd">with</span> (<span class="id">prog_main</span> <span class="id">prog</span>). <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">match_program_main</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">sig_transl_function</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">Mem.extends_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span> <span class="id">R</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span> -&gt; <span class="id">CminorSel.final_state</span> <span class="id">S</span> <span class="id">r</span> -&gt; <span class="id">RTL.final_state</span> <span class="id">R</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2559')">Proof.</div>
<div class="proofscript" id="proof2559">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">MS</span>. <span class="id">inv</span> <span class="id">LD</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">CminorSel.semantics</span> <span class="id">prog</span>) (<span class="id">RTL.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2560')">Proof.</div>
<div class="proofscript" id="proof2560">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_star_wf</span> <span class="kwd">with</span> (<span class="id">order</span> := <span class="id">lt_state</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_final_states</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">lt_state_wf</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">transl_step_correct</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">CORRECTNESS</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
