<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Tunnelingproof</title>
<meta name="description" content="Documentation of Coq module Tunnelingproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Tunnelingproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for the branch tunneling optimization. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">UnionFind</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Locations</span> <span class="id">LTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Tunneling</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span> <span class="id">tp</span>: <span class="id">program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">ctx</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">tf</span> = <span class="id">tunnel_fundef</span> <span class="id">f</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span>, <span class="id">match_prog</span> <span class="id">p</span> (<span class="id">tunnel_program</span> <span class="id">p</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3555')">Proof.</div>
<div class="proofscript" id="proof3555">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_transform_program</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Properties of the branch map computed using union-find. </h1>
<br/>
<div class="doc">A variant of <span class="bracket"><span class="id">record_goto</span></span> that also incrementally computes a measure <span class="bracket"><span class="id">f</span>: <span class="id">node</span> -&gt; <span class="id">nat</span></span>
  counting the number of <span class="bracket"><span class="id">Lnop</span></span> instructions starting at a given <span class="bracket"><span class="id">pc</span></span> that were eliminated. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">measure_edge</span> (<span class="id">u</span>: <span class="id">U.t</span>) (<span class="id">pc</span> <span class="id">s</span>: <span class="id">node</span>) (<span class="id">f</span>: <span class="id">node</span> -&gt; <span class="id">nat</span>) : <span class="id">node</span> -&gt; <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">x</span> =&gt; <span class="kwd">if</span> <span class="id">peq</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">s</span>) <span class="id">pc</span> <span class="kwd">then</span> <span class="id">f</span> <span class="id">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="kwd">if</span> <span class="id">peq</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">x</span>) <span class="id">pc</span> <span class="kwd">then</span> (<span class="id">f</span> <span class="id">x</span> + <span class="id">f</span> <span class="id">s</span> + 1)%<span class="id">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">f</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">record_goto</span>' (<span class="id">uf</span>: <span class="id">U.t</span> * (<span class="id">node</span> -&gt; <span class="id">nat</span>)) (<span class="id">pc</span>: <span class="id">node</span>) (<span class="id">b</span>: <span class="id">bblock</span>) : <span class="id">U.t</span> * (<span class="id">node</span> -&gt; <span class="id">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">b</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Lbranch</span> <span class="id">s</span> :: <span class="id">b</span>' =&gt; <span class="kwd">let</span> (<span class="id">u</span>, <span class="id">f</span>) := <span class="id">uf</span> <span class="kwd">in</span> (<span class="id">U.union</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span>, <span class="id">measure_edge</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">uf</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">branch_map_correct</span> (<span class="id">c</span>: <span class="id">code</span>) (<span class="id">uf</span>: <span class="id">U.t</span> * (<span class="id">node</span> -&gt; <span class="id">nat</span>)): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">pc</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span>!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Lbranch</span> <span class="id">s</span> :: <span class="id">b</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U.repr</span> (<span class="id">fst</span> <span class="id">uf</span>) <span class="id">pc</span> = <span class="id">pc</span> \/ (<span class="id">U.repr</span> (<span class="id">fst</span> <span class="id">uf</span>) <span class="id">pc</span> = <span class="id">U.repr</span> (<span class="id">fst</span> <span class="id">uf</span>) <span class="id">s</span> /\ <span class="id">snd</span> <span class="id">uf</span> <span class="id">s</span> &lt; <span class="id">snd</span> <span class="id">uf</span> <span class="id">pc</span>)%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">U.repr</span> (<span class="id">fst</span> <span class="id">uf</span>) <span class="id">pc</span> = <span class="id">pc</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">record_gotos</span>'<span class="id">_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">branch_map_correct</span> <span class="id">c</span> (<span class="id">PTree.fold</span> <span class="id">record_goto</span>' <span class="id">c</span> (<span class="id">U.empty</span>, <span class="kwd">fun</span> (<span class="id">x</span>: <span class="id">node</span>) =&gt; <span class="id">O</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3556')">Proof.</div>
<div class="proofscript" id="proof3556">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree_Properties.fold_rec</span> <span class="kwd">with</span> (<span class="id">P</span> := <span class="kwd">fun</span> <span class="id">c</span> <span class="id">uf</span> =&gt; <span class="id">branch_map_correct</span> <span class="id">c</span> <span class="id">uf</span>).<br/>
<br/>
&nbsp;extensionality&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">H0</span>.<br/>
<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">apply</span> <span class="id">U.repr_empty</span>.<br/>
<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">m</span> <span class="id">uf</span> <span class="id">pc</span> <span class="id">bb</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">uf</span> <span class="kwd">as</span> [<span class="id">u</span> <span class="id">f</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PC</span>: <span class="id">U.repr</span> <span class="id">u</span> <span class="id">pc</span> = <span class="id">pc</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">H1</span> <span class="id">pc</span>). <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">record_goto</span>' (<span class="id">u</span>, <span class="id">f</span>) <span class="id">pc</span> <span class="id">bb</span> = (<span class="id">u</span>, <span class="id">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/ <span class="id">exists</span> <span class="id">s</span>, <span class="id">exists</span> <span class="id">bb</span>', <span class="id">bb</span> = <span class="id">Lbranch</span> <span class="id">s</span> :: <span class="id">bb</span>' /\ <span class="id">record_goto</span>' (<span class="id">u</span>, <span class="id">f</span>) <span class="id">pc</span> <span class="id">bb</span> = (<span class="id">U.union</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span>, <span class="id">measure_edge</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">record_goto</span>'; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">bb</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">auto</span>. <span class="id">right</span>. <span class="id">exists</span> <span class="id">s</span>; <span class="id">exists</span> <span class="id">bb</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [<span class="id">B</span> | [<span class="id">s</span> [<span class="id">bb</span>' [<span class="id">EQ</span> <span class="id">B</span>]]]].<br/>
<br/>
&nbsp;u&nbsp;and&nbsp;f&nbsp;are&nbsp;unchanged&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">intro</span> <span class="id">pc</span>'. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">pc</span>' <span class="id">pc</span>). <span class="tactic">subst</span> <span class="id">pc</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">bb</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>.<br/>
<br/>
&nbsp;b&nbsp;is&nbsp;Lbranch&nbsp;s,&nbsp;u&nbsp;becomes&nbsp;union&nbsp;u&nbsp;pc&nbsp;s,&nbsp;f&nbsp;becomes&nbsp;measure_edge&nbsp;u&nbsp;pc&nbsp;s&nbsp;f&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">intro</span> <span class="id">pc</span>'. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">pc</span>' <span class="id">pc</span>). <span class="tactic">subst</span> <span class="id">pc</span>'. <span class="tactic">rewrite</span> <span class="id">EQ</span>.<br/>
<br/>
&nbsp;The&nbsp;new&nbsp;instruction&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">U.repr_union_2</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span>); <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">U.repr_union_3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">measure_edge</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">s</span>) <span class="id">pc</span>). <span class="tactic">auto</span>. <span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PC</span>. <span class="tactic">rewrite</span> <span class="id">peq_true</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;An&nbsp;old&nbsp;instruction&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">pc</span>' = <span class="id">pc</span>' -&gt; <span class="id">U.repr</span> (<span class="id">U.union</span> <span class="id">u</span> <span class="id">pc</span> <span class="id">s</span>) <span class="id">pc</span>' = <span class="id">pc</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H2</span> <span class="tactic">at</span> 2. <span class="tactic">apply</span> <span class="id">U.repr_union_1</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">H1</span> <span class="id">pc</span>'). <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">m</span>!<span class="id">pc</span>'); <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">P</span> | [<span class="id">P</span> <span class="id">Q</span>]]. <span class="id">left</span>; <span class="tactic">auto</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">U.sameclass_union_2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">measure_edge</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">s</span>) <span class="id">pc</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> (<span class="id">U.repr</span> <span class="id">u</span> <span class="id">s0</span>) <span class="id">pc</span>). <span class="tactic">omega</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">record_gotos</span>' (<span class="id">f</span>: <span class="id">function</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PTree.fold</span> <span class="id">record_goto</span>' <span class="id">f</span>.(<span class="id">fn_code</span>) (<span class="id">U.empty</span>, <span class="kwd">fun</span> (<span class="id">x</span>: <span class="id">node</span>) =&gt; <span class="id">O</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">record_gotos_gotos</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">fst</span> (<span class="id">record_gotos</span>' <span class="id">f</span>) = <span class="id">record_gotos</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3557')">Proof.</div>
<div class="proofscript" id="proof3557">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">record_gotos</span>', <span class="id">record_gotos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.fold_spec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">PTree.elements</span> (<span class="id">fn_code</span> <span class="id">f</span>)) (<span class="id">U.empty</span>) (<span class="kwd">fun</span> <span class="id">_</span> : <span class="id">node</span> =&gt; <span class="id">O</span>).<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">record_goto</span>' <span class="tactic">at</span> 2. <span class="tactic">unfold</span> <span class="id">record_goto</span> <span class="tactic">at</span> 2.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">snd</span> <span class="id">a</span>). <span class="tactic">apply</span> <span class="id">IHl</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">apply</span> <span class="id">IHl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">branch_target</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">pc</span>: <span class="id">node</span>) : <span class="id">node</span> :=<br/>
&nbsp;&nbsp;<span class="id">U.repr</span> (<span class="id">record_gotos</span> <span class="id">f</span>) <span class="id">pc</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">count_gotos</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">pc</span>: <span class="id">node</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id">snd</span> (<span class="id">record_gotos</span>' <span class="id">f</span>) <span class="id">pc</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">record_gotos_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Lbranch</span> <span class="id">s</span> :: <span class="id">b</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span> = <span class="id">pc</span> \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span> = <span class="id">branch_target</span> <span class="id">f</span> <span class="id">s</span> /\ <span class="id">count_gotos</span> <span class="id">f</span> <span class="id">s</span> &lt; <span class="id">count_gotos</span> <span class="id">f</span> <span class="id">pc</span>)%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span> = <span class="id">pc</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3558')">Proof.</div>
<div class="proofscript" id="proof3558">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">record_gotos</span>'<span class="id">_correct</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span>). <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> (<span class="id">record_gotos</span>' <span class="id">f</span>). <span class="tactic">unfold</span> <span class="id">branch_map_correct</span>, <span class="id">branch_target</span>, <span class="id">count_gotos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">record_gotos_gotos</span>'. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Preservation of semantics </h1>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variables</span> <span class="id">prog</span> <span class="id">tprog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>).<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>).<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">funsig</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>) = <span class="id">funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3559')">Proof.</div>
<div class="proofscript" id="proof3559">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ros</span> <span class="id">ls</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">ls</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">ls</span> = <span class="id">Some</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3560')">Proof.</div>
<div class="proofscript" id="proof3560">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">f</span>. <span class="tactic">destruct</span> <span class="id">ros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">apply</span> <span class="id">functions_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">function_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The proof of semantic preservation is a simulation argument
  based on diagrams of the following form:
<pre>
           st1 --------------- st2
            |                   |
           t|                  ?|t
            |                   |
            v                   v
           st1'--------------- st2'</pre>
  The <span class="bracket"><span class="id">match_states</span></span> predicate, defined below, captures the precondition
  between states <span class="bracket"><span class="id">st1</span></span> and <span class="bracket"><span class="id">st2</span></span>, as well as the postcondition between
  <span class="bracket"><span class="id">st1</span>'</span> and <span class="bracket"><span class="id">st2</span>'</span>.  One transition in the source code (left) can correspond
  to zero or one transition in the transformed code (right).  The
  "zero transition" case occurs when executing a <span class="bracket"><span class="id">Lgoto</span></span> instruction
  in the source code that has been removed by tunneling.
  In the definition of <span class="bracket"><span class="id">match_states</span></span>, note that only the control-flow
  (in particular, the current program point <span class="bracket"><span class="id">pc</span></span>) is changed:
  the values of locations and the memory states are identical in the
  original and transformed codes. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">tunneled_block</span> (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">b</span>: <span class="id">bblock</span>) :=<br/>
&nbsp;&nbsp;<span class="id">tunnel_block</span> (<span class="id">record_gotos</span> <span class="id">f</span>) <span class="id">b</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">tunneled_code</span> (<span class="id">f</span>: <span class="id">function</span>) :=<br/>
&nbsp;&nbsp;<span class="id">PTree.map1</span> (<span class="id">tunneled_block</span> <span class="id">f</span>) (<span class="id">fn_code</span> <span class="id">f</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stackframes</span>: <span class="id">stackframe</span> -&gt; <span class="id">stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls0</span> <span class="id">bb</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls0</span> <span class="id">bb</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> (<span class="id">tunnel_function</span> <span class="id">f</span>) <span class="id">sp</span> <span class="id">ls0</span> (<span class="id">tunneled_block</span> <span class="id">f</span> <span class="id">bb</span>)).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">ts</span> (<span class="id">tunnel_function</span> <span class="id">f</span>) <span class="id">sp</span> (<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_block</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Block</span> <span class="id">ts</span> (<span class="id">tunnel_function</span> <span class="id">f</span>) <span class="id">sp</span> (<span class="id">tunneled_block</span> <span class="id">f</span> <span class="id">bb</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_interm</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> (<span class="id">Lbranch</span> <span class="id">pc</span> :: <span class="id">bb</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">ts</span> (<span class="id">tunnel_function</span> <span class="id">f</span>) <span class="id">sp</span> (<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">ts</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Returnstate</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">ts</span> <span class="id">ls</span> <span class="id">m</span>).<br/>
<br/>
<div class="doc">To preserve non-terminating behaviours, we show that the transformed
  code cannot take an infinity of "zero transition" cases.
  We use the following <span class="bracket"><span class="kwd">measure</span></span> function over source states,
  which decreases strictly in the "zero transition" case. </div>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">st</span>: <span class="id">state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> =&gt; (<span class="id">count_gotos</span> <span class="id">f</span> <span class="id">pc</span> * 2)%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> (<span class="id">Lbranch</span> <span class="id">pc</span> :: <span class="id">_</span>) <span class="id">ls</span> <span class="id">m</span> =&gt; (<span class="id">count_gotos</span> <span class="id">f</span> <span class="id">pc</span> * 2 + 1)%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Returnstate</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">m</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_parent_locset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">parent_locset</span> <span class="id">ts</span> = <span class="id">parent_locset</span> <span class="id">s</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3561')">Proof.</div>
<div class="proofscript" id="proof3561">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>. <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">tunnel_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">t</span> <span class="id">st2</span>, <span class="id">step</span> <span class="id">ge</span> <span class="id">st1</span> <span class="id">t</span> <span class="id">st2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st1</span>'),<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">st2</span>', <span class="id">step</span> <span class="id">tge</span> <span class="id">st1</span>' <span class="id">t</span> <span class="id">st2</span>' /\ <span class="id">match_states</span> <span class="id">st2</span> <span class="id">st2</span>')<br/>
&nbsp;&nbsp;\/ (<span class="kwd">measure</span> <span class="id">st2</span> &lt; <span class="kwd">measure</span> <span class="id">st1</span> /\ <span class="id">t</span> = <span class="id">E0</span> /\ <span class="id">match_states</span> <span class="id">st2</span> <span class="id">st1</span>')%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3562')">Proof.</div>
<div class="proofscript" id="proof3562">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="tactic">try</span> <span class="id">inv</span> <span class="id">MS</span>.<br/>
<br/>
&nbsp;entering&nbsp;a&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DEFAULT</span>: <span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span> = <span class="id">pc</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">st2</span>' : <span class="id">state</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">ts</span> (<span class="id">tunnel_function</span> <span class="id">f</span>) <span class="id">sp</span> (<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span>) <span class="id">rs</span> <span class="id">m</span>) <span class="id">E0</span> <span class="id">st2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_states</span> (<span class="id">Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">rs</span> <span class="id">m</span>) <span class="id">st2</span>')).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gmap1</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">record_gotos_correct</span> <span class="id">f</span> <span class="id">pc</span>). <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">bb</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">A</span> | [<span class="id">B</span> <span class="id">C</span>]]. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lop</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lload&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lload</span> <span class="kwd">with</span> (<span class="id">a</span> := <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lgetstack&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lsetstack&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lstore&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lstore</span> <span class="kwd">with</span> (<span class="id">a</span> := <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lcall&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lcall</span> <span class="kwd">with</span> (<span class="id">fd</span> := <span class="id">tunnel_fundef</span> <span class="id">fd</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">find_function_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sig_preserved</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;Ltailcall&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ltailcall</span> <span class="kwd">with</span> (<span class="id">fd</span> := <span class="id">tunnel_fundef</span> <span class="id">fd</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">match_parent_locset</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">find_function_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">match_parent_locset</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lbuiltin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lbuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lbranch&nbsp;(preserved)&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lbranch</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> (<span class="id">branch_target</span> <span class="id">f</span> <span class="id">pc</span>). <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lbranch&nbsp;(eliminated)&nbsp;*)</span>&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;Lcond&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lcond</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Ljumptable&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ljumptable</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">list_nth_z_map</span>. <span class="id">change</span> <span class="id">U.elt</span> <span class="kwd">with</span> <span class="id">node</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">reflexivity</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Lreturn&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Lreturn</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">match_parent_locset</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;internal&nbsp;function&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;external&nbsp;function&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_return</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3563')">Proof.</div>
<div class="proofscript" id="proof3563">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">nil</span> (<span class="id">tunnel_fundef</span> <span class="id">f</span>) (<span class="id">Locmap.init</span> <span class="id">Vundef</span>) <span class="id">m0</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">Genv.init_mem_transf</span> <span class="id">TRANSL</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_program_main</span> <span class="id">TRANSL</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">function_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3564')">Proof.</div>
<div class="proofscript" id="proof3564">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H5</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">LTL.semantics</span> <span class="id">prog</span>) (<span class="id">LTL.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3565')">Proof.</div>
<div class="proofscript" id="proof3565">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_opt</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_final_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">tunnel_step_correct</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
