<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module CSEproof</title>
<meta name="description" content="Documentation of Coq module CSEproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module CSEproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for common subexpression elimination. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Errors</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">Lattice</span> <span class="id">Kildall</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Registers</span> <span class="id">RTL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValueDomain</span> <span class="id">ValueAOp</span> <span class="id">ValueAnalysis</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CSEdomain</span> <span class="id">CombineOp</span> <span class="id">CombineOpproof</span> <span class="id">CSE</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">prog</span> <span class="id">tprog</span>: <span class="id">RTL.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">prog</span> <span class="id">tprog</span>, <span class="id">transf_program</span> <span class="id">prog</span> = <span class="id">OK</span> <span class="id">tprog</span> -&gt; <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3141')">Proof.</div>
<div class="proofscript" id="proof3141">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_transform_partial_program_contextual</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Soundness of operations over value numberings </h1>
<br/>
<span class="kwd">Remark</span> <span class="id">wf_equation_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">next1</span> <span class="id">next2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_equation</span> <span class="id">next1</span> <span class="id">e</span> -&gt; <span class="id">Ple</span> <span class="id">next1</span> <span class="id">next2</span> -&gt; <span class="id">wf_equation</span> <span class="id">next2</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3142')">Proof.</div>
<div class="proofscript" id="proof3142">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">wf_equation</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">e</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_le_trans</span> <span class="kwd">with</span> <span class="id">next1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Plt_le_trans</span> <span class="kwd">with</span> <span class="id">next1</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Extensionality with respect to valuations. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">valu_agree</span> (<span class="id">valu1</span> <span class="id">valu2</span>: <span class="id">valuation</span>) (<span class="id">upto</span>: <span class="id">valnum</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">Plt</span> <span class="id">v</span> <span class="id">upto</span> -&gt; <span class="id">valu2</span> <span class="id">v</span> = <span class="id">valu1</span> <span class="id">v</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">EXTEN</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">valu1</span>: <span class="id">valuation</span>.<br/>
<span class="kwd">Variable</span> <span class="id">upto</span>: <span class="id">valnum</span>.<br/>
<span class="kwd">Variable</span> <span class="id">valu2</span>: <span class="id">valuation</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">AGREE</span>: <span class="id">valu_agree</span> <span class="id">valu1</span> <span class="id">valu2</span> <span class="id">upto</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rs</span>: <span class="id">regset</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">valnums_val_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> <span class="id">vl</span> -&gt; <span class="id">Plt</span> <span class="id">v</span> <span class="id">upto</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">map</span> <span class="id">valu2</span> <span class="id">vl</span> = <span class="id">map</span> <span class="id">valu1</span> <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3143')">Proof.</div>
<div class="proofscript" id="proof3143">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">list_map_exten</span>. <span class="tactic">intros</span>. <span class="tactic">symmetry</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">rhs_eval_to_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">r</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> (<span class="id">valnums_rhs</span> <span class="id">r</span>) -&gt; <span class="id">Plt</span> <span class="id">v</span> <span class="id">upto</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">r</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3144')">Proof.</div>
<div class="proofscript" id="proof3144">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">valnums_val_exten</span> <span class="tactic">by</span> <span class="tactic">assumption</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">valnums_val_exten</span> <span class="tactic">by</span> <span class="tactic">assumption</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">equation_holds_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">equation_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">wf_equation</span> <span class="id">upto</span> <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">equation_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3145')">Proof.</div>
<div class="proofscript" id="proof3145">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">e</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">AGREE</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">rhs_eval_to_exten</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>. <span class="tactic">apply</span> <span class="id">rhs_eval_to_exten</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">AGREE</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">numbering_holds_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">upto</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3146')">Proof.</div>
<div class="proofscript" id="proof3146">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">equation_holds_exten</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">wf_equation_incr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">AGREE</span>. <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Plt_le_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">wf_num_reg</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">EXTEN</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">splitall</span> := <span class="tactic">repeat</span> (<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span> |- <span class="id">_</span> /\ <span class="id">_</span> =&gt; <span class="tactic">split</span> <span class="kwd">end</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">valnum_reg_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">r</span> <span class="id">n</span>' <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">r</span> = (<span class="id">n</span>', <span class="id">v</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">rs</span>#<span class="id">r</span> = <span class="id">valu2</span> <span class="id">v</span><br/>
&nbsp;&nbsp;/\ <span class="id">valu_agree</span> <span class="id">valu1</span> <span class="id">valu2</span> <span class="id">n</span>.(<span class="id">num_next</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Plt</span> <span class="id">v</span> <span class="id">n</span>'.(<span class="id">num_next</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Ple</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">n</span>'.(<span class="id">num_next</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3147')">Proof.</div>
<div class="proofscript" id="proof3147">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">valnum_reg</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">num_reg</span> <span class="id">n</span>)!<span class="id">r</span> <span class="kwd">as</span> [<span class="id">v</span>'|] <span class="id">eqn</span>:<span class="id">NR</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="id">exists</span> <span class="id">valu1</span>; <span class="id">splitall</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">valu2</span> := <span class="kwd">fun</span> <span class="id">vn</span> =&gt; <span class="kwd">if</span> <span class="id">peq</span> <span class="id">vn</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="kwd">then</span> <span class="id">rs</span>#<span class="id">r</span> <span class="kwd">else</span> <span class="id">valu1</span> <span class="id">vn</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">AG</span>: <span class="id">valu_agree</span> <span class="id">valu1</span> <span class="id">valu2</span> <span class="id">n</span>.(<span class="id">num_next</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">valu2</span>. <span class="tactic">apply</span> <span class="id">peq_false</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>; <span class="id">splitall</span>.<br/>
+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
* <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wf_equation_incr</span> <span class="kwd">with</span> (<span class="id">num_next</span> <span class="id">n</span>). <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_trans_succ</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">v</span> (<span class="id">num_next</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">r0</span> <span class="kwd">with</span> <span class="id">r</span> <span class="tactic">by</span> (<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">intuition</span>). <span class="tactic">rewrite</span> <span class="id">PTree.gss</span>. <span class="tactic">subst</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
* <span class="tactic">eapply</span> <span class="id">equation_holds_exten</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
* <span class="tactic">unfold</span> <span class="id">valu2</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">peq_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">peq_false</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">unfold</span> <span class="id">valu2</span>. <span class="tactic">rewrite</span> <span class="id">peq_true</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">auto</span>.<br/>
+ <span class="id">xomega</span>.<br/>
+ <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">valnum_regs_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rl</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">n</span>' <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">rl</span> = (<span class="id">n</span>', <span class="id">vl</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">rs</span>##<span class="id">rl</span> = <span class="id">map</span> <span class="id">valu2</span> <span class="id">vl</span><br/>
&nbsp;&nbsp;/\ <span class="id">valu_agree</span> <span class="id">valu1</span> <span class="id">valu2</span> <span class="id">n</span>.(<span class="id">num_next</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">v</span>, <span class="id">In</span> <span class="id">v</span> <span class="id">vl</span> -&gt; <span class="id">Plt</span> <span class="id">v</span> <span class="id">n</span>'.(<span class="id">num_next</span>))<br/>
&nbsp;&nbsp;/\ <span class="id">Ple</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">n</span>'.(<span class="id">num_next</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3148')">Proof.</div>
<div class="proofscript" id="proof3148">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="id">exists</span> <span class="id">valu1</span>; <span class="id">splitall</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">tauto</span>. <span class="id">xomega</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">v1</span>] <span class="id">eqn</span>:<span class="id">V1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">n1</span> <span class="id">rl</span>) <span class="kwd">as</span> [<span class="id">n2</span> <span class="id">vs</span>] <span class="id">eqn</span>:<span class="id">V2</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_reg_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHrl</span> <span class="id">valu2</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">valu3</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span> &amp; <span class="id">S</span> &amp; <span class="id">T</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu3</span>; <span class="id">splitall</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">simpl</span>; <span class="tactic">f_equal</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">R</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">valu2</span> <span class="id">v</span>); <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">R</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">subst</span> <span class="id">v1</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;+ <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_valnum_rhs_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rh</span> <span class="id">v</span> <span class="id">eqs</span>,<br/>
&nbsp;&nbsp;<span class="id">find_valnum_rhs</span> <span class="id">rh</span> <span class="id">eqs</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">In</span> (<span class="id">Eq</span> <span class="id">v</span> <span class="id">true</span> <span class="id">rh</span>) <span class="id">eqs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3149')">Proof.</div>
<div class="proofscript" id="proof3149">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">eqs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> (<span class="id">strict</span> &amp;&amp; <span class="id">eq_rhs</span> <span class="id">rh</span> <span class="id">r</span>) <span class="id">eqn</span>:<span class="id">T</span>.<br/>
&nbsp;&nbsp;+ <span class="id">InvBooleans</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">left</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">right</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_valnum_rhs</span>'<span class="id">_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rh</span> <span class="id">v</span> <span class="id">eqs</span>,<br/>
&nbsp;&nbsp;<span class="id">find_valnum_rhs</span>' <span class="id">rh</span> <span class="id">eqs</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">exists</span> <span class="id">strict</span>, <span class="id">In</span> (<span class="id">Eq</span> <span class="id">v</span> <span class="id">strict</span> <span class="id">rh</span>) <span class="id">eqs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3150')">Proof.</div>
<div class="proofscript" id="proof3150">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">eqs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> (<span class="id">eq_rhs</span> <span class="id">rh</span> <span class="id">r</span>) <span class="id">eqn</span>:<span class="id">T</span>.<br/>
&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">strict</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">IHeqs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">s</span> <span class="id">IN</span>]. <span class="id">exists</span> <span class="id">s</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_valnum_num_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">r</span> <span class="id">eqs</span>, <span class="id">find_valnum_num</span> <span class="id">v</span> <span class="id">eqs</span> = <span class="id">Some</span> <span class="id">r</span> -&gt; <span class="id">In</span> (<span class="id">Eq</span> <span class="id">v</span> <span class="id">true</span> <span class="id">r</span>) <span class="id">eqs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3151')">Proof.</div>
<div class="proofscript" id="proof3151">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">eqs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> (<span class="id">strict</span> &amp;&amp; <span class="id">peq</span> <span class="id">v</span> <span class="id">v0</span>) <span class="id">eqn</span>:<span class="id">T</span>.<br/>
&nbsp;&nbsp;+ <span class="id">InvBooleans</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">reg_valnum_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">v</span> <span class="id">r</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">reg_valnum</span> <span class="id">n</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">rs</span>#<span class="id">r</span> = <span class="id">valu</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3152')">Proof.</div>
<div class="proofscript" id="proof3152">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">reg_valnum</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">num_val</span> <span class="id">n</span>)#<span class="id">v</span> <span class="kwd">as</span> [ | <span class="id">r1</span> <span class="id">rl</span>] <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">num_holds_reg</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">E</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">regs_valnums_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vl</span> <span class="id">rl</span>,<br/>
&nbsp;&nbsp;<span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vl</span> = <span class="id">Some</span> <span class="id">rl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">rs</span>##<span class="id">rl</span> = <span class="id">map</span> <span class="id">valu</span> <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3153')">Proof.</div>
<div class="proofscript" id="proof3153">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">reg_valnum</span> <span class="id">n</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">r1</span>|] <span class="id">eqn</span>:<span class="id">RV1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">rl1</span>|] <span class="id">eqn</span>:<span class="id">RVL</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">f_equal</span>. <span class="tactic">eapply</span> <span class="id">reg_valnum_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_rhs_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">rh</span> <span class="id">r</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">find_rhs</span> <span class="id">n</span> <span class="id">rh</span> = <span class="id">Some</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rh</span> <span class="id">v</span> /\ <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">rs</span>#<span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3154')">Proof.</div>
<div class="proofscript" id="proof3154">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">find_rhs</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">find_valnum_rhs</span>' <span class="id">rh</span> (<span class="id">num_eqs</span> <span class="id">n</span>)) <span class="kwd">as</span> [<span class="id">vres</span>|] <span class="id">eqn</span>:<span class="id">E</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_valnum_rhs</span>'<span class="id">_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">strict</span> <span class="id">IN</span>].<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">reg_valnum_sound</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">num_holds_eq</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EH</span>. <span class="id">inv</span> <span class="id">EH</span>.<br/>
- <span class="id">exists</span> (<span class="id">valu</span> <span class="id">vres</span>); <span class="tactic">auto</span>.<br/>
- <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">in_remove</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">eq</span>: <span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">A</span>), {<span class="id">x</span>=<span class="id">y</span>}+{<span class="id">x</span>&lt;&gt;<span class="id">y</span>}) <span class="id">x</span> <span class="id">y</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">y</span> (<span class="id">List.remove</span> <span class="id">eq</span> <span class="id">x</span> <span class="id">l</span>) &lt;-&gt; <span class="id">x</span> &lt;&gt; <span class="id">y</span> /\ <span class="id">In</span> <span class="id">y</span> <span class="id">l</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3155')">Proof.</div>
<div class="proofscript" id="proof3155">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq</span> <span class="id">x</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">rewrite</span> <span class="id">IHl</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">IHl</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">forget_reg_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_numbering</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">r</span> (<span class="id">PMap.get</span> <span class="id">v</span> (<span class="id">forget_reg</span> <span class="id">n</span> <span class="id">rd</span>)) -&gt; <span class="id">r</span> &lt;&gt; <span class="id">rd</span> /\ <span class="id">In</span> <span class="id">r</span> (<span class="id">PMap.get</span> <span class="id">v</span> <span class="id">n</span>.(<span class="id">num_val</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3156')">Proof.</div>
<div class="proofscript" id="proof3156">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">forget_reg</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">PTree.get</span> <span class="id">rd</span> <span class="id">n</span>.(<span class="id">num_reg</span>)) <span class="kwd">as</span> [<span class="id">vd</span>|] <span class="id">eqn</span>:<span class="id">GET</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">v</span> <span class="id">vd</span>).<br/>
&nbsp;&nbsp;+ <span class="tactic">subst</span> <span class="id">v</span>. <span class="tactic">rewrite</span> <span class="id">in_remove</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">exploit</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
- <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">exploit</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_reg_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">vd</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_numbering</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">r</span> (<span class="id">PMap.get</span> <span class="id">v</span> (<span class="id">update_reg</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">vd</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">r</span> (<span class="id">PTree.set</span> <span class="id">rd</span> <span class="id">vd</span> <span class="id">n</span>.(<span class="id">num_reg</span>)) = <span class="id">Some</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3157')">Proof.</div>
<div class="proofscript" id="proof3157">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">update_reg</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">v</span> <span class="id">vd</span>).<br/>
- <span class="tactic">subst</span> <span class="id">v</span>. <span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
+ <span class="tactic">subst</span> <span class="id">r</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
+ <span class="id">exploit</span> <span class="id">forget_reg_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">exploit</span> <span class="id">forget_reg_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">wf_num_val</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">rhs_eval_to_inj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rh</span> <span class="id">v1</span> <span class="id">v2</span>,<br/>
&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rh</span> <span class="id">v1</span> -&gt; <span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rh</span> <span class="id">v2</span> -&gt; <span class="id">v1</span> = <span class="id">v2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3158')">Proof.</div>
<div class="proofscript" id="proof3158">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_rhs_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">rh</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rh</span> (<span class="id">rs</span>'#<span class="id">rd</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">wf_rhs</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="id">rh</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">r</span> &lt;&gt; <span class="id">rd</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>, <span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span>' <span class="id">m</span> (<span class="id">add_rhs</span> <span class="id">n</span> <span class="id">rd</span> <span class="id">rh</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3159')">Proof.</div>
<div class="proofscript" id="proof3159">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_rhs</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_valnum_rhs</span> <span class="id">rh</span> <span class="id">n</span>.(<span class="id">num_eqs</span>)) <span class="kwd">as</span> [<span class="id">vres</span>|] <span class="id">eqn</span>:<span class="id">FIND</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;A&nbsp;value&nbsp;number&nbsp;exists&nbsp;already&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_valnum_rhs_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">IN</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">wf_num_eqs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">num_holds_eq</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EH</span>. <span class="id">inv</span> <span class="id">EH</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs</span>'#<span class="id">rd</span> = <span class="id">valu1</span> <span class="id">vres</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">rhs_eval_to_inj</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu1</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">rd</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H5</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">update_reg_charact</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">rd</span>).<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Assigning&nbsp;a&nbsp;new&nbsp;value&nbsp;number&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">valu2</span> := <span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="kwd">if</span> <span class="id">peq</span> <span class="id">v</span> <span class="id">n</span>.(<span class="id">num_next</span>) <span class="kwd">then</span> <span class="id">rs</span>'#<span class="id">rd</span> <span class="kwd">else</span> <span class="id">valu1</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">AG</span>: <span class="id">valu_agree</span> <span class="id">valu1</span> <span class="id">valu2</span> <span class="id">n</span>.(<span class="id">num_next</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">valu2</span>. <span class="tactic">apply</span> <span class="id">peq_false</span>. <span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="tactic">simpl</span>; <span class="tactic">split</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Plt_trans_succ</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wf_equation_incr</span> <span class="kwd">with</span> (<span class="id">num_next</span> <span class="id">n</span>). <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">rd</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_trans_succ</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">apply</span> <span class="id">update_reg_charact</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">unfold</span> <span class="id">valu2</span> <span class="tactic">at</span> 2; <span class="tactic">rewrite</span> <span class="id">peq_true</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">rhs_eval_to_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">equation_holds_exten</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">unfold</span> <span class="id">valu2</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">rd</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>. <span class="tactic">rewrite</span> <span class="id">peq_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">peq_false</span>. <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Plt_ne</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_op_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">op</span> (<span class="id">args</span>: <span class="id">list</span> <span class="id">reg</span>) <span class="id">v</span> <span class="id">dst</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">op</span> <span class="id">rs</span>##<span class="id">args</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>, <span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">rs</span>#<span class="id">dst</span> &lt;- <span class="id">v</span>) <span class="id">m</span> (<span class="id">add_op</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">op</span> <span class="id">args</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3160')">Proof.</div>
<div class="proofscript" id="proof3160">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_op</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">is_move_operation</span> <span class="id">op</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">src</span>|] <span class="id">eqn</span>:<span class="id">ISMOVE</span>.<br/>
- <span class="comment">(*&nbsp;special&nbsp;case&nbsp;for&nbsp;moves&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">is_move_operation_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]; <span class="tactic">subst</span> <span class="id">op</span> <span class="id">args</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">src</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vsrc</span>] <span class="id">eqn</span>:<span class="id">VN</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_reg_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">dst</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">update_reg_charact</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r</span> <span class="id">dst</span>). <span class="tactic">congruence</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;general&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:<span class="id">VN</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_rhs_holds</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">congruence</span>.<br/>
+ <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Regmap.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_load_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">addr</span> (<span class="id">args</span>: <span class="id">list</span> <span class="id">reg</span>) <span class="id">a</span> <span class="id">chunk</span> <span class="id">v</span> <span class="id">dst</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">rs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.loadv</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">a</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>, <span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">rs</span>#<span class="id">dst</span> &lt;- <span class="id">v</span>) <span class="id">m</span> (<span class="id">add_load</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3161')">Proof.</div>
<div class="proofscript" id="proof3161">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_load</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">n</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:<span class="id">VN</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_rhs_holds</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="id">econstructor</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">B</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Regmap.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_unknown_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">v</span>) <span class="id">m</span> (<span class="id">set_unknown</span> <span class="id">n</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3162')">Proof.</div>
<div class="proofscript" id="proof3162">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">PTree.grspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">r0</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">forget_reg_charact</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gro</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.grspec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">r0</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_res_unknown_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">regmap_setres</span> <span class="id">r</span> <span class="id">v</span> <span class="id">rs</span>) <span class="id">m</span> (<span class="id">set_res_unknown</span> <span class="id">n</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3163')">Proof.</div>
<div class="proofscript" id="proof3163">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">r</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">set_unknown_holds</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kill_eqs_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">pred</span> <span class="id">l</span> <span class="id">strict</span> <span class="id">r</span> <span class="id">eqs</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">Eq</span> <span class="id">l</span> <span class="id">strict</span> <span class="id">r</span>) (<span class="id">kill_eqs</span> <span class="id">pred</span> <span class="id">eqs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">pred</span> <span class="id">r</span> = <span class="id">false</span> /\ <span class="id">In</span> (<span class="id">Eq</span> <span class="id">l</span> <span class="id">strict</span> <span class="id">r</span>) <span class="id">eqs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3164')">Proof.</div>
<div class="proofscript" id="proof3164">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">eqs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">tauto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> (<span class="id">pred</span> <span class="id">r0</span>) <span class="id">eqn</span>:<span class="id">PRED</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">auto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kill_equations_hold</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">pred</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pred</span> <span class="id">r</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">r</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span>' <span class="id">r</span> <span class="id">v</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">kill_equations</span> <span class="id">pred</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3165')">Proof.</div>
<div class="proofscript" id="proof3165">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">e</span>. <span class="id">exploit</span> <span class="id">kill_eqs_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">eq</span>. <span class="id">exploit</span> <span class="id">kill_eqs_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">num_holds_eq</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">EH</span>; <span class="id">inv</span> <span class="id">EH</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kill_all_loads_hold</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">kill_all_loads</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3166')">Proof.</div>
<div class="proofscript" id="proof3166">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">kill_equations_hold</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">filter_loads</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">op_depends_on_memory_correct</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kill_loads_after_store_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">a</span> <span class="id">chunk</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">approx</span> <span class="id">ae</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">addr</span> <span class="id">rs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storev</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">approx</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">kill_loads_after_store</span> <span class="id">approx</span> <span class="id">n</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3167')">Proof.</div>
<div class="proofscript" id="proof3167">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">kill_equations_hold</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">filter_after_store</span> <span class="kwd">in</span> <span class="id">H6</span>; <span class="id">inv</span> <span class="id">H7</span>.<br/>
- <span class="id">constructor</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H8</span>. <span class="tactic">apply</span> <span class="id">op_depends_on_memory_correct</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">rl</span>|] <span class="id">eqn</span>:<span class="id">RV</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H9</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H9</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">negb_false_iff</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">unfold</span> <span class="id">aaddressing</span> <span class="kwd">in</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">pdisjoint_sound</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>. <span class="tactic">eapply</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">regs_valnums_sound</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>. <span class="tactic">eapply</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_normalized_range_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">chunk</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">vmatch</span> <span class="id">bc</span> <span class="id">v</span> (<span class="id">store_normalized_range</span> <span class="id">chunk</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> (<span class="id">Val.load_result</span> <span class="id">chunk</span> <span class="id">v</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3168')">Proof.</div>
<div class="proofscript" id="proof3168">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Val.load_result</span>; <span class="id">remember</span> <span class="id">Archi.ptr64</span> <span class="kwd">as</span> <span class="id">ptr64</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">is_sgn_sign_ext</span> <span class="kwd">in</span> <span class="id">H4</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">is_uns_zero_ext</span> <span class="kwd">in</span> <span class="id">H4</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">is_sgn_sign_ext</span> <span class="kwd">in</span> <span class="id">H4</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">is_uns_zero_ext</span> <span class="kwd">in</span> <span class="id">H4</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">ptr64</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">ptr64</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">ptr64</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_store_result_hold</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>' <span class="id">n</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">a</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">src</span> <span class="id">bc</span> <span class="id">ae</span> <span class="id">approx</span> <span class="id">am</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu1</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>' <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">rs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storev</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">a</span> <span class="id">rs</span>#<span class="id">src</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">approx</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu2</span>, <span class="id">numbering_holds</span> <span class="id">valu2</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">add_store_result</span> <span class="id">approx</span> <span class="id">n</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3169')">Proof.</div>
<div class="proofscript" id="proof3169">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_store_result</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">avalue</span>; <span class="tactic">rewrite</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">vincl</span> (<span class="id">AE.get</span> <span class="id">src</span> <span class="id">ae</span>) (<span class="id">store_normalized_range</span> <span class="id">chunk</span>)) <span class="id">eqn</span>:<span class="id">INCL</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">valnum_reg</span> <span class="id">n</span> <span class="id">src</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vsrc</span>] <span class="id">eqn</span>:<span class="id">VR1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">n1</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n2</span> <span class="id">vargs</span>] <span class="id">eqn</span>:<span class="id">VR2</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_reg_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu3</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span> &amp; <span class="id">S</span> &amp; <span class="id">T</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu3</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">subst</span> <span class="id">e</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Plt_le_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">H4</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>. <span class="tactic">subst</span> <span class="id">eq</span>. <span class="tactic">apply</span> <span class="id">eq_holds_lessdef</span> <span class="kwd">with</span> (<span class="id">Val.load_result</span> <span class="id">chunk</span> <span class="id">rs</span>#<span class="id">src</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">load_eval_to</span> <span class="kwd">with</span> <span class="id">a</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">Q</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_store_same</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">rewrite</span> <span class="id">R</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">store_normalized_range_sound</span> <span class="kwd">with</span> <span class="id">bc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">B</span>. <span class="tactic">eapply</span> <span class="id">vmatch_ge</span>. <span class="tactic">apply</span> <span class="id">vincl_ge</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">H2</span>.<br/>
+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
<br/>
- <span class="id">exists</span> <span class="id">valu1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">kill_loads_after_storebytes_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">bytes</span> <span class="id">m</span>' <span class="id">bc</span> <span class="id">approx</span> <span class="id">ae</span> <span class="id">am</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">dst</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storebytes</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) <span class="id">bytes</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ematch</span> <span class="id">bc</span> <span class="id">rs</span> <span class="id">ae</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">approx</span> = <span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">length</span> <span class="id">bytes</span> = <span class="id">nat_of_Z</span> <span class="id">sz</span> -&gt; <span class="id">sz</span> &gt;= 0 -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">kill_loads_after_storebytes</span> <span class="id">approx</span> <span class="id">n</span> <span class="id">dst</span> <span class="id">sz</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3170')">Proof.</div>
<div class="proofscript" id="proof3170">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">kill_equations_hold</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">filter_after_store</span> <span class="kwd">in</span> <span class="id">H8</span>; <span class="id">inv</span> <span class="id">H9</span>.<br/>
- <span class="id">constructor</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H10</span>. <span class="tactic">apply</span> <span class="id">op_depends_on_memory_correct</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">rl</span>|] <span class="id">eqn</span>:<span class="id">RV</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H11</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H10</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">negb_false_iff</span> <span class="kwd">in</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_storebytes_other</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="tactic">rewrite</span> <span class="id">nat_of_Z_eq</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">pdisjoint_sound</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">aaddressing</span>. <span class="tactic">apply</span> <span class="id">match_aptr_of_aval</span>. <span class="tactic">eapply</span> <span class="id">eval_static_addressing_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">regs_valnums_sound</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">va</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">load_memcpy</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">b1</span> <span class="id">ofs1</span> <span class="id">sz</span> <span class="id">bytes</span> <span class="id">b2</span> <span class="id">ofs2</span> <span class="id">m</span>' <span class="id">chunk</span> <span class="id">i</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">b1</span> <span class="id">ofs1</span> <span class="id">sz</span> = <span class="id">Some</span> <span class="id">bytes</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storebytes</span> <span class="id">m</span> <span class="id">b2</span> <span class="id">ofs2</span> <span class="id">bytes</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b1</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ofs1</span> &lt;= <span class="id">i</span> -&gt; <span class="id">i</span> + <span class="id">size_chunk</span> <span class="id">chunk</span> &lt;= <span class="id">ofs1</span> + <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">align_chunk</span> <span class="id">chunk</span> | <span class="id">ofs2</span> - <span class="id">ofs1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b2</span> (<span class="id">i</span> + (<span class="id">ofs2</span> - <span class="id">ofs1</span>)) = <span class="id">Some</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3171')">Proof.</div>
<div class="proofscript" id="proof3171">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">size_chunk_pos</span> <span class="id">chunk</span>); <span class="tactic">intros</span> <span class="id">SPOS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">n1</span> := <span class="id">i</span> - <span class="id">ofs1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">n2</span> := <span class="id">size_chunk</span> <span class="id">chunk</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">n3</span> := <span class="id">sz</span> - (<span class="id">n1</span> + <span class="id">n2</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">sz</span> <span class="kwd">with</span> (<span class="id">n1</span> + (<span class="id">n2</span> + <span class="id">n3</span>)) <span class="kwd">in</span> <span class="id">H</span> <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">n3</span>, <span class="id">n2</span>, <span class="id">n1</span>; <span class="tactic">omega</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">n1</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">n3</span>, <span class="id">n2</span>, <span class="id">n1</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bytes1</span> &amp; <span class="id">bytes23</span> &amp; <span class="id">LB1</span> &amp; <span class="id">LB23</span> &amp; <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_split</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">n2</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">n3</span>, <span class="id">n2</span>, <span class="id">n1</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">bytes2</span> &amp; <span class="id">bytes3</span> &amp; <span class="id">LB2</span> &amp; <span class="id">LB3</span> &amp; <span class="id">EQ</span>').<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">bytes23</span>; <span class="tactic">subst</span> <span class="id">bytes</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_loadbytes</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">bytes2</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">bytes2</span>' = <span class="id">bytes2</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">replace</span> (<span class="id">ofs1</span> + <span class="id">n1</span>) <span class="kwd">with</span> <span class="id">i</span> <span class="kwd">in</span> <span class="id">LB2</span> <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">n1</span>; <span class="tactic">omega</span>). <span class="tactic">unfold</span> <span class="id">n2</span> <span class="kwd">in</span> <span class="id">LB2</span>. <span class="tactic">congruence</span>.  }<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">bytes2</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storebytes_split</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">m1</span> &amp; <span class="id">SB1</span> &amp; <span class="id">SB23</span>).<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storebytes_split</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">m2</span> &amp; <span class="id">SB2</span> &amp; <span class="id">SB3</span>).<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SB23</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">L1</span>: <span class="id">Z.of_nat</span> (<span class="id">length</span> <span class="id">bytes1</span>) = <span class="id">n1</span>).<br/>
&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">Mem.loadbytes_length</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">nat_of_Z_eq</span>. <span class="tactic">unfold</span> <span class="id">n1</span>; <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">L2</span>: <span class="id">Z.of_nat</span> (<span class="id">length</span> <span class="id">bytes2</span>) = <span class="id">n2</span>).<br/>
&nbsp;&nbsp;{ <span class="id">erewrite</span> <span class="id">Mem.loadbytes_length</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">nat_of_Z_eq</span>. <span class="tactic">unfold</span> <span class="id">n2</span>; <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">L1</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">L2</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LB</span>': <span class="id">Mem.loadbytes</span> <span class="id">m2</span> <span class="id">b2</span> (<span class="id">ofs2</span> + <span class="id">n1</span>) <span class="id">n2</span> = <span class="id">Some</span> <span class="id">bytes2</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">L2</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_storebytes_same</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LB</span>'': <span class="id">Mem.loadbytes</span> <span class="id">m</span>' <span class="id">b2</span> (<span class="id">ofs2</span> + <span class="id">n1</span>) <span class="id">n2</span> = <span class="id">Some</span> <span class="id">bytes2</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">LB</span>'. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_storebytes_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">n2</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>; <span class="id">left</span>; <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_valid_access</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">Mem.loadbytes_load</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">i</span> + (<span class="id">ofs2</span> - <span class="id">ofs1</span>)) <span class="kwd">with</span> (<span class="id">ofs2</span> + <span class="id">n1</span>) <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">n1</span>; <span class="tactic">omega</span>).<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">LB</span>''.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z.divide_add_r</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">shift_memcpy_eq_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">e</span> <span class="id">e</span>' <span class="id">next</span>,<br/>
&nbsp;&nbsp;<span class="id">shift_memcpy_eq</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">e</span> = <span class="id">Some</span> <span class="id">e</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">wf_equation</span> <span class="id">next</span> <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">wf_equation</span> <span class="id">next</span> <span class="id">e</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3172')">Proof with</div>
<div class="proofscript" id="proof3172">
 (<span class="tactic">try</span> <span class="tactic">discriminate</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">shift_memcpy_eq</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">e</span>. <span class="tactic">destruct</span> <span class="id">r</span>... <span class="tactic">destruct</span> <span class="id">a</span>...<br/>
&nbsp;&nbsp;<span class="tactic">try</span> (<span class="tactic">rename</span> <span class="id">i</span> <span class="id">into</span> <span class="id">ofs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> <span class="id">src</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">zle</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">size_chunk</span> <span class="id">m</span>) (<span class="id">src</span> + <span class="id">sz</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">zeq</span> (<span class="id">delta</span> <span class="id">mod</span> <span class="id">align_chunk</span> <span class="id">m</span>) 0 &amp;&amp; <span class="id">zle</span> 0 (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">delta</span>) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">zle</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">delta</span>) <span class="id">Ptrofs.max_unsigned</span>)...<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">shift_memcpy_eq_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">src</span> <span class="id">dst</span> <span class="id">sz</span> <span class="id">e</span> <span class="id">e</span>' <span class="id">m</span> <span class="id">sp</span> <span class="id">bytes</span> <span class="id">m</span>' <span class="id">valu</span> <span class="id">ge</span>,<br/>
&nbsp;&nbsp;<span class="id">shift_memcpy_eq</span> <span class="id">src</span> <span class="id">sz</span> (<span class="id">dst</span> - <span class="id">src</span>) <span class="id">e</span> = <span class="id">Some</span> <span class="id">e</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">src</span> <span class="id">sz</span> = <span class="id">Some</span> <span class="id">bytes</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storebytes</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">dst</span> <span class="id">bytes</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">equation_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">e</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">equation_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span>' <span class="id">e</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3173')">Proof with</div>
<div class="proofscript" id="proof3173">
 (<span class="tactic">try</span> <span class="tactic">discriminate</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">set</span> (<span class="id">delta</span> := <span class="id">dst</span> - <span class="id">src</span>) <span class="kwd">in</span> *. <span class="tactic">unfold</span> <span class="id">shift_memcpy_eq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">e</span> <span class="kwd">as</span> [<span class="id">l</span> <span class="id">strict</span> <span class="id">rhs</span>] <span class="id">eqn</span>:<span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">rhs</span> <span class="kwd">as</span> [<span class="id">op</span> <span class="id">vl</span> | <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vl</span>]...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">addr</span>...<br/>
&nbsp;&nbsp;<span class="tactic">try</span> (<span class="tactic">rename</span> <span class="id">i</span> <span class="id">into</span> <span class="id">ofs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">i1</span> := <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) <span class="kwd">in</span> *. <span class="tactic">set</span> (<span class="id">j</span> := <span class="id">i1</span> + <span class="id">delta</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> <span class="id">src</span> <span class="id">i1</span>)...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> (<span class="id">i1</span> + <span class="id">size_chunk</span> <span class="id">chunk</span>) (<span class="id">src</span> + <span class="id">sz</span>))...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">delta</span> <span class="id">mod</span> <span class="id">align_chunk</span> <span class="id">chunk</span>) 0)...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> 0 <span class="id">j</span>)...<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> <span class="id">j</span> <span class="id">Ptrofs.max_unsigned</span>)...<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LD</span>: <span class="kwd">forall</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.loadv</span> <span class="id">chunk</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.loadv</span> <span class="id">chunk</span> <span class="id">m</span>' (<span class="id">Vptr</span> <span class="id">sp</span> (<span class="id">Ptrofs.repr</span> <span class="id">j</span>)) = <span class="id">Some</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">j</span>, <span class="id">delta</span>. <span class="tactic">eapply</span> <span class="id">load_memcpy</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zmod_divide</span>; <span class="tactic">auto</span>. <span class="tactic">generalize</span> (<span class="id">align_chunk_pos</span> <span class="id">chunk</span>); <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>.<br/>
+ <span class="id">inv</span> <span class="id">H3</span>. <span class="id">exploit</span> <span class="id">eval_addressing_Ainstack_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">E1</span> <span class="id">E2</span>].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">E2</span>; <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span> <span class="kwd">in</span> <span class="id">E2</span>. <span class="tactic">subst</span> <span class="id">a</span>.    <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eq_holds_strict</span>. <span class="id">econstructor</span>. <span class="tactic">rewrite</span> <span class="id">eval_addressing_Ainstack</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">LD</span>; <span class="tactic">auto</span>.<br/>
+ <span class="id">inv</span> <span class="id">H4</span>. <span class="id">exploit</span> <span class="id">eval_addressing_Ainstack_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">E1</span> <span class="id">E2</span>].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">E2</span>; <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span> <span class="kwd">in</span> <span class="id">E2</span>. <span class="tactic">subst</span> <span class="id">a</span>.    <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eq_holds_lessdef</span> <span class="kwd">with</span> <span class="id">v</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">rewrite</span> <span class="id">eval_addressing_Ainstack</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">LD</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_memcpy_eqs_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>' <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">eqs2</span> <span class="id">eqs1</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">e</span>' (<span class="id">add_memcpy_eqs</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">eqs1</span> <span class="id">eqs2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">e</span>' <span class="id">eqs2</span> \/ <span class="id">exists</span> <span class="id">e</span>, <span class="id">In</span> <span class="id">e</span> <span class="id">eqs1</span> /\ <span class="id">shift_memcpy_eq</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">e</span> = <span class="id">Some</span> <span class="id">e</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3174')">Proof.</div>
<div class="proofscript" id="proof3174">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">eqs1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">shift_memcpy_eq</span> <span class="id">src</span> <span class="id">sz</span> <span class="id">delta</span> <span class="id">a</span>) <span class="kwd">as</span> [<span class="id">e</span>''|] <span class="id">eqn</span>:<span class="id">SHIFT</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">subst</span> <span class="id">e</span>''. <span class="id">right</span>; <span class="id">exists</span> <span class="id">a</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHeqs1</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">e</span> [<span class="id">A</span> <span class="id">B</span>]]]; <span class="tactic">auto</span>. <span class="id">right</span>; <span class="id">exists</span> <span class="id">e</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">IHeqs1</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">e</span> [<span class="id">A</span> <span class="id">B</span>]]]; <span class="tactic">auto</span>. <span class="id">right</span>; <span class="id">exists</span> <span class="id">e</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_memcpy_holds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">bsrc</span> <span class="id">osrc</span> <span class="id">sz</span> <span class="id">bytes</span> <span class="id">bdst</span> <span class="id">odst</span> <span class="id">m</span>' <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">n1</span> <span class="id">n2</span> <span class="id">bc</span> <span class="id">asrc</span> <span class="id">adst</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.loadbytes</span> <span class="id">m</span> <span class="id">bsrc</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">osrc</span>) <span class="id">sz</span> = <span class="id">Some</span> <span class="id">bytes</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.storebytes</span> <span class="id">m</span> <span class="id">bdst</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">odst</span>) <span class="id">bytes</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span> <span class="id">n1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span>' <span class="id">n2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">bsrc</span> <span class="id">osrc</span> <span class="id">asrc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">bdst</span> <span class="id">odst</span> <span class="id">adst</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> (<span class="id">num_next</span> <span class="id">n1</span>) (<span class="id">num_next</span> <span class="id">n2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">rs</span> <span class="id">m</span>' (<span class="id">add_memcpy</span> <span class="id">n1</span> <span class="id">n2</span> <span class="id">asrc</span> <span class="id">adst</span> <span class="id">sz</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3175')">Proof.</div>
<div class="proofscript" id="proof3175">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">add_memcpy</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">asrc</span>; <span class="tactic">auto</span>; <span class="tactic">destruct</span> <span class="id">adst</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">o</span> <span class="id">i</span>, <span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">o</span> (<span class="id">Stk</span> <span class="id">i</span>) -&gt; <span class="id">b</span> = <span class="id">sp</span> /\ <span class="id">i</span> = <span class="id">o</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H7</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">A</span> <span class="kwd">in</span> <span class="id">H3</span>; <span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">subst</span> <span class="id">bsrc</span> <span class="id">ofs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">A</span> <span class="kwd">in</span> <span class="id">H4</span>; <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">subst</span> <span class="id">bdst</span> <span class="id">ofs0</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">add_memcpy_eqs_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> | (<span class="id">e0</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span>)].<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wf_equation_incr</span> <span class="kwd">with</span> (<span class="id">num_next</span> <span class="id">n1</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">shift_memcpy_eq_wf</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
- <span class="id">exploit</span> <span class="id">add_memcpy_eqs_charact</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> | (<span class="id">e0</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span>)].<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">shift_memcpy_eq_holds</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Correctness of operator reduction </div>
<br/>
<span class="kwd">Section</span> <span class="id">REDUCE</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">A</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: (<span class="id">valnum</span> -&gt; <span class="id">option</span> <span class="id">rhs</span>) -&gt; <span class="id">A</span> -&gt; <span class="id">list</span> <span class="id">valnum</span> -&gt; <span class="id">option</span> (<span class="id">A</span> * <span class="id">list</span> <span class="id">valnum</span>).<br/>
<span class="kwd">Variable</span> <span class="id">V</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rs</span>: <span class="id">regset</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sem</span>: <span class="id">A</span> -&gt; <span class="id">list</span> <span class="id">val</span> -&gt; <span class="id">option</span> <span class="id">V</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">f_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">eqs</span> <span class="id">valu</span> <span class="id">op</span> <span class="id">args</span> <span class="id">op</span>' <span class="id">args</span>',<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">v</span> <span class="id">rhs</span>, <span class="id">eqs</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">rhs</span> -&gt; <span class="id">rhs_eval_to</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">m</span> <span class="id">rhs</span> (<span class="id">valu</span> <span class="id">v</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> <span class="id">eqs</span> <span class="id">op</span> <span class="id">args</span> = <span class="id">Some</span>(<span class="id">op</span>', <span class="id">args</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">op</span>' (<span class="id">map</span> <span class="id">valu</span> <span class="id">args</span>') = <span class="id">sem</span> <span class="id">op</span> (<span class="id">map</span> <span class="id">valu</span> <span class="id">args</span>).<br/>
<span class="kwd">Variable</span> <span class="id">n</span>: <span class="id">numbering</span>.<br/>
<span class="kwd">Variable</span> <span class="id">valu</span>: <span class="id">valnum</span> -&gt; <span class="id">val</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">n_holds</span>: <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">n</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">reduce_rec_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">niter</span> <span class="id">op</span> <span class="id">args</span> <span class="id">op</span>' <span class="id">rl</span>' <span class="id">res</span>,<br/>
&nbsp;&nbsp;<span class="id">reduce_rec</span> <span class="id">A</span> <span class="id">f</span> <span class="id">n</span> <span class="id">niter</span> <span class="id">op</span> <span class="id">args</span> = <span class="id">Some</span>(<span class="id">op</span>', <span class="id">rl</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">op</span> (<span class="id">map</span> <span class="id">valu</span> <span class="id">args</span>) = <span class="id">Some</span> <span class="id">res</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">op</span>' (<span class="id">rs</span>##<span class="id">rl</span>') = <span class="id">Some</span> <span class="id">res</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3176')">Proof.</div>
<div class="proofscript" id="proof3176">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">niter</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span> (<span class="kwd">fun</span> <span class="id">v</span> : <span class="id">valnum</span> =&gt; <span class="id">find_valnum_num</span> <span class="id">v</span> (<span class="id">num_eqs</span> <span class="id">n</span>)) <span class="id">op</span> <span class="id">args</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">as</span> [[<span class="id">op1</span> <span class="id">args1</span>] | ] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">sem</span> <span class="id">op1</span> (<span class="id">map</span> <span class="id">valu</span> <span class="id">args1</span>) = <span class="id">Some</span> <span class="id">res</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">f_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">num_holds_eq</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_valnum_num_charact</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">EH</span>; <span class="id">inv</span> <span class="id">EH</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce_rec</span> <span class="id">A</span> <span class="id">f</span> <span class="id">n</span> <span class="id">niter</span> <span class="id">op1</span> <span class="id">args1</span>) <span class="kwd">as</span> [[<span class="id">op2</span> <span class="id">rl2</span>] | ] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">IHniter</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">regs_valnums</span> <span class="id">n</span> <span class="id">args1</span>) <span class="kwd">as</span> [<span class="id">rl</span>|] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">erewrite</span> <span class="id">regs_valnums_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">reduce_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">rl</span> <span class="id">vl</span> <span class="id">op</span>' <span class="id">rl</span>' <span class="id">res</span>,<br/>
&nbsp;&nbsp;<span class="id">reduce</span> <span class="id">A</span> <span class="id">f</span> <span class="id">n</span> <span class="id">op</span> <span class="id">rl</span> <span class="id">vl</span> = (<span class="id">op</span>', <span class="id">rl</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">map</span> <span class="id">valu</span> <span class="id">vl</span> = <span class="id">rs</span>##<span class="id">rl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">op</span> <span class="id">rs</span>##<span class="id">rl</span> = <span class="id">Some</span> <span class="id">res</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">op</span>' <span class="id">rs</span>##<span class="id">rl</span>' = <span class="id">Some</span> <span class="id">res</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3177')">Proof.</div>
<div class="proofscript" id="proof3177">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">reduce</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce_rec</span> <span class="id">A</span> <span class="id">f</span> <span class="id">n</span> 4%<span class="id">nat</span> <span class="id">op</span> <span class="id">vl</span>) <span class="kwd">as</span> [[<span class="id">op1</span> <span class="id">rl1</span>] | ] <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">reduce_rec_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">REDUCE</span>.<br/>
<br/>
<div class="doc">The numberings associated to each instruction by the static analysis
  are inductively satisfiable, in the following sense: the numbering
  at the function entry point is satisfiable, and for any RTL execution
  from <span class="bracket"><span class="id">pc</span></span> to <span class="bracket"><span class="id">pc</span>'</span>, satisfiability at <span class="bracket"><span class="id">pc</span></span> implies
  satisfiability at <span class="bracket"><span class="id">pc</span>'</span>. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">analysis_correct_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">f</span> <span class="id">vapprox</span> <span class="id">approx</span> <span class="id">pc</span> <span class="id">pc</span>' <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">analyze</span> <span class="id">f</span> <span class="id">vapprox</span> = <span class="id">Some</span> <span class="id">approx</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span> -&gt; <span class="id">In</span> <span class="id">pc</span>' (<span class="id">successors_instr</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> (<span class="id">transfer</span> <span class="id">f</span> <span class="id">vapprox</span> <span class="id">pc</span> <span class="id">approx</span>!!<span class="id">pc</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">approx</span>!!<span class="id">pc</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3178')">Proof.</div>
<div class="proofscript" id="proof3178">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Numbering.ge</span> <span class="id">approx</span>!!<span class="id">pc</span>' (<span class="id">transfer</span> <span class="id">f</span> <span class="id">vapprox</span> <span class="id">pc</span> <span class="id">approx</span>!!<span class="id">pc</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Solver.fixpoint_solution</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [<span class="id">valu</span> <span class="id">NH</span>]. <span class="id">exists</span> <span class="id">valu</span>; <span class="tactic">apply</span> <span class="id">H3</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">analysis_correct_entry</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">f</span> <span class="id">vapprox</span> <span class="id">approx</span>,<br/>
&nbsp;&nbsp;<span class="id">analyze</span> <span class="id">f</span> <span class="id">vapprox</span> = <span class="id">Some</span> <span class="id">approx</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">approx</span>!!(<span class="id">f</span>.(<span class="id">fn_entrypoint</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3179')">Proof.</div>
<div class="proofscript" id="proof3179">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">approx</span>!!(<span class="id">f</span>.(<span class="id">fn_entrypoint</span>))) <span class="kwd">with</span> <span class="id">Solver.L.top</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">Vundef</span>). <span class="tactic">apply</span> <span class="id">empty_numbering_holds</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">Solver.fixpoint_entry</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Semantic preservation </h1>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span> : <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">f</span>: <span class="id">RTL.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">cu</span> <span class="id">tf</span>, <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> /\ <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">funct_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">f</span>: <span class="id">RTL.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">cu</span> <span class="id">tf</span>, <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> /\ <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rm</span> <span class="id">f</span> <span class="id">tf</span>, <span class="id">transf_fundef</span> <span class="id">rm</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt; <span class="id">funsig</span> <span class="id">tf</span> = <span class="id">funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3180')">Proof.</div>
<div class="proofscript" id="proof3180">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_fundef</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">f</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">analyze</span> <span class="id">f</span> (<span class="id">vanalyze</span> <span class="id">rm</span> <span class="id">f</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="id">inv</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">transf_function</span>' (<span class="id">f</span>: <span class="id">function</span>) (<span class="id">approxs</span>: <span class="id">PMap.t</span> <span class="id">numbering</span>) : <span class="id">function</span> :=<br/>
&nbsp;&nbsp;<span class="id">mkfunction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_sig</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_params</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">transf_code</span> <span class="id">approxs</span> <span class="id">f</span>.(<span class="id">fn_code</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_entrypoint</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">regs_lessdef</span> (<span class="id">rs1</span> <span class="id">rs2</span>: <span class="id">regset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.lessdef</span> (<span class="id">rs1</span>#<span class="id">r</span>) (<span class="id">rs2</span>#<span class="id">r</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">regs_lessdef_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs1</span> <span class="id">rs2</span>, <span class="id">regs_lessdef</span> <span class="id">rs1</span> <span class="id">rs2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rl</span>, <span class="id">Val.lessdef_list</span> <span class="id">rs1</span>##<span class="id">rl</span> <span class="id">rs2</span>##<span class="id">rl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3181')">Proof.</div>
<div class="proofscript" id="proof3181">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_reg_lessdef</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">rs1</span> <span class="id">rs2</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v1</span> <span class="id">v2</span> -&gt; <span class="id">regs_lessdef</span> <span class="id">rs1</span> <span class="id">rs2</span> -&gt; <span class="id">regs_lessdef</span> (<span class="id">rs1</span>#<span class="id">r</span> &lt;- <span class="id">v1</span>) (<span class="id">rs2</span>#<span class="id">r</span> &lt;- <span class="id">v2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3182')">Proof.</div>
<div class="proofscript" id="proof3182">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Regmap.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">init_regs_lessdef</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rl</span> <span class="id">vl1</span> <span class="id">vl2</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vl1</span> <span class="id">vl2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">regs_lessdef</span> (<span class="id">init_regs</span> <span class="id">vl1</span> <span class="id">rl</span>) (<span class="id">init_regs</span> <span class="id">vl2</span> <span class="id">rl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3183')">Proof.</div>
<div class="proofscript" id="proof3183">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ros</span> <span class="id">rs</span> <span class="id">fd</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">rs</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">cu</span> <span class="id">tfd</span>, <span class="id">find_function</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">rs</span>' = <span class="id">Some</span> <span class="id">tfd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">fd</span> = <span class="id">OK</span> <span class="id">tfd</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3184')">Proof.</div>
<div class="proofscript" id="proof3184">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">find_function</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">ros</span>.<br/>
- <span class="id">specialize</span> (<span class="id">H0</span> <span class="id">r</span>). <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functions_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">funct_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The proof of semantic preservation is a simulation argument using
  diagrams of the following form:
<pre>
           st1 --------------- st2
            |                   |
           t|                   |t
            |                   |
            v                   v
           st1'--------------- st2'</pre>
  Left: RTL execution in the original program.  Right: RTL execution in
  the optimized program.  Precondition (top) and postcondition (bottom):
  agreement between the states, including the fact that
  the numbering at <span class="bracket"><span class="id">pc</span></span> (returned by the static analysis) is satisfiable.
</div>
<br/>
<span class="kwd">Definition</span> <span class="id">analyze</span> (<span class="id">cu</span>: <span class="id">program</span>) (<span class="id">f</span>: <span class="id">function</span>) :=<br/>
&nbsp;&nbsp;<span class="id">CSE.analyze</span> <span class="id">f</span> (<span class="id">vanalyze</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">f</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stackframes</span>: <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">nil</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_cons</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">res</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">f</span> <span class="id">s</span> <span class="id">rs</span>' <span class="id">s</span>' <span class="id">cu</span> <span class="id">approx</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ANALYZE</span>: <span class="id">analyze</span> <span class="id">cu</span> <span class="id">f</span> = <span class="id">Some</span> <span class="id">approx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SAT</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">m</span>, <span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">rs</span>#<span class="id">res</span> &lt;- <span class="id">v</span>) <span class="id">m</span> <span class="id">approx</span>!!<span class="id">pc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RLD</span>: <span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> :: <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> (<span class="id">transf_function</span>' <span class="id">f</span> <span class="id">approx</span>) <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span>' :: <span class="id">s</span>').<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">rs</span>' <span class="id">m</span>' <span class="id">f</span> <span class="id">cu</span> <span class="id">approx</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ANALYZE</span>: <span class="id">analyze</span> <span class="id">cu</span> <span class="id">f</span> = <span class="id">Some</span> <span class="id">approx</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SAT</span>: <span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">approx</span>!!<span class="id">pc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RLD</span>: <span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span>' <span class="id">f</span> <span class="id">approx</span>) <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">args</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">args</span>' <span class="id">m</span>' <span class="id">cu</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TFD</span>: <span class="id">transf_fundef</span> (<span class="id">romem_for</span> <span class="id">cu</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="id">Val.lessdef_list</span> <span class="id">args</span> <span class="id">args</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">args</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">s</span>' <span class="id">tf</span> <span class="id">args</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">s</span>' <span class="id">v</span> <span class="id">v</span>' <span class="id">m</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACK</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RES</span>: <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">v</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Returnstate</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">s</span>' <span class="id">v</span>' <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">TransfInstr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H1</span>: (<span class="id">PTree.get</span> ?<span class="id">pc</span> ?<span class="id">c</span> = <span class="id">Some</span> ?<span class="id">instr</span>), <span class="id">f</span>: <span class="id">function</span>, <span class="id">approx</span>: <span class="id">PMap.t</span> <span class="id">numbering</span> |- <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> ((<span class="id">transf_function</span>' <span class="id">f</span> <span class="id">approx</span>).(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span>(<span class="id">transf_instr</span> <span class="id">approx</span>!!<span class="id">pc</span> <span class="id">instr</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="tactic">simpl</span> <span class="id">transf_instr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="tactic">unfold</span> <span class="id">transf_function</span>', <span class="id">transf_code</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">PTree.gmap</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">option_map</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">reflexivity</span> ]<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The proof of simulation is a case analysis over the transition
  in the source code. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span>, <span class="id">step</span> <span class="id">ge</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">s1</span> <span class="id">s1</span>') (<span class="id">SOUND</span>: <span class="id">sound_state</span> <span class="id">prog</span> <span class="id">s1</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">s2</span>', <span class="id">step</span> <span class="id">tge</span> <span class="id">s1</span>' <span class="id">t</span> <span class="id">s2</span>' /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s2</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3185')">Proof.</div>
<div class="proofscript" id="proof3185">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">MS</span>; <span class="tactic">try</span> (<span class="id">TransfInstr</span>; <span class="tactic">intro</span> <span class="id">C</span>).<br/>
<br/>
&nbsp;Inop&nbsp;*)</span>- <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Inop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;Iop&nbsp;*)</span>- <span class="tactic">destruct</span> (<span class="id">is_trivial_op</span> <span class="id">op</span>) <span class="id">eqn</span>:<span class="id">TRIV</span>.<br/>
+ <span class="comment">(*&nbsp;unchanged&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_operation_lessdef</span>. <span class="tactic">eapply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAT</span> <span class="kwd">as</span> [<span class="id">valu</span> <span class="id">NH</span>]. <span class="tactic">eapply</span> <span class="id">add_op_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;possibly&nbsp;optimized&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">approx</span>!!<span class="id">pc</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAT</span> <span class="kwd">as</span> [<span class="id">valu1</span> <span class="id">NH1</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">NH2</span> &amp; <span class="id">EQ</span> &amp; <span class="id">AG</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_rhs</span> <span class="id">n1</span> (<span class="id">Op</span> <span class="id">op</span> <span class="id">vl</span>)) <span class="kwd">as</span> [<span class="id">r</span>|] <span class="id">eqn</span>:?.<br/>
* <span class="comment">(*&nbsp;replaced&nbsp;by&nbsp;move&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_rhs_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">EV</span> &amp; <span class="id">LD</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">v</span>' = <span class="id">v</span>) <span class="tactic">by</span> (<span class="id">inv</span> <span class="id">EV</span>; <span class="tactic">congruence</span>). <span class="tactic">subst</span> <span class="id">v</span>'.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_op_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Val.lessdef_trans</span>; <span class="tactic">eauto</span>.<br/>
* <span class="comment">(*&nbsp;possibly&nbsp;simplified&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce</span> <span class="id">operation</span> <span class="id">combine_op</span> <span class="id">n1</span> <span class="id">op</span> <span class="id">args</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">op</span>' <span class="id">args</span>'] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RES</span>: <span class="id">eval_operation</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">op</span>' <span class="id">rs</span>##<span class="id">args</span>' <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">reduce_sound</span> <span class="kwd">with</span> (<span class="id">sem</span> := <span class="kwd">fun</span> <span class="id">op</span> <span class="id">vl</span> =&gt; <span class="id">eval_operation</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">op</span> <span class="id">vl</span> <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">combine_op_sound</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_operation_lessdef</span>. <span class="tactic">eapply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>'); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_op_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Iload&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">approx</span>!!<span class="id">pc</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAT</span> <span class="kwd">as</span> [<span class="id">valu1</span> <span class="id">NH1</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">NH2</span> &amp; <span class="id">EQ</span> &amp; <span class="id">AG</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_rhs</span> <span class="id">n1</span> (<span class="kwd">Load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">vl</span>)) <span class="kwd">as</span> [<span class="id">r</span>|] <span class="id">eqn</span>:?.<br/>
+ <span class="comment">(*&nbsp;replaced&nbsp;by&nbsp;move&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_rhs_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">EV</span> &amp; <span class="id">LD</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">v</span>' = <span class="id">v</span>) <span class="tactic">by</span> (<span class="id">inv</span> <span class="id">EV</span>; <span class="tactic">congruence</span>). <span class="tactic">subst</span> <span class="id">v</span>'.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_load_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Val.lessdef_trans</span>; <span class="tactic">eauto</span>.<br/>
+ <span class="comment">(*&nbsp;load&nbsp;is&nbsp;preserved,&nbsp;but&nbsp;addressing&nbsp;is&nbsp;possibly&nbsp;simplified&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce</span> <span class="id">addressing</span> <span class="id">combine_addr</span> <span class="id">n1</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">addr</span>' <span class="id">args</span>'] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ADDR</span>: <span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span>' <span class="id">rs</span>##<span class="id">args</span>' = <span class="id">Some</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">reduce_sound</span> <span class="kwd">with</span> (<span class="id">sem</span> := <span class="kwd">fun</span> <span class="id">addr</span> <span class="id">vl</span> =&gt; <span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">vl</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">combine_addr_sound</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">ADDR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ADDR</span>': <span class="id">eval_addressing</span> <span class="id">tge</span> <span class="id">sp</span> <span class="id">addr</span>' <span class="id">rs</span>'##<span class="id">args</span>' = <span class="id">Some</span> <span class="id">a</span>').<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">X</span> <span class="id">Y</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iload</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_load_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Istore&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">approx</span>!!<span class="id">pc</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAT</span> <span class="kwd">as</span> [<span class="id">valu1</span> <span class="id">NH1</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">NH2</span> &amp; <span class="id">EQ</span> &amp; <span class="id">AG</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce</span> <span class="id">addressing</span> <span class="id">combine_addr</span> <span class="id">n1</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">addr</span>' <span class="id">args</span>'] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ADDR</span>: <span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span>' <span class="id">rs</span>##<span class="id">args</span>' = <span class="id">Some</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">reduce_sound</span> <span class="kwd">with</span> (<span class="id">sem</span> := <span class="kwd">fun</span> <span class="id">addr</span> <span class="id">vl</span> =&gt; <span class="id">eval_addressing</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">vl</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">combine_addr_sound</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">ADDR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ADDR</span>': <span class="id">eval_addressing</span> <span class="id">tge</span> <span class="id">sp</span> <span class="id">addr</span>' <span class="id">rs</span>'##<span class="id">args</span>' = <span class="id">Some</span> <span class="id">a</span>').<br/>
&nbsp;&nbsp;{ <span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m</span>'' [<span class="id">X</span> <span class="id">Y</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Istore</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">InvSoundState</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_store_result_hold</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">kill_loads_after_store_holds</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Icall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">cu</span>' &amp; <span class="id">tf</span> &amp; <span class="id">FIND</span>' &amp; <span class="id">TRANSF</span>' &amp; <span class="id">LINK</span>').<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stackframes_cons</span> <span class="kwd">with</span> (<span class="id">cu</span> := <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">Vundef</span>); <span class="tactic">apply</span> <span class="id">empty_numbering_holds</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Itailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">cu</span>' &amp; <span class="id">tf</span> &amp; <span class="id">FIND</span>' &amp; <span class="id">TRANSF</span>' &amp; <span class="id">LINK</span>').<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m</span>'' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Ibuiltin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">eval_builtin_args_lessdef</span> <span class="id">_</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">vargs</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">m1</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span> &amp; <span class="id">S</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ibuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
* <span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAT</span> <span class="kwd">as</span> [<span class="id">valu</span> <span class="id">NH</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE1</span>: <span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">vres</span> <span class="id">rs</span>) <span class="id">m</span>' <span class="id">empty_numbering</span>).<br/>
&nbsp;&nbsp;{ <span class="id">exists</span> <span class="id">valu</span>; <span class="tactic">apply</span> <span class="id">empty_numbering_holds</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE2</span>: <span class="id">m</span>' = <span class="id">m</span> -&gt; <span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">vres</span> <span class="id">rs</span>) <span class="id">m</span>' (<span class="id">set_res_unknown</span> <span class="id">approx</span>#<span class="id">pc</span> <span class="id">res</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">m</span>'. <span class="id">exists</span> <span class="id">valu</span>. <span class="tactic">apply</span> <span class="id">set_res_unknown_holds</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE3</span>: <span class="id">exists</span> <span class="id">valu</span>, <span class="id">numbering_holds</span> <span class="id">valu</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">vres</span> <span class="id">rs</span>) <span class="id">m</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">set_res_unknown</span> (<span class="id">kill_all_loads</span> <span class="id">approx</span>#<span class="id">pc</span>) <span class="id">res</span>)).<br/>
&nbsp;&nbsp;{ <span class="id">exists</span> <span class="id">valu</span>. <span class="tactic">apply</span> <span class="id">set_res_unknown_holds</span>. <span class="tactic">eapply</span> <span class="id">kill_all_loads_hold</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ef</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE1</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE3</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE1</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE2</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE3</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE1</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE1</span>.<br/>
&nbsp;&nbsp;+ <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">valu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_res_unknown_holds</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">InvSoundState</span>. <span class="tactic">unfold</span> <span class="id">vanalyze</span>; <span class="tactic">rewrite</span> <span class="id">AN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">bsrc</span> <span class="id">osrc</span> (<span class="id">aaddr_arg</span> (<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span>) <span class="id">a0</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">aaddr_arg_sound_1</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">bdst</span> <span class="id">odst</span> (<span class="id">aaddr_arg</span> (<span class="id">VA.State</span> <span class="id">ae</span> <span class="id">am</span>) <span class="id">a1</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">aaddr_arg_sound_1</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_memcpy_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">kill_loads_after_storebytes_holds</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.loadbytes_length</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE2</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE2</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE1</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">CASE2</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
* <span class="tactic">apply</span> <span class="id">set_res_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Icond&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">valnum_regs</span> <span class="id">approx</span>!!<span class="id">pc</span> <span class="id">args</span>) <span class="kwd">as</span> [<span class="id">n1</span> <span class="id">vl</span>] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">SAT</span>; <span class="tactic">intros</span> <span class="id">valu1</span> <span class="id">NH1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">valnum_regs_holds</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">valu2</span> &amp; <span class="id">NH2</span> &amp; <span class="id">EQ</span> &amp; <span class="id">AG</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reduce</span> <span class="id">condition</span> <span class="id">combine_cond</span> <span class="id">n1</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">vl</span>) <span class="kwd">as</span> [<span class="id">cond</span>' <span class="id">args</span>'] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RES</span>: <span class="id">eval_condition</span> <span class="id">cond</span>' <span class="id">rs</span>##<span class="id">args</span>' <span class="id">m</span> = <span class="id">Some</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">reduce_sound</span> <span class="kwd">with</span> (<span class="id">sem</span> := <span class="kwd">fun</span> <span class="id">cond</span> <span class="id">vl</span> =&gt; <span class="id">eval_condition</span> <span class="id">cond</span> <span class="id">vl</span> <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">combine_cond_sound</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icond</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_condition_lessdef</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Ijumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">RLD</span> <span class="id">arg</span>); <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">intro</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ijumptable</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_1</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">list_nth_z_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transfer</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Ireturn&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m</span>'' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ireturn</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">or</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TFD</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> <span class="id">EQ</span>. <span class="id">fold</span> (<span class="id">analyze</span> <span class="id">cu</span> <span class="id">f</span>) <span class="kwd">in</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">analyze</span> <span class="id">cu</span> <span class="id">f</span>) <span class="kwd">as</span> [<span class="id">approx</span>|] <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">m</span>'' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">analysis_correct_entry</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">init_regs_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TFD</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">m1</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span> &amp; <span class="id">S</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_return</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3186')">Proof.</div>
<div class="proofscript" id="proof3186">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">funct_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">cu</span> &amp; <span class="id">tf</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">nil</span> <span class="id">tf</span> <span class="id">nil</span> <span class="id">m0</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> (<span class="id">Genv.init_mem_match</span> <span class="id">TRANSF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="kwd">with</span> (<span class="id">prog_main</span> <span class="id">prog</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">match_program_main</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>. <span class="tactic">eapply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Mem.extends_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3187')">Proof.</div>
<div class="proofscript" id="proof3187">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">RES</span>. <span class="id">inv</span> <span class="id">STACK</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">RTL.semantics</span> <span class="id">prog</span>) (<span class="id">RTL.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3188')">Proof.</div>
<div class="proofscript" id="proof3188">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_step</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">match_states</span> := <span class="kwd">fun</span> <span class="id">s1</span> <span class="id">s2</span> =&gt; <span class="id">sound_state</span> <span class="id">prog</span> <span class="id">s1</span> /\ <span class="id">match_states</span> <span class="id">s1</span> <span class="id">s2</span>).<br/>
- <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
- <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">transf_initial_states</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">s2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">s2</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">sound_initial</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">transf_final_states</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">exploit</span> <span class="id">transf_step_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">s2</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">s2</span>'; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">sound_step</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
