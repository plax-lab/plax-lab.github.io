<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Asmgenproof</title>
<meta name="description" content="Documentation of Coq module Asmgenproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Asmgenproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for x86-64 generation: main proof. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">Floats</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Locations</span> <span class="id">Mach</span> <span class="id">Conventions</span> <span class="id">Asm</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Asmgen</span> <span class="id">Asmgenproof0</span> <span class="id">Asmgenproof1</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">Mach.program</span>) (<span class="id">tp</span>: <span class="id">Asm.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transf_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3932')">Proof.</div>
<div class="proofscript" id="proof3932">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_transform_partial_program</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Asm.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_transl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fb</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">tf</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3933')">Proof.</div>
<div class="proofscript" id="proof3933">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">B</span>. <span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">EQ</span>; <span class="id">inv</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Properties of control flow </h1>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_function_no_overflow</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt; <span class="id">list_length_z</span> (<span class="id">fn_code</span> <span class="id">tf</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3934')">Proof.</div>
<div class="proofscript" id="proof3934">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">list_length_z</span> (<span class="id">fn_code</span> <span class="id">x</span>))); <span class="id">monadInv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_straight_exec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">c</span>' <span class="id">rs</span> <span class="id">m</span> <span class="id">rs</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs</span> <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_straight</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">c</span>' <span class="id">rs</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">rs</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">rs</span>' <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3935')">Proof.</div>
<div class="proofscript" id="proof3935">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_steps_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_function_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_straight_at</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">c</span>' <span class="id">ep</span>' <span class="id">tc</span>' <span class="id">rs</span> <span class="id">m</span> <span class="id">rs</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs</span> <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_code</span> <span class="id">f</span> <span class="id">c</span>' <span class="id">ep</span>' = <span class="id">OK</span> <span class="id">tc</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_straight</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">tc</span>' <span class="id">rs</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs</span>' <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span>' <span class="id">ep</span>' <span class="id">tf</span> <span class="id">tc</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3936')">Proof.</div>
<div class="proofscript" id="proof3936">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">exec_straight_steps_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_function_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ofs</span>' [<span class="id">PC</span>' <span class="id">CT</span>']].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PC</span>'. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The following lemmas show that the translation from Mach to Asm
  preserves labels, in the sense that the following diagram commutes:
<pre>
                          translation
        Mach code ------------------------ Asm instr sequence
            |                                          |
            | Mach.find_label lbl       find_label lbl |
            |                                          |
            v                                          v
        Mach code tail ------------------- Asm instr seq tail
                          translation</pre>
  The proof demands many boring lemmas showing that Asm constructor
  functions do not introduce new labels.
  In passing, we also prove a "is tail" property of the generated Asm code.
</div>
<br/>
<span class="kwd">Section</span> <span class="id">TRANSL_LABEL</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_mov_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rd</span> <span class="id">rs</span> <span class="id">k</span> <span class="id">c</span>, <span class="id">mk_mov</span> <span class="id">rd</span> <span class="id">rs</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt; <span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3937')">Proof.</div>
<div class="proofscript" id="proof3937">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mk_mov</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">rd</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> <span class="id">rs</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">mk_mov_label</span>: <span class="id">labels</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_shrximm_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">k</span> <span class="id">c</span>, <span class="id">mk_shrximm</span> <span class="id">n</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt; <span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3938')">Proof.</div>
<div class="proofscript" id="proof3938">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">mk_shrximm_label</span>: <span class="id">labels</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_shrxlimm_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">k</span> <span class="id">c</span>, <span class="id">mk_shrxlimm</span> <span class="id">n</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt; <span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3939')">Proof.</div>
<div class="proofscript" id="proof3939">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span>); <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">mk_shrxlimm_label</span>: <span class="id">labels</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_intconv_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">r1</span> <span class="id">r2</span> <span class="id">k</span> <span class="id">c</span>, <span class="id">mk_intconv</span> <span class="id">f</span> <span class="id">r1</span> <span class="id">r2</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span> <span class="id">r</span>', <span class="id">nolabel</span> (<span class="id">f</span> <span class="id">r</span> <span class="id">r</span>')) -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3940')">Proof.</div>
<div class="proofscript" id="proof3940">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mk_intconv</span>; <span class="tactic">intros</span>. <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">mk_intconv_label</span>: <span class="id">labels</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_storebyte_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">addr</span> <span class="id">r</span> <span class="id">k</span> <span class="id">c</span>, <span class="id">mk_storebyte</span> <span class="id">addr</span> <span class="id">r</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt; <span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3941')">Proof.</div>
<div class="proofscript" id="proof3941">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mk_storebyte</span>; <span class="tactic">intros</span>. <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">mk_storebyte_label</span>: <span class="id">labels</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">loadind_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">base</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">dst</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">loadind</span> <span class="id">base</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">dst</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3942')">Proof.</div>
<div class="proofscript" id="proof3942">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">loadind</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> (<span class="id">preg_of</span> <span class="id">dst</span>); <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">storeind_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">base</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">src</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">storeind</span> <span class="id">src</span> <span class="id">base</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3943')">Proof.</div>
<div class="proofscript" id="proof3943">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">storeind</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> (<span class="id">preg_of</span> <span class="id">src</span>); <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_setcc_base_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xc</span> <span class="id">rd</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> (<span class="id">mk_setcc_base</span> <span class="id">xc</span> <span class="id">rd</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3944')">Proof.</div>
<div class="proofscript" id="proof3944">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">xc</span>; <span class="tactic">simpl</span>; <span class="tactic">destruct</span> (<span class="id">ireg_eq</span> <span class="id">rd</span> <span class="id">RAX</span>); <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_setcc_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xc</span> <span class="id">rd</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> (<span class="id">mk_setcc</span> <span class="id">xc</span> <span class="id">rd</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3945')">Proof.</div>
<div class="proofscript" id="proof3945">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">mk_setcc</span>. <span class="tactic">destruct</span> (<span class="id">Archi.ptr64</span> || <span class="id">low_ireg</span> <span class="id">rd</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mk_setcc_base_label</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">tail_nolabel_trans</span>. <span class="tactic">apply</span> <span class="id">mk_setcc_base_label</span>. <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">mk_jcc_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xc</span> <span class="id">lbl</span>' <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> (<span class="id">mk_jcc</span> <span class="id">xc</span> <span class="id">lbl</span>' <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3946')">Proof.</div>
<div class="proofscript" id="proof3946">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">xc</span>; <span class="tactic">simpl</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_cond_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_cond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3947')">Proof.</div>
<div class="proofscript" id="proof3947">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_cond</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cond</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq_dec</span> <span class="id">n</span> <span class="id">Int.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq_dec</span> <span class="id">n</span> <span class="id">Int64.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">c0</span>; <span class="tactic">simpl</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">c0</span>; <span class="tactic">simpl</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">c0</span>; <span class="tactic">simpl</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">c0</span>; <span class="tactic">simpl</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_op_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">args</span> <span class="id">r</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_op</span> <span class="id">op</span> <span class="id">args</span> <span class="id">r</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3948')">Proof.</div>
<div class="proofscript" id="proof3948">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_op</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">op</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq_dec</span> <span class="id">n</span> <span class="id">Int.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq_dec</span> <span class="id">n</span> <span class="id">Int64.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float.eq_dec</span> <span class="id">n</span> <span class="id">Float.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float32.eq_dec</span> <span class="id">n</span> <span class="id">Float32.zero</span>); <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">normalize_addrmode_64</span> <span class="id">x</span>) <span class="kwd">as</span> [<span class="id">am</span>' [<span class="id">delta</span>|]]; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">tail_nolabel_trans</span>. <span class="tactic">eapply</span> <span class="id">transl_cond_label</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mk_setcc_label</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_load_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="kwd">dest</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_load</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="kwd">dest</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3949')">Proof.</div>
<div class="proofscript" id="proof3949">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_store_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_store</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">args</span> <span class="id">src</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3950')">Proof.</div>
<div class="proofscript" id="proof3950">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="id">TailNoLabel</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_instr_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_instr</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">i</span> <span class="kwd">with</span> <span class="id">Mlabel</span> <span class="id">lbl</span> =&gt; <span class="id">c</span> = <span class="id">Plabel</span> <span class="id">lbl</span> :: <span class="id">k</span> | <span class="id">_</span> =&gt; <span class="id">tail_nolabel</span> <span class="id">k</span> <span class="id">c</span> <span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3951')">Proof.</div>
<div class="proofscript" id="proof3951">
<span class="id">Opaque</span> <span class="id">loadind</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_instr</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">i</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">loadind_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">storeind_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">loadind_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">tail_nolabel_trans</span>; <span class="tactic">eapply</span> <span class="id">loadind_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_op_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_load_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_store_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s0</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s0</span>; <span class="id">TailNoLabel</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">tail_nolabel_trans</span>. <span class="tactic">eapply</span> <span class="id">transl_cond_label</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">mk_jcc_label</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_instr_label</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_instr</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">c</span> = <span class="kwd">if</span> <span class="id">Mach.is_label</span> <span class="id">lbl</span> <span class="id">i</span> <span class="kwd">then</span> <span class="id">Some</span> <span class="id">k</span> <span class="kwd">else</span> <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3952')">Proof.</div>
<div class="proofscript" id="proof3952">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">transl_instr_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> (<span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]; <span class="tactic">apply</span> <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">c</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_code_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tc</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_code</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> = <span class="id">OK</span> <span class="id">tc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tc</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">c</span>' =&gt; <span class="id">exists</span> <span class="id">tc</span>', <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tc</span> = <span class="id">Some</span> <span class="id">tc</span>' /\ <span class="id">transl_code</span> <span class="id">f</span> <span class="id">c</span>' <span class="id">false</span> = <span class="id">OK</span> <span class="id">tc</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3953')">Proof.</div>
<div class="proofscript" id="proof3953">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> (<span class="id">transl_instr_label</span>' <span class="id">lbl</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Mach.is_label_correct</span> <span class="id">lbl</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mach.is_label</span> <span class="id">lbl</span> <span class="id">a</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">EQ</span>. <span class="id">exists</span> <span class="id">x</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHc</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">f</span>.(<span class="id">Mach.fn_code</span>) <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">c</span> =&gt; <span class="id">exists</span> <span class="id">tc</span>, <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) = <span class="id">Some</span> <span class="id">tc</span> /\ <span class="id">transl_code</span> <span class="id">f</span> <span class="id">c</span> <span class="id">false</span> = <span class="id">OK</span> <span class="id">tc</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3954')">Proof.</div>
<div class="proofscript" id="proof3954">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">list_length_z</span> (<span class="id">fn_code</span> <span class="id">x</span>))); <span class="id">inv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">transl_code_label</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">transl_code</span>'<span class="id">_transl_code</span> <span class="kwd">in</span> <span class="id">EQ0</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">TRANSL_LABEL</span>.<br/>
<br/>
<div class="doc">A valid branch in a piece of Mach code translates to a valid ``go to''
  transition in the generated PPC code. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_goto_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">lbl</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">c</span>' <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">rs</span> <span class="id">PC</span> = <span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">f</span>.(<span class="id">Mach.fn_code</span>) = <span class="id">Some</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tc</span>', <span class="id">exists</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">goto_label</span> <span class="id">tf</span> <span class="id">lbl</span> <span class="id">rs</span> <span class="id">m</span> = <span class="kwd">Next</span> <span class="id">rs</span>' <span class="id">m</span><br/>
&nbsp;&nbsp;/\ <span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs</span>' <span class="id">PC</span>) <span class="id">b</span> <span class="id">f</span> <span class="id">c</span>' <span class="id">false</span> <span class="id">tf</span> <span class="id">tc</span>'<br/>
&nbsp;&nbsp;/\ <span class="kwd">forall</span> <span class="id">r</span>, <span class="id">r</span> &lt;&gt; <span class="id">PC</span> -&gt; <span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3955')">Proof.</div>
<div class="proofscript" id="proof3955">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">lbl</span> <span class="id">f</span> <span class="id">tf</span>); <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tc</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">label_pos_code_tail</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := 0).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">pos</span>' [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tc</span>; <span class="id">exists</span> (<span class="id">rs</span>#<span class="id">PC</span> &lt;- (<span class="id">Vptr</span> <span class="id">b</span> (<span class="id">Ptrofs.repr</span> <span class="id">pos</span>'))).<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">unfold</span> <span class="id">goto_label</span>. <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_repr</span>. <span class="tactic">replace</span> (<span class="id">pos</span>' - 0) <span class="kwd">with</span> <span class="id">pos</span>' <span class="kwd">in</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">transf_function_no_overflow</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Pregmap.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Existence of return addresses </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">return_address_exists</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sg</span> <span class="id">ros</span> <span class="id">c</span>, <span class="id">is_tail</span> (<span class="id">Mcall</span> <span class="id">sg</span> <span class="id">ros</span> :: <span class="id">c</span>) <span class="id">f</span>.(<span class="id">Mach.fn_code</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ra</span>, <span class="id">return_address_offset</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ra</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3956')">Proof.</div>
<div class="proofscript" id="proof3956">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Asmgenproof0.return_address_exists</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">transl_instr_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> (<span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]; <span class="tactic">apply</span> <span class="id">A</span>). <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">c0</span>. <span class="tactic">repeat</span> <span class="id">constructor</span>.<br/>
- <span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">list_length_z</span> (<span class="id">fn_code</span> <span class="id">x</span>))); <span class="id">inv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ</span>. <span class="tactic">rewrite</span> <span class="id">transl_code</span>'<span class="id">_transl_code</span> <span class="kwd">in</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>; <span class="id">exists</span> <span class="id">true</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">unfold</span> <span class="id">fn_code</span>. <span class="tactic">repeat</span> <span class="id">constructor</span>.<br/>
- <span class="tactic">exact</span> <span class="id">transf_function_no_overflow</span>.<br/>
Qed.</div>
<br/>
<h1> Proof of semantic preservation </h1>
<br/>
<div class="doc">Semantic preservation is proved using simulation diagrams
  of the following form.
<pre>
           st1 --------------- st2
            |                   |
           t|                  *|t
            |                   |
            v                   v
           st1'--------------- st2'</pre>
  The invariant is the <span class="bracket"><span class="id">match_states</span></span> predicate below, which includes:
<ul>
<li>
 The PPC code pointed by the PC register is the translation of
  the current Mach code sequence.
</li>
<li>
 Mach register values and PPC register values agree.
</li>
</ul>
</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">Mach.state</span> -&gt; <span class="id">Asm.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">sp</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">ms</span> <span class="id">m</span> <span class="id">m</span>' <span class="id">rs</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">tc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stack</span> <span class="id">ge</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FIND</span>: <span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AT</span>: <span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs</span> <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AG</span>: <span class="id">agree</span> <span class="id">ms</span> <span class="id">sp</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AXP</span>: <span class="id">ep</span> = <span class="id">true</span> -&gt; <span class="id">rs</span>#<span class="id">RAX</span> = <span class="id">parent_sp</span> <span class="id">s</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Mach.State</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">sp</span> <span class="id">c</span> <span class="id">ms</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Asm.State</span> <span class="id">rs</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">ms</span> <span class="id">m</span> <span class="id">m</span>' <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stack</span> <span class="id">ge</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AG</span>: <span class="id">agree</span> <span class="id">ms</span> (<span class="id">parent_sp</span> <span class="id">s</span>) <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ATPC</span>: <span class="id">rs</span> <span class="id">PC</span> = <span class="id">Vptr</span> <span class="id">fb</span> <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ATLR</span>: <span class="id">rs</span> <span class="id">RA</span> = <span class="id">parent_ra</span> <span class="id">s</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Mach.Callstate</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">ms</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Asm.State</span> <span class="id">rs</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ms</span> <span class="id">m</span> <span class="id">m</span>' <span class="id">rs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stack</span> <span class="id">ge</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MEXT</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AG</span>: <span class="id">agree</span> <span class="id">ms</span> (<span class="id">parent_sp</span> <span class="id">s</span>) <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ATPC</span>: <span class="id">rs</span> <span class="id">PC</span> = <span class="id">parent_ra</span> <span class="id">s</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Mach.Returnstate</span> <span class="id">s</span> <span class="id">ms</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Asm.State</span> <span class="id">rs</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_straight_steps</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">f</span> <span class="id">rs1</span> <span class="id">i</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">m1</span>' <span class="id">m2</span> <span class="id">m2</span>' <span class="id">sp</span> <span class="id">ms2</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stack</span> <span class="id">ge</span> <span class="id">s</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.extends</span> <span class="id">m2</span> <span class="id">m2</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs1</span> <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> (<span class="id">i</span> :: <span class="id">c</span>) <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">k</span> <span class="id">c</span> (<span class="id">TR</span>: <span class="id">transl_instr</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_straight</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">c</span> <span class="id">rs1</span> <span class="id">m1</span>' <span class="id">k</span> <span class="id">rs2</span> <span class="id">m2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">agree</span> <span class="id">ms2</span> <span class="id">sp</span> <span class="id">rs2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ (<span class="id">it1_is_parent</span> <span class="id">ep</span> <span class="id">i</span> = <span class="id">true</span> -&gt; <span class="id">rs2</span>#<span class="id">RAX</span> = <span class="id">parent_sp</span> <span class="id">s</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">rs1</span> <span class="id">m1</span>') <span class="id">E0</span> <span class="id">st</span>' /\<br/>
&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Mach.State</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">sp</span> <span class="id">c</span> <span class="id">ms2</span> <span class="id">m2</span>) <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3957')">Proof.</div>
<div class="proofscript" id="proof3957">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H2</span>. <span class="tactic">subst</span>. <span class="id">monadInv</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">State</span> <span class="id">rs2</span> <span class="id">m2</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_exec</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">exec_straight_at</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_straight_steps_goto</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">f</span> <span class="id">rs1</span> <span class="id">i</span> <span class="id">c</span> <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> <span class="id">m1</span>' <span class="id">m2</span> <span class="id">m2</span>' <span class="id">sp</span> <span class="id">ms2</span> <span class="id">lbl</span> <span class="id">c</span>',<br/>
&nbsp;&nbsp;<span class="id">match_stack</span> <span class="id">ge</span> <span class="id">s</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.extends</span> <span class="id">m2</span> <span class="id">m2</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">f</span>.(<span class="id">Mach.fn_code</span>) = <span class="id">Some</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">rs1</span> <span class="id">PC</span>) <span class="id">fb</span> <span class="id">f</span> (<span class="id">i</span> :: <span class="id">c</span>) <span class="id">ep</span> <span class="id">tf</span> <span class="id">tc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">it1_is_parent</span> <span class="id">ep</span> <span class="id">i</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">k</span> <span class="id">c</span> (<span class="id">TR</span>: <span class="id">transl_instr</span> <span class="id">f</span> <span class="id">i</span> <span class="id">ep</span> <span class="id">k</span> = <span class="id">OK</span> <span class="id">c</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">jmp</span>, <span class="id">exists</span> <span class="id">k</span>', <span class="id">exists</span> <span class="id">rs2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exec_straight</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">c</span> <span class="id">rs1</span> <span class="id">m1</span>' (<span class="id">jmp</span> :: <span class="id">k</span>') <span class="id">rs2</span> <span class="id">m2</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">agree</span> <span class="id">ms2</span> <span class="id">sp</span> <span class="id">rs2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">exec_instr</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">jmp</span> <span class="id">rs2</span> <span class="id">m2</span>' = <span class="id">goto_label</span> <span class="id">tf</span> <span class="id">lbl</span> <span class="id">rs2</span> <span class="id">m2</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">rs1</span> <span class="id">m1</span>') <span class="id">E0</span> <span class="id">st</span>' /\<br/>
&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Mach.State</span> <span class="id">s</span> <span class="id">fb</span> <span class="id">sp</span> <span class="id">c</span>' <span class="id">ms2</span> <span class="id">m2</span>) <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3958')">Proof.</div>
<div class="proofscript" id="proof3958">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H3</span>. <span class="tactic">subst</span>. <span class="id">monadInv</span> <span class="id">H9</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">jmp</span> [<span class="id">k</span>' [<span class="id">rs2</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">functions_transl</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H7</span> <span class="id">H8</span>); <span class="tactic">intro</span> <span class="id">FN</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">transf_function_no_overflow</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H8</span>); <span class="tactic">intro</span> <span class="id">NOOV</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">exec_straight_steps_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ofs</span>' [<span class="id">PC2</span> <span class="id">CT2</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_label_goto_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tc</span>' [<span class="id">rs3</span> [<span class="id">GOTO</span> [<span class="id">AT</span>' <span class="id">OTH</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">State</span> <span class="id">rs3</span> <span class="id">m2</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_right</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_steps_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_instr_tail</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>. <span class="id">eexact</span> <span class="id">GOTO</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_exten</span> <span class="kwd">with</span> <span class="id">rs2</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">We need to show that, in the simulation diagram, we cannot
  take infinitely many Mach transitions that correspond to zero
  transitions on the PPC side.  Actually, all Mach transitions
  correspond to at least one Asm transition, except the
  transition from <span class="bracket"><span class="id">Mach.Returnstate</span></span> to <span class="bracket"><span class="id">Mach.State</span></span>.
  So, the following integer measure will suffice to rule out
  the unwanted behaviour. </div>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">s</span>: <span class="id">Mach.state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Mach.State</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Mach.Callstate</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Mach.Returnstate</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; 1%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">This is the simulation diagram.  We prove it by case analysis on the Mach transition. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">step_simulation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">Mach.step</span> <span class="id">return_address_offset</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">S1</span> <span class="id">S1</span>'),<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">S2</span>', <span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> <span class="id">S1</span>' <span class="id">t</span> <span class="id">S2</span>' /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">S2</span>')<br/>
&nbsp;&nbsp;\/ (<span class="kwd">measure</span> <span class="id">S2</span> &lt; <span class="kwd">measure</span> <span class="id">S1</span> /\ <span class="id">t</span> = <span class="id">E0</span> /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">S1</span>')%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3959')">Proof.</div>
<div class="proofscript" id="proof3959">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">MS</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mlabel&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">exec_straight_one</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mgetstack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">load_stack</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadind_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>'; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_set_mreg</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Msetstack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef</span> (<span class="id">rs</span> <span class="id">src</span>) (<span class="id">rs0</span> (<span class="id">preg_of</span> <span class="id">src</span>))). <span class="tactic">eapply</span> <span class="id">preg_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m2</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">storeind_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>'; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_undef_regs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Q</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">destroyed_by_setstack</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">simpl</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mgetparam&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>; <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">load_stack</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">parent</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">lessdef_parent_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">clear</span> <span class="id">B</span>; <span class="tactic">intros</span> <span class="id">B</span>; <span class="tactic">subst</span> <span class="id">parent</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
<span class="id">Opaque</span> <span class="id">loadind</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DIFF</span>: <span class="id">negb</span> (<span class="id">mreg_eq</span> <span class="id">dst</span> <span class="id">AX</span>) = <span class="id">true</span> -&gt; <span class="id">IR</span> <span class="id">RAX</span> &lt;&gt; <span class="id">preg_of</span> <span class="id">dst</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">change</span> (<span class="id">IR</span> <span class="id">RAX</span>) <span class="kwd">with</span> (<span class="id">preg_of</span> <span class="id">AX</span>). <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">proj_sumbool</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> (<span class="id">mreg_eq</span> <span class="id">dst</span> <span class="id">AX</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">eapply</span> <span class="id">preg_of_injective</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ep</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;RAX&nbsp;contains&nbsp;parent&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadind_correct</span>. <span class="id">eexact</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (2 := <span class="id">rs0</span>). <span class="tactic">rewrite</span> <span class="id">AXP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs1</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_set_mreg</span>. <span class="tactic">eapply</span> <span class="id">agree_set_mreg</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">R</span>; <span class="tactic">auto</span>.<br/>
&nbsp;RAX&nbsp;does&nbsp;not&nbsp;contain&nbsp;parent&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadind_correct</span>. <span class="id">eexact</span> <span class="id">EQ0</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs1</span> [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadind_correct</span>. <span class="id">eexact</span> <span class="id">EQ</span>. <span class="id">instantiate</span> (2 := <span class="id">rs1</span>). <span class="tactic">rewrite</span> <span class="id">Q</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">S</span> [<span class="id">T</span> <span class="id">U</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_straight_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_set_mreg</span>. <span class="tactic">eapply</span> <span class="id">agree_set_mreg</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">U</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">eval_operation</span> <span class="id">tge</span> <span class="id">sp</span> <span class="id">op</span> <span class="id">rs</span>##<span class="id">args</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_operation_lessdef</span>. <span class="tactic">eapply</span> <span class="id">preg_vals</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_op_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">S</span>: <span class="id">Val.lessdef</span> <span class="id">v</span> (<span class="id">rs2</span> (<span class="id">preg_of</span> <span class="id">res</span>))) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Val.lessdef_trans</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_set_undef_mreg</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mload&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">eval_addressing</span> <span class="id">tge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">rs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>. <span class="tactic">eapply</span> <span class="id">preg_vals</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_load_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_set_undef_mreg</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mstore&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">eval_addressing</span> <span class="id">tge</span> <span class="id">sp</span> <span class="id">addr</span> <span class="id">rs</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>. <span class="tactic">eapply</span> <span class="id">preg_vals</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef</span> (<span class="id">rs</span> <span class="id">src</span>) (<span class="id">rs0</span> (<span class="id">preg_of</span> <span class="id">src</span>))). <span class="tactic">eapply</span> <span class="id">preg_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m2</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_store_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">rs2</span> [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>; <span class="tactic">split</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_undef_regs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>.  <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NOOV</span>: <span class="id">list_length_z</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_function_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ros</span> <span class="kwd">as</span> [<span class="id">rf</span>|<span class="id">fid</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">monadInv</span> <span class="id">H5</span>.<br/>
+ <span class="comment">(*&nbsp;Indirect&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs</span> <span class="id">rf</span> = <span class="id">Vptr</span> <span class="id">f</span>' <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rs</span> <span class="id">rf</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">H</span>; <span class="id">predSpec</span> <span class="id">Ptrofs.eq</span> <span class="id">Ptrofs.eq_spec</span> <span class="id">i</span> <span class="id">Ptrofs.zero</span>; <span class="tactic">intros</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs0</span> <span class="id">x0</span> = <span class="id">Vptr</span> <span class="id">f</span>' <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">ireg_val</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H5</span>; <span class="tactic">intros</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">code_tail_next_int</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">NOOV</span> <span class="id">H6</span>). <span class="tactic">intro</span> <span class="id">CT1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TCA</span>: <span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">fb</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs</span> <span class="id">Ptrofs.one</span>)) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">false</span> <span class="id">tf</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">return_address_offset_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">ra</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_sp_def</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="id">Simplifs</span>.<br/>
&nbsp;&nbsp;<span class="id">Simplifs</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;Direct&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">code_tail_next_int</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">NOOV</span> <span class="id">H6</span>). <span class="tactic">intro</span> <span class="id">CT1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TCA</span>: <span class="id">transl_code_at_pc</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">fb</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs</span> <span class="id">Ptrofs.one</span>)) <span class="id">fb</span> <span class="id">f</span> <span class="id">c</span> <span class="id">false</span> <span class="id">tf</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">return_address_offset_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">ra</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_sp_def</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="id">Simplifs</span>.<br/>
&nbsp;&nbsp;<span class="id">Simplifs</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mtailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>.  <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NOOV</span>: <span class="id">list_length_z</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_function_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> *. <span class="tactic">unfold</span> <span class="id">load_stack</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">parent</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H2</span>. <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">ra</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">lessdef_parent_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">parent</span>'. <span class="tactic">clear</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">lessdef_parent_ra</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">ra</span>'. <span class="tactic">clear</span> <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m2</span>' [<span class="id">E</span> <span class="id">F</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ros</span> <span class="kwd">as</span> [<span class="id">rf</span>|<span class="id">fid</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">monadInv</span> <span class="id">H7</span>.<br/>
+ <span class="comment">(*&nbsp;Indirect&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs</span> <span class="id">rf</span> = <span class="id">Vptr</span> <span class="id">f</span>' <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rs</span> <span class="id">rf</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">revert</span> <span class="id">H</span>; <span class="id">predSpec</span> <span class="id">Ptrofs.eq</span> <span class="id">Ptrofs.eq_spec</span> <span class="id">i</span> <span class="id">Ptrofs.zero</span>; <span class="tactic">intros</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs0</span> <span class="id">x0</span> = <span class="id">Vptr</span> <span class="id">f</span>' <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">ireg_val</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H7</span>; <span class="tactic">intros</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">code_tail_next_int</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">NOOV</span> <span class="id">H8</span>). <span class="tactic">intro</span> <span class="id">CT1</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">replace</span> (<span class="id">chunk_of_type</span> <span class="id">Tptr</span>) <span class="kwd">with</span> <span class="id">Mptr</span> <span class="kwd">in</span> * <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">Tptr</span>, <span class="id">Mptr</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>. <span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">rewrite</span> &lt;- (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>). <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Val.offset_ptr</span> <span class="id">rs0</span>#<span class="id">PC</span> <span class="id">Ptrofs.one</span>). <span class="tactic">auto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_change_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">parent_sp_def</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">Simplifs</span>. <span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">preg_of_not_SP</span> <span class="id">rf</span>). <span class="tactic">rewrite</span> (<span class="id">ireg_of_eq</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ1</span>). <span class="tactic">congruence</span>.<br/>
+ <span class="comment">(*&nbsp;Direct&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">code_tail_next_int</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">NOOV</span> <span class="id">H8</span>). <span class="tactic">intro</span> <span class="id">CT1</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">replace</span> (<span class="id">chunk_of_type</span> <span class="id">Tptr</span>) <span class="kwd">with</span> <span class="id">Mptr</span> <span class="kwd">in</span> * <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">Tptr</span>, <span class="id">Mptr</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span>. <span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">rewrite</span> &lt;- (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>). <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Val.offset_ptr</span> <span class="id">rs0</span>#<span class="id">PC</span> <span class="id">Ptrofs.one</span>). <span class="tactic">auto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_change_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">parent_sp_def</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>. <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mbuiltin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>. <span class="id">monadInv</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">FN</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">transf_function_no_overflow</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H3</span>); <span class="tactic">intro</span> <span class="id">NOOV</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">builtin_args_match</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">vargs</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">vres</span>' [<span class="id">m2</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_step_builtin</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> &lt;- <span class="id">sp_val</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (2 := <span class="id">tf</span>); <span class="id">instantiate</span> (1 := <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr_nf</span>, <span class="id">nextinstr</span>. <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">undef_regs_other</span>. <span class="tactic">rewrite</span> <span class="id">set_res_other</span>. <span class="tactic">rewrite</span> <span class="id">undef_regs_other_2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>. <span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">code_tail_next_int</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">preg_notin_charact</span>. <span class="tactic">intros</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_nextinstr_nf</span>. <span class="tactic">eapply</span> <span class="id">agree_set_res</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_undef_regs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">undef_regs_other_2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mgoto&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>. <span class="id">monadInv</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_label_goto_label</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tc</span>' [<span class="id">rs</span>' [<span class="id">GOTO</span> [<span class="id">AT2</span> <span class="id">INV</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">exists</span> (<span class="id">State</span> <span class="id">rs</span>' <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mcond&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_condition_lessdef</span>. <span class="tactic">eapply</span> <span class="id">preg_vals</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EC</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps_goto</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">transl_cond_correct</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">_</span> <span class="id">_</span> <span class="id">rs0</span> <span class="id">m</span>' <span class="id">TR</span>)<br/>
&nbsp;&nbsp;<span class="kwd">as</span> [<span class="id">rs</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EC</span> <span class="kwd">in</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">testcond_for_condition</span> <span class="id">cond</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;simple&nbsp;jcc&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Pjcc</span> <span class="id">c1</span> <span class="id">lbl</span>); <span class="id">exists</span> <span class="id">k</span>; <span class="id">exists</span> <span class="id">rs</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">auto</span>.<br/>
&nbsp;jcc;&nbsp;jcc&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c1</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b1</span>|] <span class="id">eqn</span>:<span class="id">TC1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c2</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b2</span>|] <span class="id">eqn</span>:<span class="id">TC2</span>; <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b1</span>.<br/>
&nbsp;first&nbsp;jcc&nbsp;jumps&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Pjcc</span> <span class="id">c1</span> <span class="id">lbl</span>); <span class="id">exists</span> (<span class="id">Pjcc</span> <span class="id">c2</span> <span class="id">lbl</span> :: <span class="id">k</span>); <span class="id">exists</span> <span class="id">rs</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">TC1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;second&nbsp;jcc&nbsp;jumps&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Pjcc</span> <span class="id">c2</span> <span class="id">lbl</span>); <span class="id">exists</span> <span class="id">k</span>; <span class="id">exists</span> (<span class="id">nextinstr</span> <span class="id">rs</span>').<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">exec_straight_trans</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_one</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">TC1</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">Simplifs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">eval_testcond_nextinstr</span>. <span class="tactic">rewrite</span> <span class="id">TC2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b2</span>; <span class="tactic">auto</span> || <span class="tactic">discriminate</span>.<br/>
&nbsp;jcc2&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c1</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b1</span>|] <span class="id">eqn</span>:<span class="id">TC1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c2</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b2</span>|] <span class="id">eqn</span>:<span class="id">TC2</span>; <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H3</span>). <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Pjcc2</span> <span class="id">c1</span> <span class="id">c2</span> <span class="id">lbl</span>); <span class="id">exists</span> <span class="id">k</span>; <span class="id">exists</span> <span class="id">rs</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">TC1</span>; <span class="tactic">rewrite</span> <span class="id">TC2</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mcond&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_condition_lessdef</span>. <span class="tactic">eapply</span> <span class="id">preg_vals</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EC</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">eapply</span> <span class="id">exec_straight_steps</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">transl_cond_correct</span> <span class="id">tge</span> <span class="id">tf</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">_</span> <span class="id">_</span> <span class="id">rs0</span> <span class="id">m</span>' <span class="id">TR</span>)<br/>
&nbsp;&nbsp;<span class="kwd">as</span> [<span class="id">rs</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EC</span> <span class="kwd">in</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">testcond_for_condition</span> <span class="id">cond</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;simple&nbsp;jcc&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_trans</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_straight_one</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;jcc&nbsp;;&nbsp;jcc&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c1</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b1</span>|] <span class="id">eqn</span>:<span class="id">TC1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c2</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b2</span>|] <span class="id">eqn</span>:<span class="id">TC2</span>; <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">orb_false_elim</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>); <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_trans</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_two</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">TC1</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">eval_testcond_nextinstr</span>. <span class="tactic">rewrite</span> <span class="id">TC2</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;jcc2&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c1</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b1</span>|] <span class="id">eqn</span>:<span class="id">TC1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eval_testcond</span> <span class="id">c2</span> <span class="id">rs</span>') <span class="kwd">as</span> [<span class="id">b2</span>|] <span class="id">eqn</span>:<span class="id">TC2</span>; <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">nextinstr</span> <span class="id">rs</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_straight_trans</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_straight_one</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">TC1</span>; <span class="tactic">rewrite</span> <span class="id">TC2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">subst</span> <span class="id">b2</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">eapply</span> <span class="id">agree_exten</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mjumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>. <span class="id">monadInv</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">FN</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">transf_function_no_overflow</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H5</span>); <span class="tactic">intro</span> <span class="id">NOOV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">rs1</span> := <span class="id">rs0</span> #<span class="id">RAX</span> &lt;- <span class="id">Vundef</span> #<span class="id">RDX</span> &lt;- <span class="id">Vundef</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">find_label_goto_label</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">lbl</span> <span class="id">rs1</span>); <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tc</span>' [<span class="id">rs</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">ireg_val</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">intros</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H9</span>.  <span class="tactic">unfold</span> <span class="id">Mach.label</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">unfold</span> <span class="id">label</span>; <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<span class="id">Transparent</span> <span class="id">destroyed_by_jumptable</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_undef_regs</span> <span class="kwd">with</span> <span class="id">rs0</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H8</span>. <span class="tactic">rewrite</span> <span class="id">C</span> <span class="tactic">by</span> <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>. <span class="tactic">unfold</span> <span class="id">rs1</span>; <span class="id">Simplifs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Mreturn&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f0</span> = <span class="id">f</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">f0</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">AT</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NOOV</span>: <span class="id">list_length_z</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_function_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> *. <span class="tactic">unfold</span> <span class="id">load_stack</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">chunk_of_type</span> <span class="id">Tptr</span>) <span class="kwd">with</span> <span class="id">Mptr</span> <span class="kwd">in</span> * <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">Tptr</span>, <span class="id">Mptr</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">parent</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">lessdef_parent_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">parent</span>'. <span class="tactic">clear</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">ra</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">lessdef_parent_ra</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">ra</span>'. <span class="tactic">clear</span> <span class="id">D</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m2</span>' [<span class="id">E</span> <span class="id">F</span>]].<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">code_tail_next_int</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">CT1</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">C</span>. <span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">rewrite</span> &lt;- (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>). <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_internal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Val.offset_ptr</span> <span class="id">rs0</span>#<span class="id">PC</span> <span class="id">Ptrofs.one</span>). <span class="tactic">auto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">functions_transl</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">find_instr_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_change_sp</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">parent_sp_def</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">monadInv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">EQ</span>; <span class="tactic">intros</span> <span class="id">EQ</span>'. <span class="id">monadInv</span> <span class="id">EQ</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">list_length_z</span> (<span class="id">fn_code</span> <span class="id">x0</span>))); <span class="id">inv</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ0</span>. <span class="tactic">rewrite</span> <span class="id">transl_code</span>'<span class="id">_transl_code</span> <span class="kwd">in</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_extends</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">m1</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>. <span class="id">eexact</span> <span class="id">D</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">m2</span>' [<span class="id">F</span> <span class="id">G</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>. <span class="id">eexact</span> <span class="id">G</span>. <span class="id">eexact</span> <span class="id">H2</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">m3</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_zero</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">C</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">F</span>, <span class="id">P</span>. <br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">chunk_of_type</span> <span class="id">Tptr</span>) <span class="kwd">with</span> <span class="id">Mptr</span> <span class="kwd">in</span> <span class="id">F</span>, <span class="id">P</span> <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">Tptr</span>, <span class="id">Mptr</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sp_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AG</span>) <span class="kwd">in</span> <span class="id">F</span>. <span class="tactic">rewrite</span> <span class="id">F</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ATLR</span>. <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nextinstr</span>. <span class="tactic">rewrite</span> <span class="id">Pregmap.gss</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Pregmap.gso</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ATPC</span>. <span class="tactic">simpl</span>. <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fn_code</span>. <span class="tactic">eapply</span> <span class="id">code_tail_next_int</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">g</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_nextinstr</span>. <span class="tactic">eapply</span> <span class="id">agree_change_sp</span>; <span class="tactic">eauto</span>.<br/>
<span class="id">Transparent</span> <span class="id">destroyed_at_function_entry</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_undef_regs</span> <span class="kwd">with</span> <span class="id">rs0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Pregmap.gso</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">asmgen</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">Simplifs</span>. <span class="tactic">eapply</span> <span class="id">agree_sp</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">B</span>. <span class="id">inv</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">extcall_arguments_match</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">args</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">res</span>' [<span class="id">m2</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> <span class="id">S</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_step_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">loc_external_result</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_set_other</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_set_pair</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">ATPC</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">Mach.initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">Asm.initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3960')">Proof.</div>
<div class="proofscript" id="proof3960">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">ge0</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> (<span class="id">Genv.init_mem_transf_partial</span> <span class="id">TRANSF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Genv.symbol_address</span> (<span class="id">Genv.globalenv</span> <span class="id">tprog</span>) (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="id">Ptrofs.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> (<span class="id">Vptr</span> <span class="id">fb</span> <span class="id">Ptrofs.zero</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.extends_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">reflexivity</span>. <span class="tactic">simpl</span>. <br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Vnullptr</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_program_main</span> <span class="id">TRANSF</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ge</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">Mach.final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">Asm.final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3961')">Proof.</div>
<div class="proofscript" id="proof3961">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">r0</span> = <span class="id">AX</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">loc_result</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">compute</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">r0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">preg_val</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">AX</span> <span class="id">AG</span>). <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">intros</span> <span class="id">LD</span>; <span class="id">inv</span> <span class="id">LD</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">Mach.semantics</span> <span class="id">return_address_offset</span> <span class="id">prog</span>) (<span class="id">Asm.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3962')">Proof.</div>
<div class="proofscript" id="proof3962">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_star</span> <span class="kwd">with</span> (<span class="kwd">measure</span> := <span class="kwd">measure</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_final_states</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">step_simulation</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
