<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module SimplLocalsproof</title>
<meta name="description" content="Documentation of Coq module SimplLocalsproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module SimplLocalsproof</h1>
<div class="coq">
<br/>
<div class="doc">Semantic preservation for the SimplLocals pass. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSets</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Errors</span> <span class="id">Ordered</span> <span class="id">Maps</span> <span class="id">Integers</span> <span class="id">Floats</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Globalenvs</span> <span class="id">Events</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ctypes</span> <span class="id">Cop</span> <span class="id">Clight</span> <span class="id">SimplLocals</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">VSF</span> := <span class="id">FSetFacts.Facts</span>(<span class="id">VSet</span>).<br/>
<span class="kwd">Module</span> <span class="id">VSP</span> := <span class="id">FSetProperties.Properties</span>(<span class="id">VSet</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span> <span class="id">tp</span>: <span class="id">program</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">ctx</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span><br/>
&nbsp;/\ <span class="id">prog_types</span> <span class="id">tp</span> = <span class="id">prog_types</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_transf_program</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transf_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4380')">Proof.</div>
<div class="proofscript" id="proof4380">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_program</span>; <span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">match_transform_partial_program</span>. <span class="tactic">rewrite</span> <span class="id">EQ</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">comp_env_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">genv_cenv</span> <span class="id">tge</span> = <span class="id">genv_cenv</span> <span class="id">ge</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4381')">Proof.</div>
<div class="proofscript" id="proof4381">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">tge</span>, <span class="id">ge</span>. <span class="tactic">destruct</span> <span class="id">prog</span>, <span class="id">tprog</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">TRANSF</span> <span class="kwd">as</span> [<span class="id">_</span> <span class="id">EQ</span>]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">EQ</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_match</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_match</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">f</span>: <span class="id">fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>, <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf_partial</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">f</span>: <span class="id">fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>, <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf_partial</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">type_of_fundef_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fd</span> <span class="id">tfd</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_fundef</span> <span class="id">fd</span> = <span class="id">OK</span> <span class="id">tfd</span> -&gt; <span class="id">type_of_fundef</span> <span class="id">tfd</span> = <span class="id">type_of_fundef</span> <span class="id">fd</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4382')">Proof.</div>
<div class="proofscript" id="proof4382">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">fd</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">EQ</span>. <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">type_of_function</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching between environments before and after </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_var</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">e</span>: <span class="id">env</span>) (<span class="id">m</span>: <span class="id">mem</span>) (<span class="id">te</span>: <span class="id">env</span>) (<span class="id">tle</span>: <span class="id">temp_env</span>) (<span class="id">id</span>: <span class="id">ident</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_var_lifted</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">chunk</span> <span class="id">v</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ENV</span>: <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TENV</span>: <span class="id">te</span>!<span class="id">id</span> = <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LIFTED</span>: <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAPPED</span>: <span class="id">f</span> <span class="id">b</span> = <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MODE</span>: <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LOAD</span>: <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TLENV</span>: <span class="id">tle</span>!(<span class="id">id</span>) = <span class="id">Some</span> <span class="id">tv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VINJ</span>: <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_var</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">m</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">id</span><br/>
&nbsp;&nbsp;| <span class="id">match_var_not_lifted</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">b</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ENV</span>: <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TENV</span>: <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LIFTED</span>: <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MAPPED</span>: <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', 0)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_var</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">m</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">id</span><br/>
&nbsp;&nbsp;| <span class="id">match_var_not_local</span>: <span class="kwd">forall</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ENV</span>: <span class="id">e</span>!<span class="id">id</span> = <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TENV</span>: <span class="id">te</span>!<span class="id">id</span> = <span class="id">None</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LIFTED</span>: <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_var</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">m</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">id</span>.<br/>
<br/>
<span class="kwd">Record</span> <span class="id">match_envs</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">cenv</span>: <span class="id">compilenv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">e</span>: <span class="id">env</span>) (<span class="id">le</span>: <span class="id">temp_env</span>) (<span class="id">m</span>: <span class="id">mem</span>) (<span class="id">lo</span> <span class="id">hi</span>: <span class="id">block</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">te</span>: <span class="id">env</span>) (<span class="id">tle</span>: <span class="id">temp_env</span>) (<span class="id">tlo</span> <span class="id">thi</span>: <span class="id">block</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_match_envs</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_vars</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">match_var</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">m</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">id</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_temps</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">le</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">tv</span>, <span class="id">tle</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">tv</span> /\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span> -&gt; <span class="id">v</span> = <span class="id">Vundef</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_inj</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id1</span> <span class="id">b1</span> <span class="id">ty1</span> <span class="id">id2</span> <span class="id">b2</span> <span class="id">ty2</span>, <span class="id">e</span>!<span class="id">id1</span> = <span class="id">Some</span>(<span class="id">b1</span>, <span class="id">ty1</span>) -&gt; <span class="id">e</span>!<span class="id">id2</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">ty2</span>) -&gt; <span class="id">id1</span> &lt;&gt; <span class="id">id2</span> -&gt; <span class="id">b1</span> &lt;&gt; <span class="id">b2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_range</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">Ple</span> <span class="id">lo</span> <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> <span class="id">hi</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_trange</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>, <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">Ple</span> <span class="id">tlo</span> <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> <span class="id">thi</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_mapped</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>' <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>) -&gt; <span class="id">exists</span> <span class="id">b</span>, <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', 0) /\ <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_flat</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>' <span class="id">ty</span> <span class="id">b</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>) -&gt; <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) /\ <span class="id">delta</span> = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_incr</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">lo</span> <span class="id">hi</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_tincr</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">tlo</span> <span class="id">thi</span><br/>
&nbsp;&nbsp;}.<br/>
<br/>
<div class="doc">Invariance by change of memory and injection </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">f</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">chunk</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">None</span> -&gt; <span class="id">Ple</span> <span class="id">lo</span> <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> <span class="id">hi</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Ple</span> <span class="id">lo</span> <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> <span class="id">hi</span> -&gt; <span class="id">f</span>' <span class="id">b</span> = <span class="id">f</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">f</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Ple</span> <span class="id">tlo</span> <span class="id">b</span>' /\ <span class="id">Plt</span> <span class="id">b</span>' <span class="id">thi</span> -&gt; <span class="id">f</span>' <span class="id">b</span> = <span class="id">f</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span>' <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>' <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4383')">Proof.</div>
<div class="proofscript" id="proof4383">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>'; <span class="tactic">intros</span> <span class="id">ME</span> <span class="id">LD</span> <span class="id">INCR</span> <span class="id">INV1</span> <span class="id">INV2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ME</span>; <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">MAPPED</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_temps0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]] <span class="id">C</span>]. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;mapped&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_mapped0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">b</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;flat&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">me_flat0</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">INV2</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by external call </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_extcall</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">tm</span> <span class="id">f</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> (<span class="id">loc_unmapped</span> <span class="id">f</span>) <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_separated</span> <span class="id">f</span> <span class="id">f</span>' <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">hi</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt; <span class="id">Ple</span> <span class="id">thi</span> (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span>' <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>' <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4384')">Proof.</div>
<div class="proofscript" id="proof4384">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_envs_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>]|] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span>' <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>]|] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">xomegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>'' <span class="id">delta</span>']|] <span class="id">eqn</span>:?. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">xomegaContradiction</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Properties of values resulting from a cast </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">val_casted_load_result</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">ty</span> <span class="id">chunk</span>,<br/>
&nbsp;&nbsp;<span class="id">val_casted</span> <span class="id">v</span> <span class="id">ty</span> -&gt; <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.load_result</span> <span class="id">chunk</span> <span class="id">v</span> = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4385')">Proof.</div>
<div class="proofscript" id="proof4385">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">clear</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">v</span> <span class="id">ty</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">sz</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">clear</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">clear</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">clear</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">chunk</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span>); <span class="tactic">subst</span> <span class="id">n</span>; <span class="tactic">reflexivity</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Mptr</span>, <span class="id">Val.load_result</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>. <br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Mptr</span>, <span class="id">Val.load_result</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Val.load_result</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Mptr</span>, <span class="id">Val.load_result</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">Val.load_result</span>; <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">val_casted_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>' <span class="id">ty</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>' -&gt; <span class="id">val_casted</span> <span class="id">v</span> <span class="id">ty</span> -&gt; <span class="id">val_casted</span> <span class="id">v</span>' <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4386')">Proof.</div>
<div class="proofscript" id="proof4386">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">forall2_val_casted_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">vl</span> <span class="id">vl</span>', <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">vl</span> <span class="id">vl</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tyl</span>, <span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">vl</span> <span class="id">tyl</span> -&gt; <span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">vl</span>' <span class="id">tyl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4387')">Proof.</div>
<div class="proofscript" id="proof4387">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">tyl</span> <span class="id">F</span>; <span class="id">inv</span> <span class="id">F</span>; <span class="id">constructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">val_casted_inject</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">val_casted_list</span>: <span class="id">list</span> <span class="id">val</span> -&gt; <span class="id">typelist</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">vcl_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">val_casted_list</span> <span class="id">nil</span> <span class="id">Tnil</span><br/>
&nbsp;&nbsp;| <span class="id">vcl_cons</span>: <span class="kwd">forall</span> <span class="id">v1</span> <span class="id">vl</span> <span class="id">ty1</span> <span class="id">tyl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">val_casted</span> <span class="id">v1</span> <span class="id">ty1</span> -&gt; <span class="id">val_casted_list</span> <span class="id">vl</span> <span class="id">tyl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">val_casted_list</span> (<span class="id">v1</span> :: <span class="id">vl</span>) (<span class="id">Tcons</span>  <span class="id">ty1</span> <span class="id">tyl</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">val_casted_list_params</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">params</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">val_casted_list</span> <span class="id">vl</span> (<span class="id">type_of_params</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">vl</span> (<span class="id">map</span> <span class="id">snd</span> <span class="id">params</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4388')">Proof.</div>
<div class="proofscript" id="proof4388">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">params</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]. <span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Correctness of <span class="bracket"><span class="id">make_cast</span></span> </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cast_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v1</span> <span class="id">tto</span> <span class="id">v2</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">tge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_cast</span> <span class="id">v1</span> (<span class="id">typeof</span> <span class="id">a</span>) <span class="id">tto</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">tge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_cast</span> <span class="id">a</span> <span class="id">tto</span>) <span class="id">v2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4389')">Proof.</div>
<div class="proofscript" id="proof4389">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DFL</span>: <span class="id">eval_expr</span> <span class="id">tge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">Ecast</span> <span class="id">a</span> <span class="id">tto</span>) <span class="id">v2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_cast</span>, <span class="id">make_cast</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_cast</span> (<span class="id">typeof</span> <span class="id">a</span>) <span class="id">tto</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sz2</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">v1</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id1</span> <span class="id">id2</span>); <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id1</span> <span class="id">id2</span>); <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Debug annotations. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cast_typeconv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">ty</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">val_casted</span> <span class="id">v</span> <span class="id">ty</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_cast</span> <span class="id">v</span> <span class="id">ty</span> (<span class="id">typeconv</span> <span class="id">ty</span>) <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4390')">Proof.</div>
<div class="proofscript" id="proof4390">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>, <span class="id">classify_cast</span>; <span class="tactic">destruct</span> <span class="id">sz</span>, <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>, <span class="id">classify_cast</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">dec_eq_true</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">sem_cast</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">dec_eq_true</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_Sdebug_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">le</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">val_casted</span> <span class="id">v</span> <span class="id">ty</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sdebug_temp</span> <span class="id">id</span> <span class="id">ty</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4391')">Proof.</div>
<div class="proofscript" id="proof4391">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Sdebug_temp</span>. <span class="tactic">eapply</span> <span class="id">step_builtin</span> <span class="kwd">with</span> (<span class="id">optid</span> := <span class="id">None</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">constructor</span>. <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">cast_typeconv</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_Sdebug_var</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sdebug_var</span> <span class="id">id</span> <span class="id">ty</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4392')">Proof.</div>
<div class="proofscript" id="proof4392">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Sdebug_var</span>. <span class="tactic">eapply</span> <span class="id">step_builtin</span> <span class="kwd">with</span> (<span class="id">optid</span> := <span class="id">None</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_Sset_debug</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">a</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">tge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_cast</span> <span class="id">v</span> (<span class="id">typeof</span> <span class="id">a</span>) <span class="id">ty</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sset_debug</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">a</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span>' <span class="id">le</span>) <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4393')">Proof.</div>
<div class="proofscript" id="proof4393">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">unfold</span> <span class="id">Sset_debug</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">k</span>, <span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sset</span> <span class="id">id</span> (<span class="id">make_cast</span> <span class="id">a</span> <span class="id">ty</span>)) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span>' <span class="id">le</span>) <span class="id">m</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">step_set</span>. <span class="tactic">eapply</span> <span class="id">make_cast_correct</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>).<br/>
- <span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="tactic">apply</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="tactic">apply</span> <span class="id">step_Sdebug_temp</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>').<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gss</span>. <span class="tactic">eapply</span> <span class="id">cast_val_is_casted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
- <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">H1</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_add_debug_vars</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">s</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt; <span class="id">exists</span> <span class="id">b</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span> (<span class="id">b</span>, <span class="id">ty</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">add_debug_vars</span> <span class="id">vars</span> <span class="id">s</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4394')">Proof.</div>
<div class="proofscript" id="proof4394">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_debug_vars</span>. <span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>).<br/>
- <span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">b</span> &amp; <span class="id">TE</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="tactic">eapply</span> <span class="id">step_Sdebug_var</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHvars</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">bind_parameter_temps_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">params</span> <span class="id">args</span> <span class="id">le</span> <span class="id">le</span>',<br/>
&nbsp;&nbsp;<span class="id">bind_parameter_temps</span> <span class="id">params</span> <span class="id">args</span> <span class="id">le</span> = <span class="id">Some</span> <span class="id">le</span>' -&gt;<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">le</span>'!<span class="id">id</span> = <span class="id">le</span>!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4395')">Proof.</div>
<div class="proofscript" id="proof4395">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">params</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">args</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">destruct</span> <span class="id">args</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> ((<span class="id">PTree.set</span> <span class="id">id1</span> <span class="id">v</span> <span class="id">le</span>)!<span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHparams</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">PTree.gso</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_add_debug_params</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">params</span> <span class="id">vl</span> <span class="id">le1</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">vl</span> (<span class="id">map</span> <span class="id">snd</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">bind_parameter_temps</span> <span class="id">params</span> <span class="id">vl</span> <span class="id">le1</span> = <span class="id">Some</span> <span class="id">le</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">add_debug_params</span> <span class="id">params</span> <span class="id">s</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4396')">Proof.</div>
<div class="proofscript" id="proof4396">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_debug_params</span>. <span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>).<br/>
- <span class="tactic">induction</span> <span class="id">params</span> <span class="kwd">as</span> [ | [<span class="id">id</span> <span class="id">ty</span>] <span class="id">params</span> ]; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">le1</span>; <span class="tactic">intros</span> <span class="id">NR</span> <span class="id">CAST</span> <span class="id">BIND</span>; <span class="id">inv</span> <span class="id">CAST</span>; <span class="id">inv</span> <span class="id">NR</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">assert</span> (<span class="id">le</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">a1</span>). { <span class="id">erewrite</span> <span class="id">bind_parameter_temps_inv</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="tactic">eapply</span> <span class="id">step_Sdebug_temp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHparams</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
- <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation by assignment to lifted variable. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_assign_lifted</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">id</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">val_casted</span> <span class="id">v</span> <span class="id">ty</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">ge</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">Ptrofs.zero</span> <span class="id">v</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>' <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">tv</span> <span class="id">tle</span>) <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4397')">Proof.</div>
<div class="proofscript" id="proof4397">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ENV</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H3</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.storev</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_zero</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.load_store_same</span>; <span class="tactic">eauto</span>. <span class="id">erewrite</span> <span class="id">val_casted_load_result</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id0</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">LOAD0</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_temps0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">tv1</span> [<span class="id">A</span> <span class="id">B</span>]] <span class="id">C</span>]. <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id0</span>. <span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation by assignment to a temporary </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_set_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">id</span> <span class="id">v</span> <span class="id">tv</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">check_temp</span> <span class="id">cenv</span> <span class="id">id</span> = <span class="id">OK</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span> <span class="id">le</span>) <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">tv</span> <span class="id">tle</span>) <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4398')">Proof.</div>
<div class="proofscript" id="proof4398">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">check_temp</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?; <span class="id">monadInv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id0</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>. <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">split</span>. <span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">auto</span>. <span class="tactic">intros</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">me_temps0</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_set_opttemp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">optid</span> <span class="id">v</span> <span class="id">tv</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">check_opttemp</span> <span class="id">cenv</span> <span class="id">optid</span> = <span class="id">OK</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> (<span class="id">set_opttemp</span> <span class="id">optid</span> <span class="id">v</span> <span class="id">le</span>) <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> (<span class="id">set_opttemp</span> <span class="id">optid</span> <span class="id">tv</span> <span class="id">tle</span>) <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4399')">Proof.</div>
<div class="proofscript" id="proof4399">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">set_opttemp</span>. <span class="tactic">destruct</span> <span class="id">optid</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_set_temp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Extensionality with respect to temporaries </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_temps_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">tle</span>',<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">tle</span>'!<span class="id">id</span> = <span class="id">tle</span>!<span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span>' <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4400')">Proof.</div>
<div class="proofscript" id="proof4400">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by assignment to an irrelevant temporary </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_envs_change_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">id</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">le</span>!<span class="id">id</span> = <span class="id">None</span> -&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span> <span class="id">tle</span>) <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4401')">Proof.</div>
<div class="proofscript" id="proof4401">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id0</span>); <span class="tactic">intros</span> <span class="id">MV</span>; <span class="id">inv</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span>. <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Properties of <span class="bracket"><span class="id">cenv_for</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">cenv_for_gen</span> (<span class="id">atk</span>: <span class="id">VSet.t</span>) (<span class="id">vars</span>: <span class="id">list</span> (<span class="id">ident</span> * <span class="id">type</span>)) : <span class="id">compilenv</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.fold_right</span> (<span class="id">add_local_variable</span> <span class="id">atk</span>) <span class="id">VSet.empty</span> <span class="id">vars</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">add_local_variable_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">atk</span> <span class="id">cenv</span> <span class="id">id1</span>,<br/>
&nbsp;&nbsp;<span class="id">VSet.In</span> <span class="id">id1</span> (<span class="id">add_local_variable</span> <span class="id">atk</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">cenv</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">VSet.In</span> <span class="id">id1</span> <span class="id">cenv</span> \/ <span class="id">exists</span> <span class="id">chunk</span>, <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span> /\ <span class="id">id</span> = <span class="id">id1</span> /\ <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">atk</span> = <span class="id">false</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4402')">Proof.</div>
<div class="proofscript" id="proof4402">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">add_local_variable</span>. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">access_mode</span> <span class="id">ty</span>) <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">atk</span>) <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VSF.add_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="id">right</span>; <span class="id">exists</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">chunk</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">access_mode</span> <span class="id">ty</span>); <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">atk</span>); <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">VSF.add_iff</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">B</span>. <span class="tactic">rewrite</span> <span class="id">C</span>. <span class="tactic">apply</span> <span class="id">VSet.add_1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cenv_for_gen_domain</span>:<br/>
&nbsp;<span class="kwd">forall</span> <span class="id">atk</span> <span class="id">id</span> <span class="id">vars</span>, <span class="id">VSet.In</span> <span class="id">id</span> (<span class="id">cenv_for_gen</span> <span class="id">atk</span> <span class="id">vars</span>) -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4403')">Proof.</div>
<div class="proofscript" id="proof4403">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VSF.empty_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">rewrite</span> <span class="id">add_local_variable_charact</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">chunk</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cenv_for_gen_by_value</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">atk</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">vars</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">VSet.In</span> <span class="id">id</span> (<span class="id">cenv_for_gen</span> <span class="id">atk</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">chunk</span>, <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4404')">Proof.</div>
<div class="proofscript" id="proof4404">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">add_local_variable_charact</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">chunk</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">elim</span> <span class="id">H4</span>. <span class="tactic">eapply</span> <span class="id">cenv_for_gen_domain</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">chunk</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id1</span>. <span class="tactic">elim</span> <span class="id">H4</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">ty</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">cenv_for_gen_compat</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">atk</span> <span class="id">id</span> <span class="id">vars</span>,<br/>
&nbsp;&nbsp;<span class="id">VSet.In</span> <span class="id">id</span> (<span class="id">cenv_for_gen</span> <span class="id">atk</span> <span class="id">vars</span>) -&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">atk</span> = <span class="id">false</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4405')">Proof.</div>
<div class="proofscript" id="proof4405">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VSF.empty_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">rewrite</span> <span class="id">add_local_variable_charact</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">chunk</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Compatibility between a compilation environment and an address-taken set. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">compat_cenv</span> (<span class="id">atk</span>: <span class="id">VSet.t</span>) (<span class="id">cenv</span>: <span class="id">compilenv</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">VSet.In</span> <span class="id">id</span> <span class="id">atk</span> -&gt; <span class="id">VSet.In</span> <span class="id">id</span> <span class="id">cenv</span> -&gt; <span class="id">False</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">compat_cenv_for</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">f</span>.(<span class="id">fn_body</span>)) (<span class="id">cenv_for</span> <span class="id">f</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4406')">Proof.</div>
<div class="proofscript" id="proof4406">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">VSet.mem</span> <span class="id">id</span> (<span class="id">addr_taken_stmt</span> (<span class="id">fn_body</span> <span class="id">f</span>)) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">cenv_for_gen_compat</span>. <span class="id">eexact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">VSF.mem_iff</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compat_cenv_union_l</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">atk1</span> <span class="id">atk2</span> <span class="id">cenv</span>,<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">VSet.union</span> <span class="id">atk1</span> <span class="id">atk2</span>) <span class="id">cenv</span> -&gt; <span class="id">compat_cenv</span> <span class="id">atk1</span> <span class="id">cenv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4407')">Proof.</div>
<div class="proofscript" id="proof4407">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">VSet.union_2</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compat_cenv_union_r</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">atk1</span> <span class="id">atk2</span> <span class="id">cenv</span>,<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">VSet.union</span> <span class="id">atk1</span> <span class="id">atk2</span>) <span class="id">cenv</span> -&gt; <span class="id">compat_cenv</span> <span class="id">atk2</span> <span class="id">cenv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4408')">Proof.</div>
<div class="proofscript" id="proof4408">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">VSet.union_3</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">compat_cenv_empty</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span>, <span class="id">compat_cenv</span> <span class="id">VSet.empty</span> <span class="id">cenv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4409')">Proof.</div>
<div class="proofscript" id="proof4409">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">VSet.empty_1</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">compat_cenv_union_l</span> <span class="id">compat_cenv_union_r</span> <span class="id">compat_cenv_empty</span>: <span class="id">compat</span>.<br/>
<br/>
<div class="doc">Allocation and initialization of parameters </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_variables_nextblock</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt; <span class="id">Ple</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4410')">Proof.</div>
<div class="proofscript" id="proof4410">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>. <span class="tactic">apply</span> <span class="id">Ple_succ</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_variables_range</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>'!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) \/ <span class="id">Ple</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4411')">Proof.</div>
<div class="proofscript" id="proof4411">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHalloc_variables</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id0</span>). <span class="id">inv</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">alloc_variables_nextblock</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>). <span class="tactic">intros</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">Ple_refl</span>. <span class="tactic">eapply</span> <span class="id">Plt_le_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">Plt_succ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">B</span>. <span class="tactic">rewrite</span> <span class="id">B</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_variables_injective</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">id1</span> <span class="id">b1</span> <span class="id">ty1</span> <span class="id">id2</span> <span class="id">b2</span> <span class="id">ty2</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="id">e</span>!<span class="id">id1</span> = <span class="id">Some</span>(<span class="id">b1</span>, <span class="id">ty1</span>) -&gt; <span class="id">e</span>!<span class="id">id2</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">ty2</span>) -&gt; <span class="id">id1</span> &lt;&gt; <span class="id">id2</span> -&gt; <span class="id">b1</span> &lt;&gt; <span class="id">b2</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">Plt</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">e</span>'!<span class="id">id1</span> = <span class="id">Some</span>(<span class="id">b1</span>, <span class="id">ty1</span>) -&gt; <span class="id">e</span>'!<span class="id">id2</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">ty2</span>) -&gt; <span class="id">id1</span> &lt;&gt; <span class="id">id2</span> -&gt; <span class="id">b1</span> &lt;&gt; <span class="id">b2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4412')">Proof.</div>
<div class="proofscript" id="proof4412">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHalloc_variables</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id1</span> <span class="id">id</span>); <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id2</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H6</span>. <span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H7</span>. <span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="id">inv</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_alloc_variables</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">tm</span> <span class="id">te</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>', <span class="id">exists</span> <span class="id">te</span>', <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">tm</span> (<span class="id">remove_lifted</span> <span class="id">cenv</span> <span class="id">vars</span>) <span class="id">te</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">j</span>' <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span> -&gt; <span class="id">j</span>' <span class="id">b</span> = <span class="id">j</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">b</span>' -&gt; <span class="id">j</span>' <span class="id">b</span> = <span class="id">j</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; ~<span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">b</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">id</span>, <span class="id">exists</span> <span class="id">ty</span>, <span class="id">e</span>'!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) /\ <span class="id">te</span>'!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>) /\ <span class="id">delta</span> = 0)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">e</span>'!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="kwd">if</span> <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">te</span>'!<span class="id">id</span> = <span class="id">te</span>!<span class="id">id</span> /\ <span class="id">j</span>' <span class="id">b</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">exists</span> <span class="id">tb</span>, <span class="id">te</span>'!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">tb</span>, <span class="id">ty</span>) /\ <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">tb</span>, 0))<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">id</span>, ~<span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>) -&gt; <span class="id">e</span>'!<span class="id">id</span> = <span class="id">e</span>!<span class="id">id</span> /\ <span class="id">te</span>'!<span class="id">id</span> = <span class="id">te</span>!<span class="id">id</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4413')">Proof.</div>
<div class="proofscript" id="proof4413">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>; <span class="id">exists</span> <span class="id">te</span>; <span class="id">exists</span> <span class="id">tm</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.  <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">Mem.mi_mappedblocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">tauto</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?. <span class="tactic">simpl</span>.<br/>
&nbsp;variable&nbsp;is&nbsp;lifted&nbsp;out&nbsp;of&nbsp;memory&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_left_unmapped_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j1</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHalloc_variables</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">te</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">te</span>' [<span class="id">tm</span>' [<span class="id">J</span> [<span class="id">K</span> [<span class="id">L</span> [<span class="id">M</span> [<span class="id">N</span> [<span class="id">Q</span> [<span class="id">O</span> <span class="id">P</span>]]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>'; <span class="id">exists</span> <span class="id">te</span>'; <span class="id">exists</span> <span class="id">tm</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">j1</span> <span class="id">b</span>). <span class="tactic">apply</span> <span class="id">M</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">D</span>. <span class="tactic">apply</span> <span class="id">Mem.valid_not_valid_diff</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">j1</span> <span class="id">b</span>). <span class="tactic">eapply</span> <span class="id">N</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">b1</span>); <span class="tactic">auto</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">j</span>' <span class="id">b1</span> = <span class="id">j1</span> <span class="id">b1</span>). <span class="tactic">apply</span> <span class="id">M</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;same&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ty0</span> = <span class="id">ty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">congruence</span>. <span class="tactic">elim</span> <span class="id">H5</span>. <span class="tactic">unfold</span> <span class="id">var_names</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">ty0</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ty0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">P</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> <span class="id">Y</span>]. <span class="tactic">rewrite</span> <span class="id">Heqb</span>. <span class="tactic">rewrite</span> <span class="id">X</span>. <span class="tactic">rewrite</span> <span class="id">Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b1</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">M</span>. <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;other&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">O</span>; <span class="tactic">eauto</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> (<span class="id">P</span> <span class="id">id0</span>). <span class="tactic">tauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> <span class="id">Y</span>]. <span class="tactic">rewrite</span> <span class="id">X</span>; <span class="tactic">rewrite</span> <span class="id">Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">PTree.gso</span>. <span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;variable&nbsp;is&nbsp;not&nbsp;lifted&nbsp;out&nbsp;of&nbsp;memory&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_parallel_inject</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>. <span class="tactic">apply</span> <span class="id">Zle_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j1</span> [<span class="id">tm1</span> [<span class="id">tb1</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> <span class="id">E</span>]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHalloc_variables</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">tb1</span>, <span class="id">ty</span>) <span class="id">te</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">te</span>' [<span class="id">tm</span>' [<span class="id">J</span> [<span class="id">K</span> [<span class="id">L</span> [<span class="id">M</span> [<span class="id">N</span> [<span class="id">Q</span> [<span class="id">O</span> <span class="id">P</span>]]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>'; <span class="id">exists</span> <span class="id">te</span>'; <span class="id">exists</span> <span class="id">tm</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">comp_env_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">j1</span> <span class="id">b</span>). <span class="tactic">apply</span> <span class="id">M</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">E</span>. <span class="tactic">apply</span> <span class="id">Mem.valid_not_valid_diff</span> <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">j1</span> <span class="id">b</span>). <span class="tactic">eapply</span> <span class="id">N</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">b1</span>); <span class="tactic">auto</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">j</span>' <span class="id">b1</span> = <span class="id">j1</span> <span class="id">b1</span>). <span class="tactic">apply</span> <span class="id">M</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">D</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H1</span>. <span class="id">eelim</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span>' <span class="id">tb1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>'. <span class="tactic">rewrite</span> (<span class="id">N</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>) <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">b1</span>). <span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">rewrite</span> <span class="id">D</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">P</span> <span class="id">id</span>); <span class="tactic">auto</span>. <span class="tactic">intros</span> [<span class="id">X</span> <span class="id">Y</span>]. <span class="id">exists</span> <span class="id">id</span>; <span class="id">exists</span> <span class="id">ty</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">X</span>; <span class="tactic">rewrite</span> <span class="id">Y</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gss</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">E</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">auto</span>. <span class="tactic">elim</span> <span class="id">H3</span>. <span class="tactic">eapply</span> <span class="id">Mem.mi_mappedblocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Q</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="id">exploit</span> <span class="id">Mem.alloc_result</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;same&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ty0</span> = <span class="id">ty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">congruence</span>. <span class="tactic">elim</span> <span class="id">H5</span>. <span class="tactic">unfold</span> <span class="id">var_names</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">ty0</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ty0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">P</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> <span class="id">Y</span>]. <span class="tactic">rewrite</span> <span class="id">Heqb</span>. <span class="tactic">rewrite</span> <span class="id">X</span>. <span class="tactic">rewrite</span> <span class="id">Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b1</span>. <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tb1</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">M</span>. <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;other&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">O</span> <span class="id">id0</span> <span class="id">ty0</span>). <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> (<span class="id">P</span> <span class="id">id0</span>). <span class="tactic">tauto</span>. <span class="tactic">intros</span> [<span class="id">X</span> <span class="id">Y</span>]. <span class="tactic">rewrite</span> <span class="id">X</span>; <span class="tactic">rewrite</span> <span class="id">Y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">apply</span> <span class="id">PTree.gso</span>; <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_variables_load</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> = <span class="id">Some</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4414')">Proof.</div>
<div class="proofscript" id="proof4414">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHalloc_variables</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_alloc_other</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sizeof_by_value</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span> <span class="id">chunk</span>,<br/>
&nbsp;&nbsp;<span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span> -&gt; <span class="id">size_chunk</span> <span class="id">chunk</span> &lt;= <span class="id">sizeof</span> <span class="id">ge</span> <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4415')">Proof.</div>
<div class="proofscript" id="proof4415">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">access_mode</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">size_chunk</span> <span class="id">chunk</span> = <span class="id">sizeof</span> <span class="id">ge</span> <span class="id">ty</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">try</span> <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> <span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">try</span> <span class="tactic">destruct</span> <span class="id">f</span>; <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mptr</span>; <span class="tactic">simpl</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">env_initial_value</span> (<span class="id">e</span>: <span class="id">env</span>) (<span class="id">m</span>: <span class="id">mem</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">chunk</span>,<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">Vundef</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">alloc_variables_initial_value</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span>' <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_initial_value</span> <span class="id">e</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_initial_value</span> <span class="id">e</span>' <span class="id">m</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4416')">Proof.</div>
<div class="proofscript" id="proof4416">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHalloc_variables</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_alloc_same</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">Zplus_0_l</span>. <span class="tactic">eapply</span> <span class="id">sizeof_by_value</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zdivide_0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_alloc_other</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span> <span class="id">vars</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt; (<span class="id">create_undef_temps</span> <span class="id">vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">Vundef</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4417')">Proof.</div>
<div class="proofscript" id="proof4417">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars</span> <span class="id">id</span> <span class="id">v</span>, (<span class="id">create_undef_temps</span> <span class="id">vars</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">v</span> = <span class="id">Vundef</span> /\ <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4418')">Proof.</div>
<div class="proofscript" id="proof4418">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">ty1</span>]. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHvars</span>; <span class="tactic">eauto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l1</span> <span class="id">l2</span>,<br/>
&nbsp;&nbsp;(<span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">l1</span>) &lt;-&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">l2</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">create_undef_temps</span> <span class="id">l1</span>)!<span class="id">id</span> = (<span class="id">create_undef_temps</span> <span class="id">l2</span>)!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4419')">Proof.</div>
<div class="proofscript" id="proof4419">
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">id</span> <span class="id">l1</span> <span class="id">l2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">l1</span>) -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">l2</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">create_undef_temps</span> <span class="id">l1</span>)!<span class="id">id</span> = <span class="id">None</span> \/ (<span class="id">create_undef_temps</span> <span class="id">l1</span>)!<span class="id">id</span> = (<span class="id">create_undef_temps</span> <span class="id">l2</span>)!<span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> ((<span class="id">create_undef_temps</span> <span class="id">l1</span>)!<span class="id">id</span>) <span class="kwd">as</span> [<span class="id">v1</span>|] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">create_undef_temps_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">subst</span> <span class="id">v1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">list_in_map_inv</span>. <span class="tactic">unfold</span> <span class="id">var_names</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="id">eexact</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id1</span> <span class="id">ty1</span>] [<span class="id">P</span> <span class="id">Q</span>]]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">P</span>; <span class="tactic">subst</span> <span class="id">id1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">create_undef_temps_charact</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">H</span> <span class="id">id</span> <span class="id">l1</span> <span class="id">l2</span>). <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">H</span> <span class="id">id</span> <span class="id">l2</span> <span class="id">l1</span>). <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">var_names_app</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars1</span> <span class="id">vars2</span>, <span class="id">var_names</span> (<span class="id">vars1</span> ++ <span class="id">vars2</span>) = <span class="id">var_names</span> <span class="id">vars1</span> ++ <span class="id">var_names</span> <span class="id">vars2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4420')">Proof.</div>
<div class="proofscript" id="proof4420">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">map_app</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_app</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">bool</span>) <span class="id">l1</span> <span class="id">l2</span>,<br/>
&nbsp;&nbsp;<span class="id">List.filter</span> <span class="id">f</span> (<span class="id">l1</span> ++ <span class="id">l2</span>) = <span class="id">List.filter</span> <span class="id">f</span> <span class="id">l1</span> ++ <span class="id">List.filter</span> <span class="id">f</span> <span class="id">l2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4421')">Proof.</div>
<div class="proofscript" id="proof4421">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">a</span>). <span class="tactic">simpl</span>. <span class="id">decEq</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">bool</span>) <span class="id">x</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">x</span> (<span class="id">List.filter</span> <span class="id">f</span> <span class="id">l</span>) &lt;-&gt; <span class="id">In</span> <span class="id">x</span> <span class="id">l</span> /\ <span class="id">f</span> <span class="id">x</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4422')">Proof.</div>
<div class="proofscript" id="proof4422">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">a</span>) <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">IHl</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_norepet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">bool</span>) <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">l</span> -&gt; <span class="id">list_norepet</span> (<span class="id">List.filter</span> <span class="id">f</span> <span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4423')">Proof.</div>
<div class="proofscript" id="proof4423">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">hd</span>); <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">filter_charact</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">filter_map</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span>: <span class="kwd">Type</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">pa</span>: <span class="id">A</span> -&gt; <span class="id">bool</span>) (<span class="id">pb</span>: <span class="id">B</span> -&gt; <span class="id">bool</span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">a</span>, <span class="id">pb</span> (<span class="id">f</span> <span class="id">a</span>) = <span class="id">pa</span> <span class="id">a</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">List.map</span> <span class="id">f</span> (<span class="id">List.filter</span> <span class="id">pa</span> <span class="id">l</span>) = <span class="id">List.filter</span> <span class="id">pb</span> (<span class="id">List.map</span> <span class="id">f</span> <span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4424')">Proof.</div>
<div class="proofscript" id="proof4424">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">pa</span> <span class="id">a</span>); <span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_lifted</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;~ <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> (<span class="id">fn_params</span> <span class="id">f</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">create_undef_temps</span> (<span class="id">add_lifted</span> (<span class="id">cenv_for</span> <span class="id">f</span>) (<span class="id">fn_vars</span> <span class="id">f</span>) (<span class="id">fn_temps</span> <span class="id">f</span>))) ! <span class="id">id</span> =<br/>
&nbsp;&nbsp;(<span class="id">create_undef_temps</span> (<span class="id">add_lifted</span> (<span class="id">cenv_for</span> <span class="id">f</span>) (<span class="id">fn_params</span> <span class="id">f</span> ++ <span class="id">fn_vars</span> <span class="id">f</span>) (<span class="id">fn_temps</span> <span class="id">f</span>))) ! <span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4425')">Proof.</div>
<div class="proofscript" id="proof4425">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">create_undef_temps_exten</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_lifted</span>. <span class="tactic">rewrite</span> <span class="id">filter_app</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">in_app</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">id1</span> <span class="id">ty1</span>] [<span class="id">P</span> <span class="id">Q</span>]]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="tactic">subst</span> <span class="id">id</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">filter_charact</span> <span class="kwd">in</span> <span class="id">Q</span>. <span class="tactic">destruct</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H</span>. <span class="id">change</span> <span class="id">id1</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id1</span>, <span class="id">ty1</span>)). <span class="tactic">apply</span> <span class="id">List.in_map</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">vars_and_temps_properties</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">params</span> <span class="id">vars</span> <span class="id">temps</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">params</span> ++ <span class="id">var_names</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_disjoint</span> (<span class="id">var_names</span> <span class="id">params</span>) (<span class="id">var_names</span> <span class="id">temps</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">params</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">list_norepet</span> (<span class="id">var_names</span> (<span class="id">remove_lifted</span> <span class="id">cenv</span> (<span class="id">params</span> ++ <span class="id">vars</span>)))<br/>
&nbsp;&nbsp;/\ <span class="id">list_disjoint</span> (<span class="id">var_names</span> <span class="id">params</span>) (<span class="id">var_names</span> (<span class="id">add_lifted</span> <span class="id">cenv</span> <span class="id">vars</span> <span class="id">temps</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4426')">Proof.</div>
<div class="proofscript" id="proof4426">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">list_norepet_app</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">unfold</span> <span class="id">remove_lifted</span>. <span class="tactic">unfold</span> <span class="id">var_names</span>. <span class="id">erewrite</span> <span class="id">filter_map</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="kwd">fun</span> <span class="id">a</span> =&gt; <span class="id">negb</span> (<span class="id">VSet.mem</span> <span class="id">a</span> <span class="id">cenv</span>)). 2: <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">filter_norepet</span>. <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">apply</span> <span class="id">list_norepet_append</span>; <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_lifted</span>. <span class="tactic">rewrite</span> <span class="id">var_names_app</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span> <span class="tactic">at</span> 2. <span class="id">erewrite</span> <span class="id">filter_map</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="kwd">fun</span> <span class="id">a</span> =&gt; <span class="id">VSet.mem</span> <span class="id">a</span> <span class="id">cenv</span>). 2: <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) <span class="kwd">with</span> (<span class="id">var_names</span> <span class="id">vars</span>).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">in_app</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">filter_charact</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">C</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">match_envs_alloc_variables</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span> <span class="id">m</span>' <span class="id">temps</span> <span class="id">j</span> <span class="id">tm</span>,<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">ge</span> <span class="id">empty_env</span> <span class="id">m</span> <span class="id">vars</span> <span class="id">e</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">chunk</span>, <span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_value</span> <span class="id">chunk</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span> -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>', <span class="id">exists</span> <span class="id">te</span>, <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">tge</span> <span class="id">empty_env</span> <span class="id">tm</span> (<span class="id">remove_lifted</span> <span class="id">cenv</span> <span class="id">vars</span>) <span class="id">te</span> <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">match_envs</span> <span class="id">j</span>' <span class="id">cenv</span> <span class="id">e</span> (<span class="id">create_undef_temps</span> <span class="id">temps</span>) <span class="id">m</span>' (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">te</span> (<span class="id">create_undef_temps</span> (<span class="id">add_lifted</span> <span class="id">cenv</span> <span class="id">vars</span> <span class="id">temps</span>)) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">j</span>' <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Mem.valid_block</span> <span class="id">m</span> <span class="id">b</span> -&gt; <span class="id">j</span>' <span class="id">b</span> = <span class="id">j</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">j</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">b</span>' -&gt; <span class="id">j</span>' <span class="id">b</span> = <span class="id">j</span> <span class="id">b</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">ty</span>) <span class="id">vars</span> -&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span> -&gt; <span class="id">exists</span> <span class="id">b</span>, <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4427')">Proof.</div>
<div class="proofscript" id="proof4427">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">match_alloc_variables</span> <span class="id">cenv</span>); <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">empty_env</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">te</span> [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> [<span class="id">E</span> [<span class="id">K</span> [<span class="id">F</span> <span class="id">G</span>]]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>'; <span class="id">exists</span> <span class="id">te</span>; <span class="id">exists</span> <span class="id">tm</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">ident_eq</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span> <span class="kwd">in</span> <span class="id">i</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id</span>' <span class="id">ty</span>] [<span class="id">EQ</span> <span class="id">IN</span>]]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">EQ</span>; <span class="tactic">subst</span> <span class="id">id</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">F</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> [<span class="id">P</span> <span class="id">R</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?.<br/>
&nbsp;local&nbsp;var,&nbsp;lifted&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">R</span> <span class="kwd">as</span> [<span class="id">U</span> <span class="id">V</span>]. <span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">chunk</span> <span class="id">X</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_lifted</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">Vundef</span>) (<span class="id">tv</span> := <span class="id">Vundef</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">U</span>; <span class="tactic">apply</span> <span class="id">PTree.gempty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_initial_value</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">unfold</span> <span class="id">empty_env</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H4</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">create_undef_temps_charact</span> <span class="kwd">with</span> <span class="id">ty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_lifted</span>. <span class="tactic">apply</span> <span class="id">in_or_app</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">filter_In</span>. <span class="tactic">auto</span>.<br/>
&nbsp;local&nbsp;var,&nbsp;not&nbsp;lifted&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">R</span> <span class="kwd">as</span> [<span class="id">tb</span> [<span class="id">U</span> <span class="id">V</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;non-local&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">G</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">empty_env</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intros</span> [<span class="id">U</span> <span class="id">V</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_var_not_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">n</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;temps&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">create_undef_temps_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span> <span class="kwd">in</span> <span class="id">Q</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id1</span> <span class="id">ty</span>] [<span class="id">EQ</span> <span class="id">IN</span>]]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">EQ</span>; <span class="tactic">subst</span> <span class="id">id1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">Vundef</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">create_undef_temps_charact</span> <span class="kwd">with</span> <span class="id">ty</span>. <span class="tactic">unfold</span> <span class="id">add_lifted</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_or_app</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;injective&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_injective</span>. <span class="id">eexact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H7</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;range&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">alloc_variables_range</span>. <span class="id">eexact</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;trange&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">alloc_variables_range</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;mapped&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">ident_eq</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">vars</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span> <span class="kwd">in</span> <span class="id">i</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id</span>' <span class="id">ty</span>'] [<span class="id">EQ</span> <span class="id">IN</span>]]; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">EQ</span>; <span class="tactic">subst</span> <span class="id">id</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">F</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">Q</span>. <span class="tactic">destruct</span> <span class="id">Q</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Q</span> <span class="kwd">as</span> [<span class="id">tb</span> [<span class="id">U</span> <span class="id">V</span>]]. <span class="id">exists</span> <span class="id">b</span>; <span class="tactic">split</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">G</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;flat&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">alloc_variables_range</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intros</span> [<span class="id">P</span>|<span class="id">P</span>]. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">K</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">id0</span> [<span class="id">ty0</span> [<span class="id">U</span> [<span class="id">V</span> <span class="id">W</span>]]]]. <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id</span> <span class="id">id0</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b</span>' &lt;&gt; <span class="id">b</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_injective</span> <span class="kwd">with</span> (<span class="id">e</span>' := <span class="id">te</span>) (<span class="id">id1</span> := <span class="id">id</span>) (<span class="id">id2</span> := <span class="id">id0</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ty1</span>; <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;incr&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;other&nbsp;properties&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="id">edestruct</span> <span class="id">F</span> <span class="kwd">as</span> (<span class="id">b</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span>); <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H5</span> <span class="kwd">in</span> <span class="id">Y</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Y</span> <span class="kwd">as</span> (<span class="id">tb</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>). <span class="id">exists</span> <span class="id">tb</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">assign_loc_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">tm</span> <span class="id">loc</span>' <span class="id">ofs</span>' <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">ge</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">loc</span> <span class="id">ofs</span>) (<span class="id">Vptr</span> <span class="id">loc</span>' <span class="id">ofs</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">tge</span> <span class="id">ty</span> <span class="id">tm</span> <span class="id">loc</span>' <span class="id">ofs</span>' <span class="id">v</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">b</span> <span class="id">chunk</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">None</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4428')">Proof.</div>
<div class="proofscript" id="proof4428">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="comment">(*&nbsp;by&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_mapped_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>'; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">assign_loc_value</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H5</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">congruence</span>.<br/>
- <span class="comment">(*&nbsp;by&nbsp;copy&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">b</span>' <span class="id">into</span> <span class="id">bsrc</span>. <span class="tactic">rename</span> <span class="id">ofs</span>'0 <span class="id">into</span> <span class="id">osrc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">loc</span> <span class="id">into</span> <span class="id">bdst</span>. <span class="tactic">rename</span> <span class="id">ofs</span> <span class="id">into</span> <span class="id">odst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rename</span> <span class="id">loc</span>' <span class="id">into</span> <span class="id">bdst</span>'. <span class="tactic">rename</span> <span class="id">b2</span> <span class="id">into</span> <span class="id">bsrc</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">comp_env_preserved</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span>) 0).<br/>
+ <span class="comment">(*&nbsp;special&nbsp;case&nbsp;size&nbsp;=&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">bytes</span> = <span class="id">nil</span>).<br/>
&nbsp;&nbsp;{ <span class="id">exploit</span> (<span class="id">Mem.loadbytes_empty</span> <span class="id">m</span> <span class="id">bsrc</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">osrc</span>) (<span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>. <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.range_perm_storebytes</span> <span class="id">tm</span> <span class="id">bdst</span>' (<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">odst</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>))) <span class="id">nil</span>)<br/>
&nbsp;&nbsp;<span class="kwd">as</span> [<span class="id">tm</span>' <span class="id">SB</span>].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">assign_loc_copy</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">e</span>; <span class="id">right</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.loadbytes_empty</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">Mem.storebytes_empty_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_storebytes_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">congruence</span>.<br/>
+ <span class="comment">(*&nbsp;general&nbsp;case&nbsp;size&nbsp;&gt;&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_length</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">LEN</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SZPOS</span>: <span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span> &gt; 0).<br/>
&nbsp;&nbsp;{ <span class="tactic">generalize</span> (<span class="id">sizeof_pos</span> <span class="id">tge</span> <span class="id">ty</span>); <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RPSRC</span>: <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">bsrc</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">osrc</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">osrc</span> + <span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span>) <span class="id">Cur</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.range_perm_implies</span>. <span class="tactic">eapply</span> <span class="id">Mem.loadbytes_range_perm</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">RPDST</span>: <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">bdst</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">odst</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">odst</span> + <span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span>) <span class="id">Cur</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">sizeof</span> <span class="id">tge</span> <span class="id">ty</span>) <span class="kwd">with</span> (<span class="id">Z_of_nat</span> (<span class="id">length</span> <span class="id">bytes</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.range_perm_implies</span>. <span class="tactic">eapply</span> <span class="id">Mem.storebytes_range_perm</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">LEN</span>. <span class="tactic">apply</span> <span class="id">nat_of_Z_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PSRC</span>: <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">bsrc</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">osrc</span>) <span class="id">Cur</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">RPSRC</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PDST</span>: <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">bdst</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">odst</span>) <span class="id">Cur</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">RPDST</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.address_inject</span>.  <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">PSRC</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.address_inject</span>.  <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">PDST</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ2</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadbytes_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">bytes2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storebytes_mapped_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">assign_loc_copy</span>; <span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">EQ1</span>; <span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">EQ2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.aligned_area_inject</span> <span class="kwd">with</span> (<span class="id">m</span> := <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">alignof_blockcopy_1248</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sizeof_alignof_blockcopy_compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.aligned_area_inject</span> <span class="kwd">with</span> (<span class="id">m</span> := <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">alignof_blockcopy_1248</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sizeof_alignof_blockcopy_compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.disjoint_or_equal_inject</span> <span class="kwd">with</span> (<span class="id">m</span> := <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.range_perm_max</span> <span class="kwd">with</span> <span class="id">Cur</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.range_perm_max</span> <span class="kwd">with</span> <span class="id">Cur</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_storebytes_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">assign_loc_nextblock</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">ge</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' -&gt; <span class="id">Mem.nextblock</span> <span class="id">m</span>' = <span class="id">Mem.nextblock</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4429')">Proof.</div>
<div class="proofscript" id="proof4429">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">Mem.nextblock_store</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.nextblock_storebytes</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">store_params_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">f</span> <span class="id">k</span> <span class="id">cenv</span> <span class="id">le</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">e</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">tm</span> <span class="id">tle1</span> <span class="id">tle2</span> <span class="id">targs</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">var_names</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">args</span> (<span class="id">map</span> <span class="id">snd</span> <span class="id">params</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">args</span> <span class="id">targs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle1</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, ~<span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">params</span>) -&gt; <span class="id">tle2</span>!<span class="id">id</span> = <span class="id">tle1</span>!<span class="id">id</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">In</span> <span class="id">id</span> (<span class="id">var_names</span> <span class="id">params</span>) -&gt; <span class="id">le</span>!<span class="id">id</span> = <span class="id">None</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tle</span>, <span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step2</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">store_params</span> <span class="id">cenv</span> <span class="id">params</span> <span class="id">s</span>) <span class="id">k</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">bind_parameter_temps</span> <span class="id">params</span> <span class="id">targs</span> <span class="id">tle2</span> = <span class="id">Some</span> <span class="id">tle</span><br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">match_envs</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>' <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span><br/>
&nbsp;&nbsp;/\ <span class="id">Mem.nextblock</span> <span class="id">tm</span>' = <span class="id">Mem.nextblock</span> <span class="id">tm</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4430')">Proof.</div>
<div class="proofscript" id="proof4430">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">targs</span>; <span class="tactic">intros</span> <span class="id">NOREPET</span> <span class="id">CASTED</span> <span class="id">VINJ</span> <span class="id">MENV</span> <span class="id">MINJ</span> <span class="id">TLE</span> <span class="id">LE</span>.<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">VINJ</span>. <span class="id">exists</span> <span class="id">tle2</span>; <span class="id">exists</span> <span class="id">tm</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">match_envs_temps_exten</span> <span class="kwd">with</span> <span class="id">tle1</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">NOREPET</span>. <span class="id">inv</span> <span class="id">CASTED</span>. <span class="id">inv</span> <span class="id">VINJ</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">id</span>); <span class="tactic">intros</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?.<br/>
&nbsp;lifted&nbsp;to&nbsp;temp&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHbind_parameters</span> <span class="kwd">with</span> (<span class="id">tle1</span> := <span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span>' <span class="id">tle1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_assign_lifted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>. <span class="tactic">rewrite</span> <span class="id">ENV</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.storev</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">Mem.store_unmapped_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">TLE</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;still&nbsp;in&nbsp;memory&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>. <span class="tactic">rewrite</span> <span class="id">ENV</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">assign_loc_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tm1</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHbind_parameters</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span>' <span class="id">tle1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_envs_change_temp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">LE</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span>' <span class="id">tle2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">TLE</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">LE</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">s</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tle</span> [<span class="id">tm</span>' [<span class="id">U</span> [<span class="id">V</span> [<span class="id">X</span> [<span class="id">Y</span> <span class="id">Z</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tle</span>; <span class="id">exists</span> <span class="id">tm</span>'; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_trans</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_Evar_local</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_Etempvar</span>. <span class="id">erewrite</span> <span class="id">bind_parameter_temps_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">instantiate</span> (1 := <span class="id">v</span>'). <span class="tactic">apply</span> <span class="id">cast_val_casted</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">val_casted_inject</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">U</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">assign_loc_nextblock</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>) <span class="kwd">in</span> <span class="id">Z</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bind_parameters_nextblock</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>' -&gt; <span class="id">Mem.nextblock</span> <span class="id">m</span>' = <span class="id">Mem.nextblock</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4431')">Proof.</div>
<div class="proofscript" id="proof4431">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHbind_parameters</span>. <span class="tactic">eapply</span> <span class="id">assign_loc_nextblock</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bind_parameters_load</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">chunk</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>' <span class="id">ty</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>) -&gt; <span class="id">b</span> &lt;&gt; <span class="id">b</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">m</span> <span class="id">params</span> <span class="id">args</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> = <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4432')">Proof.</div>
<div class="proofscript" id="proof4432">
&nbsp;&nbsp;<span class="tactic">induction</span> 2.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHbind_parameters</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b</span> &lt;&gt; <span class="id">b0</span>) <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_storebytes_other</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Freeing of local variables </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_blocks_of_env_perm_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">m</span> <span class="id">e</span> <span class="id">m</span>' <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">ce</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">ofs</span> &lt; <span class="id">sizeof</span> <span class="id">ce</span> <span class="id">ty</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">False</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4433')">Proof.</div>
<div class="proofscript" id="proof4433">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">Mem.perm_free_list</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">B</span> <span class="kwd">with</span> 0 (<span class="id">sizeof</span> <span class="id">ce</span> <span class="id">ty</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>. <span class="id">change</span> (<span class="id">b</span>, 0, <span class="id">sizeof</span> <span class="id">ce</span> <span class="id">ty</span>) <span class="kwd">with</span> (<span class="id">block_of_binding</span> <span class="id">ce</span> (<span class="id">id</span>, (<span class="id">b</span>, <span class="id">ty</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_map</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_list_perm</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">l</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">Cur</span> <span class="id">Freeable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4434')">Proof.</div>
<div class="proofscript" id="proof4434">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b1</span> <span class="id">lo1</span>] <span class="id">hi1</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b1</span> <span class="id">lo1</span> <span class="id">hi1</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">eapply</span> <span class="id">Mem.free_range_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_free_3</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_blocks_of_env_perm_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">m</span> <span class="id">e</span> <span class="id">m</span>' <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">ce</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> 0 (<span class="id">sizeof</span> <span class="id">ce</span> <span class="id">ty</span>) <span class="id">Cur</span> <span class="id">Freeable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4435')">Proof.</div>
<div class="proofscript" id="proof4435">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">free_list_perm</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>. <span class="id">change</span> (<span class="id">b</span>, 0, <span class="id">sizeof</span> <span class="id">ce</span> <span class="id">ty</span>) <span class="kwd">with</span> (<span class="id">block_of_binding</span> <span class="id">ce</span> (<span class="id">id</span>, (<span class="id">b</span>, <span class="id">ty</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_map</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">freelist_no_overlap</span> (<span class="id">l</span>: <span class="id">list</span> (<span class="id">block</span> * <span class="id">Z</span> * <span class="id">Z</span>)) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) :: <span class="id">l</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">freelist_no_overlap</span> <span class="id">l</span>' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>' <span class="id">lo</span>' <span class="id">hi</span>', <span class="id">In</span> (<span class="id">b</span>', <span class="id">lo</span>', <span class="id">hi</span>') <span class="id">l</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">b</span>' &lt;&gt; <span class="id">b</span> \/ <span class="id">hi</span>' &lt;= <span class="id">lo</span> \/ <span class="id">hi</span> &lt;= <span class="id">lo</span>')<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">can_free_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>, <span class="id">In</span> (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">l</span> -&gt; <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">Cur</span> <span class="id">Freeable</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">freelist_no_overlap</span> <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>', <span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4436')">Proof.</div>
<div class="proofscript" id="proof4436">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">exists</span> <span class="id">m</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span> <span class="id">lo</span>] <span class="id">hi</span>]. <span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.range_perm_free</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>) <span class="kwd">as</span> [<span class="id">m1</span> <span class="id">A</span>]; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">IHl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_free_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">B</span>|<span class="id">B</span>]. <span class="tactic">auto</span>. <span class="id">right</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">blocks_of_env_no_overlap</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ge</span>: <span class="id">genv</span>) <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">tm</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> 0 (<span class="id">sizeof</span> <span class="id">ge</span> <span class="id">ty</span>) <span class="id">Cur</span> <span class="id">Freeable</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">List.map</span> <span class="id">fst</span> <span class="id">l</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">bty</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">bty</span>) <span class="id">l</span> -&gt; <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">bty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">freelist_no_overlap</span> (<span class="id">List.map</span> (<span class="id">block_of_binding</span> <span class="id">ge</span>) <span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4437')">Proof.</div>
<div class="proofscript" id="proof4437">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">tm</span>; <span class="tactic">intros</span> <span class="id">ME</span> <span class="id">MINJ</span> <span class="id">PERMS</span>. <span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> [<span class="id">b</span> <span class="id">ty</span>]]. <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">apply</span> <span class="id">IHl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">id</span>' [<span class="id">b</span>'' <span class="id">ty</span>']] [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">inv</span> <span class="id">A</span>. <span class="tactic">rename</span> <span class="id">b</span>'' <span class="id">into</span> <span class="id">b</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TE</span>: <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>)) <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">TE</span>': <span class="id">te</span>!<span class="id">id</span>' = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ty</span>')) <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_mapped</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">TE</span>. <span class="tactic">intros</span> [<span class="id">b0</span> [<span class="id">INJ</span> <span class="id">E</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_mapped</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">TE</span>'. <span class="tactic">intros</span> [<span class="id">b0</span>' [<span class="id">INJ</span>' <span class="id">E</span>']].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> (<span class="id">sizeof</span> <span class="id">ge0</span> <span class="id">ty</span>) 0); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> (<span class="id">sizeof</span> <span class="id">ge0</span> <span class="id">ty</span>') 0); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">b0</span> &lt;&gt; <span class="id">b0</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">me_inj</span>; <span class="tactic">eauto</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span>; <span class="tactic">elim</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> <span class="id">id</span>' <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>', (<span class="id">b</span>', <span class="id">ty</span>'))). <span class="tactic">apply</span> <span class="id">List.in_map</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">b0</span> 0 <span class="id">Max</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Mem.perm_cur_max</span>. <span class="tactic">apply</span> <span class="id">Mem.perm_implies</span> <span class="kwd">with</span> <span class="id">Freeable</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">PERMS</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">b0</span>' 0 <span class="id">Max</span> <span class="id">Nonempty</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Mem.perm_cur_max</span>. <span class="tactic">apply</span> <span class="id">Mem.perm_implies</span> <span class="kwd">with</span> <span class="id">Freeable</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">PERMS</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.mi_no_overlap</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>]. <span class="tactic">auto</span>. <span class="id">omegaContradiction</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_list_right_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">m1</span> <span class="id">l</span> <span class="id">m2</span> <span class="id">m2</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m1</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m2</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m2</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">delta</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">j</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt; <span class="id">In</span> (<span class="id">b2</span>, <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.perm</span> <span class="id">m1</span> <span class="id">b1</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">lo</span> &lt;= <span class="id">ofs</span> + <span class="id">delta</span> &lt; <span class="id">hi</span> -&gt; <span class="id">False</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m1</span> <span class="id">m2</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4438')">Proof.</div>
<div class="proofscript" id="proof4438">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span> <span class="id">lo</span>] <span class="id">hi</span>]. <span class="tactic">destruct</span> (<span class="id">Mem.free</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>) <span class="kwd">as</span> [<span class="id">m21</span>|] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHl</span> <span class="kwd">with</span> (<span class="id">m2</span> := <span class="id">m21</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_right_inject</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">blocks_of_env_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">blocks_of_env</span> <span class="id">tge</span> <span class="id">e</span> = <span class="id">blocks_of_env</span> <span class="id">ge</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4439')">Proof.</div>
<div class="proofscript" id="proof4439">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">blocks_of_env</span>, <span class="id">block_of_binding</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">comp_env_preserved</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">match_envs_free_blocks</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">m</span>' <span class="id">tm</span>,<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">ge</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">tm</span> (<span class="id">blocks_of_env</span> <span class="id">tge</span> <span class="id">te</span>) = <span class="id">Some</span> <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span>' <span class="id">tm</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4440')">Proof.</div>
<div class="proofscript" id="proof4440">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">X</span>: <span class="id">exists</span> <span class="id">tm</span>', <span class="id">Mem.free_list</span> <span class="id">tm</span> (<span class="id">blocks_of_env</span> <span class="id">tge</span> <span class="id">te</span>) = <span class="id">Some</span> <span class="id">tm</span>').<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">blocks_of_env_translated</span>. <span class="tactic">apply</span> <span class="id">can_free_list</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;permissions&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">blocks_of_env</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">id</span> [<span class="id">b</span>' <span class="id">ty</span>]] [<span class="id">EQ</span> <span class="id">IN</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block_of_binding</span> <span class="kwd">in</span> <span class="id">EQ</span>; <span class="id">inv</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_mapped</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">PTree.elements_complete</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> 0 <span class="kwd">with</span> (0 + 0). <span class="tactic">replace</span> (<span class="id">sizeof</span> <span class="id">ge</span> <span class="id">ty</span>) <span class="kwd">with</span> (<span class="id">sizeof</span> <span class="id">ge</span> <span class="id">ty</span> + 0) <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.range_perm_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">free_blocks_of_env_perm_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;no&nbsp;overlap&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>; <span class="tactic">eapply</span> <span class="id">blocks_of_env_no_overlap</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">free_blocks_of_env_perm_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.elements_keys_norepet</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_complete</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">X</span> <span class="kwd">as</span> [<span class="id">tm</span>' <span class="id">FREE</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">free_list_right_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_list_left_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">blocks_of_env</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id</span> [<span class="id">b</span>' <span class="id">ty</span>]] [<span class="id">EQ</span> <span class="id">IN</span>]]. <span class="tactic">unfold</span> <span class="id">block_of_binding</span> <span class="kwd">in</span> <span class="id">EQ</span>. <span class="id">inv</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_flat</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_complete</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="tactic">subst</span> <span class="id">delta</span>. <span class="tactic">eapply</span> <span class="id">free_blocks_of_env_perm_1</span> <span class="kwd">with</span> (<span class="id">m</span> := <span class="id">m</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">comp_env_preserved</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching global environments </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_globalenvs</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">bound</span>: <span class="id">block</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">mk_match_globalenvs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">DOMAIN</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>, 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">IMAGE</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">delta</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt; <span class="id">Plt</span> <span class="id">b2</span> <span class="id">bound</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SYMBOLS</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>, <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FUNCTIONS</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">fd</span>, <span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VARINFOS</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">gv</span>, <span class="id">Genv.find_var_info</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">gv</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_globalenvs_preserves_globals</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">bound</span>, <span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">bound</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">ge</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4441')">Proof.</div>
<div class="proofscript" id="proof4441">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">bound</span> <span class="id">MG</span>]. <span class="id">inv</span> <span class="id">MG</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">eauto</span>. <span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">eauto</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">IMAGE</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Evaluation of expressions </div>
<br/>
<span class="kwd">Section</span> <span class="id">EVAL_EXPR</span>.<br/>
<br/>
<span class="kwd">Variables</span> <span class="id">e</span> <span class="id">te</span>: <span class="id">env</span>.<br/>
<span class="kwd">Variables</span> <span class="id">le</span> <span class="id">tle</span>: <span class="id">temp_env</span>.<br/>
<span class="kwd">Variables</span> <span class="id">m</span> <span class="id">tm</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cenv</span>: <span class="id">compilenv</span>.<br/>
<span class="kwd">Variables</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">tlo</span> <span class="id">thi</span>: <span class="id">block</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">MATCH</span>: <span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">MEMINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">GLOB</span>: <span class="id">exists</span> <span class="id">bound</span>, <span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">bound</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">typeof_simpl_expr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span>, <span class="id">typeof</span> (<span class="id">simpl_expr</span> <span class="id">cenv</span> <span class="id">a</span>) = <span class="id">typeof</span> <span class="id">a</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4442')">Proof.</div>
<div class="proofscript" id="proof4442">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">i</span> <span class="id">cenv</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">deref_loc_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">loc</span>' <span class="id">ofs</span>',<br/>
&nbsp;&nbsp;<span class="id">deref_loc</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">loc</span> <span class="id">ofs</span>) (<span class="id">Vptr</span> <span class="id">loc</span>' <span class="id">ofs</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>, <span class="id">deref_loc</span> <span class="id">ty</span> <span class="id">tm</span> <span class="id">loc</span>' <span class="id">ofs</span>' <span class="id">tv</span> /\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4443')">Proof.</div>
<div class="proofscript" id="proof4443">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;by&nbsp;value&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">deref_loc_value</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;by&nbsp;reference&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vptr</span> <span class="id">loc</span>' <span class="id">ofs</span>'); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">deref_loc_reference</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;by&nbsp;copy&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vptr</span> <span class="id">loc</span>' <span class="id">ofs</span>'); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">deref_loc_copy</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_simpl_expr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_expr</span> <span class="id">a</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>, <span class="id">eval_expr</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span> (<span class="id">simpl_expr</span> <span class="id">cenv</span> <span class="id">a</span>) <span class="id">tv</span> /\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span><br/>
<br/>
<span class="kwd">with</span> <span class="id">eval_simpl_lvalue</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_lvalue</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_expr</span> <span class="id">a</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span> <span class="id">Evar</span> <span class="id">id</span> <span class="id">ty</span> =&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span> | <span class="id">_</span> =&gt; <span class="id">True</span> <span class="kwd">end</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>', <span class="id">exists</span> <span class="id">ofs</span>', <span class="id">eval_lvalue</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span> (<span class="id">simpl_expr</span> <span class="id">cenv</span> <span class="id">a</span>) <span class="id">b</span>' <span class="id">ofs</span>' /\ <span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) (<span class="id">Vptr</span> <span class="id">b</span>' <span class="id">ofs</span>').<br/>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4444')">Proof.</div>
<div class="proofscript" id="proof4444">
&nbsp;&nbsp;<span class="tactic">destruct</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;const&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vint</span> <span class="id">i</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vfloat</span> <span class="id">f0</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vsingle</span> <span class="id">f0</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vlong</span> <span class="id">i</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;tempvar&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_temps</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]] <span class="id">C</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;addrof&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_lvalue</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">i</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">H0</span> <span class="id">i</span>). <span class="tactic">apply</span> <span class="id">VSet.singleton_2</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">VSet.mem_2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b</span>' [<span class="id">ofs</span>' [<span class="id">A</span> <span class="id">B</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vptr</span> <span class="id">b</span>' <span class="id">ofs</span>'); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;unop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_unary_operation_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;binop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>. <span class="id">eexact</span> <span class="id">H</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_binary_operation_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">E</span> <span class="id">F</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">rewrite</span> <span class="id">comp_env_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;cast&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_cast_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;sizeof&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">comp_env_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;alignof&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">rewrite</span> <span class="id">comp_env_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;rval&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EITHER</span>: (<span class="id">exists</span> <span class="id">id</span>, <span class="id">exists</span> <span class="id">ty</span>, <span class="id">a</span> = <span class="id">Evar</span> <span class="id">id</span> <span class="id">ty</span> /\ <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/ (<span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span> <span class="id">Evar</span> <span class="id">id</span> <span class="id">_</span> =&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span> | <span class="id">_</span> =&gt; <span class="id">True</span> <span class="kwd">end</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">i</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?; <span class="tactic">auto</span>. <span class="id">left</span>; <span class="id">exists</span> <span class="id">i</span>; <span class="id">exists</span> <span class="id">t</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">EITHER</span> <span class="kwd">as</span> [ [<span class="id">id</span> [<span class="id">ty</span> [<span class="id">EQ</span> <span class="id">OPT</span>]]] | <span class="id">NONOPT</span> ].<br/>
&nbsp;a&nbsp;variable&nbsp;pulled&nbsp;out&nbsp;of&nbsp;memory&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">OPT</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">id</span>). <span class="tactic">intros</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ENV</span> <span class="kwd">in</span> <span class="id">H6</span>; <span class="id">inv</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">chunk0</span> = <span class="id">chunk</span>). <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">chunk0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">v0</span> = <span class="id">v</span>). <span class="tactic">unfold</span> <span class="id">Mem.loadv</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.unsigned_zero</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">v0</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;any&nbsp;other&nbsp;l-value&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_lvalue</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">loc</span>' [<span class="id">ofs</span>' [<span class="id">A</span> <span class="id">B</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">deref_loc_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;lvalues&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;local&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">id</span>). <span class="tactic">intros</span> <span class="id">MV</span>. <span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ENV</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>'; <span class="id">exists</span> <span class="id">Ptrofs.zero</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_Evar_local</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;global&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">id</span>). <span class="tactic">intros</span> <span class="id">MV</span>. <span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">l</span>; <span class="id">exists</span> <span class="id">Ptrofs.zero</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_Evar_global</span>. <span class="tactic">auto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">GLOB</span> <span class="kwd">as</span> [<span class="id">bound</span> <span class="id">GLOB1</span>]. <span class="id">inv</span> <span class="id">GLOB1</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;deref&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">B</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;field&nbsp;struct&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">comp_env_preserved</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">B</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_Efield_struct</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_assoc</span>. <span class="id">decEq</span>. <span class="tactic">apply</span> <span class="id">Ptrofs.add_commut</span>.<br/>
&nbsp;field&nbsp;union&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">comp_env_preserved</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">B</span>. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_Efield_union</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_simpl_exprlist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_exprlist</span> <span class="id">al</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">val_casted_list</span> <span class="id">vl</span> <span class="id">tyl</span> /\<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tvl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span> (<span class="id">simpl_exprlist</span> <span class="id">cenv</span> <span class="id">al</span>) <span class="id">tyl</span> <span class="id">tvl</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">vl</span> <span class="id">tvl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4445')">Proof.</div>
<div class="proofscript" id="proof4445">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">constructor</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_cast_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_exprlist</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">E</span> [<span class="id">tvl</span> [<span class="id">F</span> <span class="id">G</span>]]].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">cast_val_is_casted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">tv2</span> :: <span class="id">tvl</span>); <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">EVAL_EXPR</span>.<br/>
<br/>
<div class="doc">Matching continuations </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_cont</span> (<span class="id">f</span>: <span class="id">meminj</span>): <span class="id">compilenv</span> -&gt; <span class="id">cont</span> -&gt; <span class="id">cont</span> -&gt; <span class="id">mem</span> -&gt; <span class="id">block</span> -&gt; <span class="id">block</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_Kstop</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">hi</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">hi</span> -&gt; <span class="id">Ple</span> <span class="id">hi</span> <span class="id">bound</span> -&gt; <span class="id">Ple</span> <span class="id">hi</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">Kstop</span> <span class="id">Kstop</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kseq</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">s</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">s</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> (<span class="id">Kseq</span> <span class="id">s</span> <span class="id">k</span>) (<span class="id">Kseq</span> <span class="id">ts</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kloop1</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s2</span> = <span class="id">OK</span> <span class="id">ts2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">VSet.union</span> (<span class="id">addr_taken_stmt</span> <span class="id">s1</span>) (<span class="id">addr_taken_stmt</span> <span class="id">s2</span>)) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> (<span class="id">Kloop1</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>) (<span class="id">Kloop1</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kloop2</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s2</span> = <span class="id">OK</span> <span class="id">ts2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">VSet.union</span> (<span class="id">addr_taken_stmt</span> <span class="id">s1</span>) (<span class="id">addr_taken_stmt</span> <span class="id">s2</span>)) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> (<span class="id">Kloop2</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>) (<span class="id">Kloop2</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kswitch</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> (<span class="id">Kswitch</span> <span class="id">k</span>) (<span class="id">Kswitch</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kcall</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">optid</span> <span class="id">fn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">k</span> <span class="id">tfn</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">hi</span> <span class="id">thi</span> <span class="id">lo</span> <span class="id">tlo</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">fn</span> = <span class="id">OK</span> <span class="id">tfn</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> (<span class="id">cenv_for</span> <span class="id">fn</span>) <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> (<span class="id">cenv_for</span> <span class="id">fn</span>) <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">tlo</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">check_opttemp</span> (<span class="id">cenv_for</span> <span class="id">fn</span>) <span class="id">optid</span> = <span class="id">OK</span> <span class="id">x</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">hi</span> <span class="id">bound</span> -&gt; <span class="id">Ple</span> <span class="id">thi</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> (<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">fn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">tfn</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<br/>
<div class="doc">Invariance property by change of memory and injection </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>' <span class="id">m</span>' <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">chunk</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">None</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> 0 = <span class="id">Some</span> <span class="id">v</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">f</span>' <span class="id">b</span> = <span class="id">f</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">f</span>' <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Plt</span> <span class="id">b</span>' <span class="id">tbound</span> -&gt; <span class="id">f</span>' <span class="id">b</span> = <span class="id">f</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span>' <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span>' <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4446')">Proof.</div>
<div class="proofscript" id="proof4446">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">LOAD</span> <span class="id">INCR</span> <span class="id">INJ1</span> <span class="id">INJ2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;globalenvs&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f</span> <span class="id">b1</span> = <span class="id">Some</span> (<span class="id">b2</span>, <span class="id">delta</span>)). <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">INJ2</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IMAGE</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">LOAD</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">INJ1</span>; <span class="tactic">auto</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">INJ2</span>; <span class="tactic">eauto</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHmatch_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">LOAD</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">INJ1</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">INJ2</span>; <span class="tactic">eauto</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by assignment to location "above" </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_assign_loc</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">ty</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">ge</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> <span class="id">loc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span>' <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4447')">Proof.</div>
<div class="proofscript" id="proof4447">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_cont_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;scalar&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>; <span class="tactic">eauto</span>. <span class="id">left</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
&nbsp;block&nbsp;copy&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_storebytes_other</span>; <span class="tactic">eauto</span>. <span class="id">left</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by external calls </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_extcall</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">tm</span> <span class="id">f</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> (<span class="id">loc_unmapped</span> <span class="id">f</span>) <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_separated</span> <span class="id">f</span> <span class="id">f</span>' <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt; <span class="id">Ple</span> <span class="id">tbound</span> (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span>' <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span>' <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4448')">Proof.</div>
<div class="proofscript" id="proof4448">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_cont_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>] | ] <span class="id">eqn</span>:?. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span>' <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>] | ] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="id">xomegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>'' <span class="id">delta</span>''] | ] <span class="id">eqn</span>:?. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">Mem.valid_block</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="id">xomegaContradiction</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by change of bounds </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_incr_bounds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bound</span>' <span class="id">tbound</span>',<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> <span class="id">bound</span>' -&gt; <span class="id">Ple</span> <span class="id">tbound</span> <span class="id">tbound</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span>' <span class="id">tbound</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4449')">Proof.</div>
<div class="proofscript" id="proof4449">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_cont</span></span> and call continuations. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_change_cenv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">cenv</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_call_cont</span> <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span>' <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4450')">Proof.</div>
<div class="proofscript" id="proof4450">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="id">contradiction</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_is_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_call_cont</span> <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_call_cont</span> <span class="id">tk</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4451')">Proof.</div>
<div class="proofscript" id="proof4451">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span>' (<span class="id">call_cont</span> <span class="id">k</span>) (<span class="id">call_cont</span> <span class="id">tk</span>) <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4452')">Proof.</div>
<div class="proofscript" id="proof4452">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_cont</span></span> and freeing of environment blocks </div>
<br/>
<span class="kwd">Remark</span> <span class="id">free_list_nextblock</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt; <span class="id">Mem.nextblock</span> <span class="id">m</span>' = <span class="id">Mem.nextblock</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4453')">Proof.</div>
<div class="proofscript" id="proof4453">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> <span class="id">p</span>. <span class="tactic">destruct</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span> <span class="id">z0</span> <span class="id">z</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>). <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.nextblock_free</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">free_list_load</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">b</span>' <span class="id">l</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>, <span class="id">In</span> (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">l</span> -&gt; <span class="id">Plt</span> <span class="id">b</span>' <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span>' 0 = <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span>' 0.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4454')">Proof.</div>
<div class="proofscript" id="proof4454">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>. <span class="tactic">destruct</span> <span class="id">p</span>. <span class="tactic">destruct</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span> <span class="id">z0</span> <span class="id">z</span>) <span class="kwd">as</span> [<span class="id">m1</span>|] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m1</span> <span class="id">b</span>' 0). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_free</span>. <span class="tactic">eauto</span>. <span class="id">left</span>. <span class="tactic">assert</span> (<span class="id">Plt</span> <span class="id">b</span>' <span class="id">b</span>) <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_free_env</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span> <span class="id">tlo</span> <span class="id">thi</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span>' <span class="id">tm</span>',<br/>
&nbsp;&nbsp;<span class="id">match_envs</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">tlo</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">hi</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">thi</span> (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">ge</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">tm</span> (<span class="id">blocks_of_env</span> <span class="id">tge</span> <span class="id">te</span>) = <span class="id">Some</span> <span class="id">tm</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span>' (<span class="id">Mem.nextblock</span> <span class="id">m</span>') (<span class="id">Mem.nextblock</span> <span class="id">tm</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4455')">Proof.</div>
<div class="proofscript" id="proof4455">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_cont_incr_bounds</span> <span class="kwd">with</span> <span class="id">lo</span> <span class="id">tlo</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H7</span>. <span class="tactic">eapply</span> <span class="id">free_list_load</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [[<span class="id">id</span> [<span class="id">b1</span> <span class="id">ty</span>]] [<span class="id">P</span> <span class="id">Q</span>]]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">P</span>. <span class="id">inv</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_range</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">PTree.elements_complete</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">free_list_nextblock</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H3</span>). <span class="id">inv</span> <span class="id">H</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">free_list_nextblock</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H4</span>). <span class="id">inv</span> <span class="id">H</span>; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Matching of global environments </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_globalenv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bound</span>, <span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">bound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4456')">Proof.</div>
<div class="proofscript" id="proof4456">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">auto</span>. <span class="id">exists</span> <span class="id">hi</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">match_cont_globalenv</span>: <span class="id">compat</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_find_funct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">vf</span> <span class="id">fd</span> <span class="id">tvf</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">vf</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">vf</span> <span class="id">tvf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tfd</span>, <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">tvf</span> = <span class="id">Some</span> <span class="id">tfd</span> /\ <span class="id">transf_fundef</span> <span class="id">fd</span> = <span class="id">OK</span> <span class="id">tfd</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4457')">Proof.</div>
<div class="proofscript" id="proof4457">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">match_cont_globalenv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">bound1</span> <span class="id">MG</span>]. <span class="tactic">destruct</span> <span class="id">MG</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">destruct</span> (<span class="id">Ptrofs.eq_dec</span> <span class="id">ofs1</span> <span class="id">Ptrofs.zero</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ofs1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b1</span>, 0)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">DOMAIN</span>. <span class="tactic">eapply</span> <span class="id">FUNCTIONS</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">dec_eq_true</span>. <span class="tactic">apply</span> <span class="id">function_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Relating execution states </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_regular_states</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span> <span class="id">j</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">tlo</span> <span class="id">thi</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRS</span>: <span class="id">simpl_stmt</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MENV</span>: <span class="id">match_envs</span> <span class="id">j</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tlo</span> <span class="id">thi</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCONT</span>: <span class="id">match_cont</span> <span class="id">j</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">lo</span> <span class="id">tlo</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">COMPAT</span>: <span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">s</span>) (<span class="id">cenv_for</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BOUND</span>: <span class="id">Ple</span> <span class="id">hi</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TBOUND</span>: <span class="id">Ple</span> <span class="id">thi</span> (<span class="id">Mem.nextblock</span> <span class="id">tm</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">te</span> <span class="id">tle</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_call_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fd</span> <span class="id">vargs</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tfd</span> <span class="id">tvargs</span> <span class="id">tk</span> <span class="id">tm</span> <span class="id">j</span> <span class="id">targs</span> <span class="id">tres</span> <span class="id">cconv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRFD</span>: <span class="id">transf_fundef</span> <span class="id">fd</span> = <span class="id">OK</span> <span class="id">tfd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCONT</span>: <span class="kwd">forall</span> <span class="id">cenv</span>, <span class="id">match_cont</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AINJ</span>: <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">vargs</span> <span class="id">tvargs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FUNTY</span>: <span class="id">type_of_fundef</span> <span class="id">fd</span> = <span class="id">Tfunction</span> <span class="id">targs</span> <span class="id">tres</span> <span class="id">cconv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ANORM</span>: <span class="id">val_casted_list</span> <span class="id">vargs</span> <span class="id">targs</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Callstate</span> <span class="id">fd</span> <span class="id">vargs</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">tfd</span> <span class="id">tvargs</span> <span class="id">tk</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_return_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tv</span> <span class="id">tk</span> <span class="id">tm</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCONT</span>: <span class="kwd">forall</span> <span class="id">cenv</span>, <span class="id">match_cont</span> <span class="id">j</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">j</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RINJ</span>: <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">tv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Returnstate</span> <span class="id">v</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">tv</span> <span class="id">tk</span> <span class="id">tm</span>).<br/>
<br/>
<div class="doc">The simulation diagrams </div>
<br/>
<span class="kwd">Remark</span> <span class="id">is_liftable_var_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">a</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">is_liftable_var</span> <span class="id">cenv</span> <span class="id">a</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">id</span> =&gt; <span class="id">exists</span> <span class="id">ty</span>, <span class="id">a</span> = <span class="id">Evar</span> <span class="id">id</span> <span class="id">ty</span> /\ <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="kwd">match</span> <span class="id">a</span> <span class="kwd">with</span> <span class="id">Evar</span> <span class="id">id</span> <span class="id">ty</span> =&gt; <span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">false</span> | <span class="id">_</span> =&gt; <span class="id">True</span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4458')">Proof.</div>
<div class="proofscript" id="proof4458">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">i</span> <span class="id">cenv</span>) <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">t</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">simpl_select_switch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">n</span> <span class="id">ls</span> <span class="id">tls</span>,<br/>
&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> (<span class="id">select_switch</span> <span class="id">n</span> <span class="id">ls</span>) = <span class="id">OK</span> (<span class="id">select_switch</span> <span class="id">n</span> <span class="id">tls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4459')">Proof.</div>
<div class="proofscript" id="proof4459">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">cenv</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DFL</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">tls</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> (<span class="id">select_switch_default</span> <span class="id">ls</span>) = <span class="id">OK</span> (<span class="id">select_switch_default</span> <span class="id">tls</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">o</span>. <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>, <span class="id">EQ1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">tls</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">ls</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">tls</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">ls</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tls</span>', <span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">tls</span> = <span class="id">Some</span> <span class="id">tls</span>' /\ <span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span>' = <span class="id">OK</span> <span class="id">tls</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">z</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>, <span class="id">EQ1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHls</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHls</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">unfold</span> <span class="id">select_switch</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">CASE</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>). <span class="tactic">destruct</span> (<span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">ls</span>) <span class="kwd">as</span> [<span class="id">ls</span>'|].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">CASE</span> <span class="kwd">as</span> [<span class="id">tls</span>' [<span class="id">P</span> <span class="id">Q</span>]]. <span class="tactic">rewrite</span> <span class="id">P</span>, <span class="id">Q</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CASE</span>. <span class="tactic">apply</span> <span class="id">DFL</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">simpl_seq_of_labeled_statement</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">ls</span> <span class="id">tls</span>,<br/>
&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">ls</span>) = <span class="id">OK</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">tls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4460')">Proof.</div>
<div class="proofscript" id="proof4460">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">simpl</span>. <span class="id">erewrite</span> <span class="id">IHls</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">compat_cenv_select_switch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">n</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> (<span class="id">select_switch</span> <span class="id">n</span> <span class="id">ls</span>)) <span class="id">cenv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4461')">Proof.</div>
<div class="proofscript" id="proof4461">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">cenv</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DFL</span>: <span class="kwd">forall</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> (<span class="id">select_switch_default</span> <span class="id">ls</span>)) <span class="id">cenv</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE</span>: <span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">ls</span> = <span class="id">Some</span> <span class="id">ls</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>') <span class="id">cenv</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>. <span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">z</span> <span class="id">n</span>). <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">specialize</span> (<span class="id">CASE</span> <span class="id">ls</span>). <span class="tactic">unfold</span> <span class="id">select_switch</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">ls</span>) <span class="kwd">as</span> [<span class="id">ls</span>'|]; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">addr_taken_seq_of_labeled_statement</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span>, <span class="id">addr_taken_stmt</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">ls</span>) = <span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4462')">Proof.</div>
<div class="proofscript" id="proof4462">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">FIND_LABEL</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cenv</span>: <span class="id">compilenv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Variables</span> <span class="id">bound</span> <span class="id">tbound</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variable</span> <span class="id">lbl</span>: <span class="id">ident</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">simpl_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;<span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">s</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">Some</span>(<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">s</span>') <span class="id">cenv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span>' <span class="id">tk</span>' <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<br/>
<span class="kwd">with</span> <span class="id">simpl_find_label_ls</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">k</span> <span class="id">tls</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;<span class="id">simpl_lblstmt</span> <span class="id">cenv</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">compat_cenv</span> (<span class="id">addr_taken_lblstmt</span> <span class="id">ls</span>) <span class="id">cenv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">find_label_ls</span> <span class="id">lbl</span> <span class="id">ls</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label_ls</span> <span class="id">lbl</span> <span class="id">tls</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label_ls</span> <span class="id">lbl</span> <span class="id">tls</span> <span class="id">tk</span> = <span class="id">Some</span>(<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">compat_cenv</span> (<span class="id">addr_taken_stmt</span> <span class="id">s</span>') <span class="id">cenv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">simpl_stmt</span> <span class="id">cenv</span> <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">k</span>' <span class="id">tk</span>' <span class="id">m</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4463')">Proof.</div>
<div class="proofscript" id="proof4463">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">s</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">tk</span>; <span class="tactic">intros</span> <span class="id">TS</span> <span class="id">MC</span> <span class="id">COMPAT</span>; <span class="tactic">auto</span>.<br/>
&nbsp;skip&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">is_liftable_var</span> <span class="id">cenv</span> <span class="id">e</span>); <span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Sset_debug</span>. <span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>); <span class="tactic">auto</span>.<br/>
&nbsp;set&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;builtin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHs1</span> (<span class="id">Kseq</span> <span class="id">s2</span> <span class="id">k</span>) <span class="id">x</span> (<span class="id">Kseq</span> <span class="id">x0</span> <span class="id">tk</span>)); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s1</span> (<span class="id">Kseq</span> <span class="id">s2</span> <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>']|].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> <span class="id">S</span>]]]]]. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eapply</span> <span class="id">IHs2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHs1</span> <span class="id">k</span> <span class="id">x</span> <span class="id">tk</span>); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s1</span> <span class="id">k</span>) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>']|].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> <span class="id">S</span>]]]]]. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eapply</span> <span class="id">IHs2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHs1</span> (<span class="id">Kloop1</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>) <span class="id">x</span> (<span class="id">Kloop1</span> <span class="id">x</span> <span class="id">x0</span> <span class="id">tk</span>)); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s1</span> (<span class="id">Kloop1</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>']|].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> <span class="id">S</span>]]]]]. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eapply</span> <span class="id">IHs2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;break&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;continue&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">simpl_find_label_ls</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">lbl</span> <span class="id">l</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>; <span class="id">exists</span> <span class="id">tk</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;goto&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TS</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;nil&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;cons&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">simpl_find_label</span> <span class="id">s</span> (<span class="id">Kseq</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">ls</span>) <span class="id">k</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="tactic">eapply</span> <span class="id">simpl_seq_of_labeled_statement</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">addr_taken_seq_of_labeled_statement</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> (<span class="id">Kseq</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">ls</span>) <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>']|].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> <span class="id">S</span>]]]]]. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">P</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">E</span>. <span class="tactic">eapply</span> <span class="id">IHls</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_store_params</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">params</span>, <span class="id">find_label</span> <span class="id">lbl</span> (<span class="id">store_params</span> <span class="id">cenv</span> <span class="id">params</span> <span class="id">s</span>) <span class="id">k</span> = <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4464')">Proof.</div>
<div class="proofscript" id="proof4464">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">params</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]. <span class="tactic">destruct</span> (<span class="id">VSet.mem</span> <span class="id">id</span> <span class="id">cenv</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_add_debug_vars</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">vars</span>, <span class="id">find_label</span> <span class="id">lbl</span> (<span class="id">add_debug_vars</span> <span class="id">vars</span> <span class="id">s</span>) <span class="id">k</span> = <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4465')">Proof.</div>
<div class="proofscript" id="proof4465">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_debug_vars</span>. <span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_add_debug_params</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">vars</span>, <span class="id">find_label</span> <span class="id">lbl</span> (<span class="id">add_debug_params</span> <span class="id">vars</span> <span class="id">s</span>) <span class="id">k</span> = <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4466')">Proof.</div>
<div class="proofscript" id="proof4466">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">add_debug_params</span>. <span class="tactic">destruct</span> (<span class="id">Compopts.debug</span> <span class="id">tt</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">FIND_LABEL</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">step_simulation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">step1</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">S1</span> <span class="id">S1</span>'), <span class="id">exists</span> <span class="id">S2</span>', <span class="id">plus</span> <span class="id">step2</span> <span class="id">tge</span> <span class="id">S1</span>' <span class="id">t</span> <span class="id">S2</span>' /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">S2</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4467')">Proof.</div>
<div class="proofscript" id="proof4467">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">MS</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">TRS</span>).<br/>
<br/>
&nbsp;assign&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_liftable_var_charact</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">a1</span>); <span class="tactic">destruct</span> (<span class="id">is_liftable_var</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">a1</span>) <span class="kwd">as</span> [<span class="id">id</span>|]; <span class="id">monadInv</span> <span class="id">TRS</span>.<br/>
&nbsp;liftable&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ty</span> [<span class="id">P</span> <span class="id">Q</span>]]; <span class="tactic">subst</span> <span class="id">a1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_cast_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_vars</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">id</span>). <span class="tactic">intros</span> <span class="id">MV</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;local&nbsp;variable&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">step_Sset_debug</span>. <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_assign_lifted</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">cast_val_is_casted</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_assign_loc</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">me_range</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>. <span class="id">inv</span> <span class="id">H2</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>. <span class="tactic">unfold</span> <span class="id">Mem.storev</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.store_unmapped_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">assign_loc_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;global&nbsp;variable&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MV</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;not&nbsp;liftable&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_lvalue</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tb</span> [<span class="id">tofs</span> [<span class="id">E</span> <span class="id">F</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_cast_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">assign_loc_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">X</span> [<span class="id">Y</span> <span class="id">Z</span>]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">eexact</span> <span class="id">E</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="id">eexact</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>; <span class="tactic">auto</span>. <span class="id">eexact</span> <span class="id">X</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">assign_loc_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">assign_loc_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;set&nbsp;temporary&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_set_temp</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tvf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_exprlist</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">CASTED</span> [<span class="id">tvargs</span> [<span class="id">C</span> <span class="id">D</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_cont_find_funct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tfd</span> [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_call</span> <span class="kwd">with</span> (<span class="id">fd</span> := <span class="id">tfd</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">type_of_fundef_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;builtin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_exprlist</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">CASTED</span> [<span class="id">tvargs</span> [<span class="id">C</span> <span class="id">D</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">match_globalenvs_preserves_globals</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">tvres</span> [<span class="id">tm</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> [<span class="id">S</span> [<span class="id">T</span> [<span class="id">U</span> <span class="id">V</span>]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_set_opttemp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_extcall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_extcall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MENV</span>; <span class="id">xomega</span>. <span class="id">inv</span> <span class="id">MENV</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Ple_trans</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;sequence&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;skip&nbsp;sequence&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;continue&nbsp;sequence&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;break&nbsp;sequence&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">step_ifthenelse</span> <span class="kwd">with</span> (<span class="id">v1</span> := <span class="id">tv</span>) (<span class="id">b</span> := <span class="id">b</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="tactic">eapply</span> <span class="id">bool_val_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;skip-or-continue&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;break&nbsp;loop1&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_break_loop1</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;skip&nbsp;loop2&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_skip_loop2</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">H2</span>; <span class="tactic">rewrite</span> <span class="id">H4</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;break&nbsp;loop2&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_break_loop2</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;return&nbsp;none&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_envs_free_blocks</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eapply</span> <span class="id">match_cont_free_env</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;return&nbsp;some&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">sem_cast_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_envs_free_blocks</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="id">monadInv</span> <span class="id">TRF</span>; <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eapply</span> <span class="id">match_cont_free_env</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;skip&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_envs_free_blocks</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_is_call_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TRF</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_cont_change_cenv</span> <span class="kwd">with</span> (<span class="id">cenv_for</span> <span class="id">f</span>); <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">match_cont_free_env</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_simpl_expr</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">typeof_simpl_expr</span>. <span class="id">instantiate</span> (1 := <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_switch_arg</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_switch</span> (<span class="id">typeof</span> <span class="id">a</span>)); <span class="tactic">try</span> <span class="tactic">discriminate</span>;<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">B</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">simpl_seq_of_labeled_statement</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">simpl_select_switch</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">addr_taken_seq_of_labeled_statement</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">compat_cenv_select_switch</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;skip-break&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_skip_break_switch</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;continue&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MCONT</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_continue_switch</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;goto&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRF</span>; <span class="tactic">intros</span> <span class="id">TRF</span>'. <span class="id">monadInv</span> <span class="id">TRF</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">simpl_find_label</span> <span class="id">j</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="id">m</span> <span class="id">lo</span> <span class="id">tlo</span> <span class="id">lbl</span> (<span class="id">fn_body</span> <span class="id">f</span>) (<span class="id">call_cont</span> <span class="id">k</span>) <span class="id">x</span> (<span class="id">call_cont</span> <span class="id">tk</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">compat_cenv_for</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">find_label_add_debug_params</span>. <span class="tactic">rewrite</span> <span class="id">find_label_store_params</span>. <span class="tactic">rewrite</span> <span class="id">find_label_add_debug_vars</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;internal&nbsp;function&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TRFD</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">EQ</span>; <span class="tactic">intro</span> <span class="id">EQ</span>'; <span class="id">monadInv</span> <span class="id">EQ</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">list_norepet</span> (<span class="id">var_names</span> (<span class="id">fn_params</span> <span class="id">f</span> ++ <span class="id">fn_vars</span> <span class="id">f</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_names</span>. <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_envs_alloc_variables</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">cenv_for_gen</span> (<span class="id">addr_taken_stmt</span> <span class="id">f</span>.(<span class="id">fn_body</span>)) (<span class="id">fn_params</span> <span class="id">f</span> ++ <span class="id">fn_vars</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">cenv_for_gen_by_value</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">VSF.mem_iff</span>. <span class="id">eexact</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">cenv_for_gen_domain</span>. <span class="tactic">rewrite</span> <span class="id">VSF.mem_iff</span>. <span class="id">eexact</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">te</span> [<span class="id">tm0</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> [<span class="id">D</span> [<span class="id">E</span> [<span class="id">F</span> <span class="id">G</span>]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">K</span>: <span class="id">list_forall2</span> <span class="id">val_casted</span> <span class="id">vargs</span> (<span class="id">map</span> <span class="id">snd</span> (<span class="id">fn_params</span> <span class="id">f</span>))).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">val_casted_list_params</span>. <span class="tactic">unfold</span> <span class="id">type_of_function</span> <span class="kwd">in</span> <span class="id">FUNTY</span>. <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">store_params_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">list_norepet_append_left</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">K</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">val_inject_list_incr</span> <span class="kwd">with</span> <span class="id">j</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">B</span>. <span class="id">eexact</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> (<span class="id">create_undef_temps_lifted</span> <span class="id">id</span> <span class="id">f</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">create_undef_temps</span> (<span class="id">fn_temps</span> <span class="id">f</span>))!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">v</span>|] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">create_undef_temps_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="tactic">elim</span> (<span class="id">l</span> <span class="id">id</span> <span class="id">id</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tel</span> [<span class="id">tm1</span> [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> [<span class="id">S</span> <span class="id">T</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">cenv_for_gen</span> (<span class="id">addr_taken_stmt</span> (<span class="id">fn_body</span> <span class="id">f</span>)) (<span class="id">fn_params</span> <span class="id">f</span> ++ <span class="id">fn_vars</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> (<span class="id">cenv_for</span> <span class="id">f</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">vars_and_temps_properties</span> (<span class="id">cenv_for</span> <span class="id">f</span>) (<span class="id">fn_params</span> <span class="id">f</span>) (<span class="id">fn_vars</span> <span class="id">f</span>) (<span class="id">fn_temps</span> <span class="id">f</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">X</span> [<span class="id">Y</span> <span class="id">Z</span>]]. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">exact</span> <span class="id">Y</span>. <span class="tactic">exact</span> <span class="id">X</span>. <span class="tactic">exact</span> <span class="id">Z</span>. <span class="tactic">simpl</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">simpl</span>. <span class="id">eexact</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="tactic">eapply</span> <span class="id">step_add_debug_params</span>. <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">forall2_val_casted_inject</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">Q</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">P</span>. <span class="tactic">eapply</span> <span class="id">step_add_debug_vars</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">remove_lifted</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">List.filter_In</span> <span class="kwd">in</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">negb_true_iff</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m0</span> <span class="id">b</span> 0).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bind_parameters_load</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">alloc_variables_range</span>. <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">empty_env</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">intros</span> [?|?]. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">b</span>'. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">alloc_variables_load</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">compat_cenv_for</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">bind_parameters_nextblock</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H2</span>). <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">T</span>; <span class="id">xomega</span>.<br/>
<br/>
&nbsp;external&nbsp;function&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TRFD</span>. <span class="id">inv</span> <span class="id">FUNTY</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">match_globalenvs_preserves_globals</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_globalenv</span>. <span class="id">eexact</span> (<span class="id">MCONT</span> <span class="id">VSet.empty</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">j</span>' [<span class="id">tvres</span> [<span class="id">tm</span>' [<span class="id">P</span> [<span class="id">Q</span> [<span class="id">R</span> [<span class="id">S</span> [<span class="id">T</span> [<span class="id">U</span> <span class="id">V</span>]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_cont_incr_bounds</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_extcall</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">MCONT</span> (<span class="id">cenv_for</span> <span class="id">f</span>)). <span class="id">inv</span> <span class="id">MCONT</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">compat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_envs_set_opttemp</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">initial_states_simulation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span>, <span class="id">initial_state</span> <span class="id">prog</span> <span class="id">S</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">R</span>, <span class="id">initial_state</span> <span class="id">tprog</span> <span class="id">R</span> /\ <span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4468')">Proof.</div>
<div class="proofscript" id="proof4468">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> (<span class="id">Genv.init_mem_transf_partial</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="kwd">with</span> (<span class="id">prog_main</span> <span class="id">prog</span>). <br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">b</span>). <span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">match_program_main</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>)). <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>; <span class="tactic">apply</span> <span class="id">type_of_fundef_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">instantiate</span> (1 := <span class="id">Mem.flat_inj</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">instantiate</span> (1 := <span class="id">Mem.nextblock</span> <span class="id">m0</span>).<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span>. <span class="tactic">apply</span> <span class="id">pred_dec_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b1</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)); <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.find_symbol_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.find_funct_ptr_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.find_var_info_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.initmem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">final_states_simulation</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span> <span class="id">R</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span> -&gt; <span class="id">final_state</span> <span class="id">S</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">R</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4469')">Proof.</div>
<div class="proofscript" id="proof4469">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">MCONT</span> <span class="id">VSet.empty</span>). <span class="id">inv</span> <span class="id">MCONT</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">RINJ</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">semantics1</span> <span class="id">prog</span>) (<span class="id">semantics2</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4470')">Proof.</div>
<div class="proofscript" id="proof4470">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_plus</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">initial_states_simulation</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">final_states_simulation</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">step_simulation</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<h2> Commutation with linking </h2>
<br/>
<span class="kwd">Instance</span> <span class="id">TransfSimplLocalsLink</span> : <span class="id">TransfLink</span> <span class="id">match_prog</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4471')">Proof.</div>
<div class="proofscript" id="proof4471">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Ctypes.link_match_program</span>; <span class="tactic">eauto</span>. <br/>
- <span class="tactic">intros</span>.<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Linker_fundef</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">unfold</span> <span class="id">link_fundef</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f1</span>; <span class="id">monadInv</span> <span class="id">H3</span>; <span class="tactic">destruct</span> <span class="id">f2</span>; <span class="id">monadInv</span> <span class="id">H4</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">e</span>; <span class="id">inv</span> <span class="id">H2</span>. <span class="id">exists</span> (<span class="id">Internal</span> <span class="id">x</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">e</span>; <span class="id">inv</span> <span class="id">H2</span>. <span class="id">exists</span> (<span class="id">Internal</span> <span class="id">x</span>); <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">external_function_eq</span> <span class="id">e</span> <span class="id">e0</span> &amp;&amp; <span class="id">typelist_eq</span> <span class="id">t</span> <span class="id">t1</span> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">type_eq</span> <span class="id">t0</span> <span class="id">t2</span> &amp;&amp; <span class="id">calling_convention_eq</span> <span class="id">c</span> <span class="id">c0</span>); <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <br/>
Qed.</div>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
