<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module NeedDomain</title>
<meta name="description" content="Documentation of Coq module NeedDomain" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module NeedDomain</h1>
<div class="coq">
<br/>
<div class="doc">Abstract domain for neededness analysis </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Maps</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">IntvSets</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Floats</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Memory</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Globalenvs</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Events</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Lattice</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Registers</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">ValueDomain</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">RTL</span>.<br/>
<br/>
<h1> Neededness for values </h1>
<br/>
<span class="kwd">Inductive</span> <span class="id">nval</span> : <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id">Nothing</span>              <span class="docright">(* value is entirely unused  *)</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> (<span class="id">m</span>: <span class="id">int</span>)           <span class="docright">(* only need the bits that are 1 in <span class="bracket"><span class="id">m</span></span>  *)</span><br/>
&nbsp;&nbsp;| <span class="id">All</span>.                 <span class="docright">(* every bit of the value is used  *)</span><br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eq_nval</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">nval</span>) : {<span class="id">x</span>=<span class="id">y</span>} + {<span class="id">x</span>&lt;&gt;<span class="id">y</span>}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3189')">Proof.</div>
<div class="proofscript" id="proof3189">
&nbsp;&nbsp;<span class="id">decide</span> <span class="id">equality</span>. <span class="tactic">apply</span> <span class="id">Int.eq_dec</span>.<br/>
Defined.</div>
<br/>
<h2> Agreement between two values relative to a need. </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">iagree</span> (<span class="id">p</span> <span class="id">q</span> <span class="id">mask</span>: <span class="id">int</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>, 0 &lt;= <span class="id">i</span> &lt; <span class="id">Int.zwordsize</span> -&gt; <span class="id">Int.testbit</span> <span class="id">mask</span> <span class="id">i</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Int.testbit</span> <span class="id">p</span> <span class="id">i</span> = <span class="id">Int.testbit</span> <span class="id">q</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">vagree</span> (<span class="id">v</span> <span class="id">w</span>: <span class="id">val</span>) (<span class="id">x</span>: <span class="id">nval</span>) {<span class="kwd">struct</span> <span class="id">x</span>}: <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">v</span>, <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Vint</span> <span class="id">p</span>, <span class="id">Vint</span> <span class="id">q</span> =&gt; <span class="id">iagree</span> <span class="id">p</span> <span class="id">q</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Vint</span> <span class="id">p</span>, <span class="id">_</span> =&gt; <span class="id">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">w</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">vagree_same</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">x</span>, <span class="id">vagree</span> <span class="id">v</span> <span class="id">v</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3190')">Proof.</div>
<div class="proofscript" id="proof3190">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">vagree_lessdef</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span>, <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">w</span> -&gt; <span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3191')">Proof.</div>
<div class="proofscript" id="proof3191">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">vagree_same</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">lessdef_vagree</span>: <span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span>, <span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> <span class="id">All</span> -&gt; <span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">w</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3192')">Proof.</div>
<div class="proofscript" id="proof3192">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">vagree_same</span> <span class="id">vagree_lessdef</span> <span class="id">lessdef_vagree</span>: <span class="id">na</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">vagree_list</span>: <span class="id">list</span> <span class="id">val</span> -&gt; <span class="id">list</span> <span class="id">val</span> -&gt; <span class="id">list</span> <span class="id">nval</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">vagree_list_nil</span>: <span class="kwd">forall</span> <span class="id">nvl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vagree_list</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">nvl</span><br/>
&nbsp;&nbsp;| <span class="id">vagree_list_default</span>: <span class="kwd">forall</span> <span class="id">v1</span> <span class="id">vl1</span> <span class="id">v2</span> <span class="id">vl2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">All</span> -&gt; <span class="id">vagree_list</span> <span class="id">vl1</span> <span class="id">vl2</span> <span class="id">nil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vagree_list</span> (<span class="id">v1</span> :: <span class="id">vl1</span>) (<span class="id">v2</span> :: <span class="id">vl2</span>) <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">vagree_list_cons</span>: <span class="kwd">forall</span> <span class="id">v1</span> <span class="id">vl1</span> <span class="id">v2</span> <span class="id">vl2</span> <span class="id">nv1</span> <span class="id">nvl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">nv1</span> -&gt; <span class="id">vagree_list</span> <span class="id">vl1</span> <span class="id">vl2</span> <span class="id">nvl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vagree_list</span> (<span class="id">v1</span> :: <span class="id">vl1</span>) (<span class="id">v2</span> :: <span class="id">vl2</span>) (<span class="id">nv1</span> :: <span class="id">nvl</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">lessdef_vagree_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vl1</span> <span class="id">vl2</span>, <span class="id">vagree_list</span> <span class="id">vl1</span> <span class="id">vl2</span> <span class="id">nil</span> -&gt; <span class="id">Val.lessdef_list</span> <span class="id">vl1</span> <span class="id">vl2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3193')">Proof.</div>
<div class="proofscript" id="proof3193">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vl1</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">vagree_lessdef_list</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vl1</span> <span class="id">vl2</span>, <span class="id">Val.lessdef_list</span> <span class="id">vl1</span> <span class="id">vl2</span> -&gt; <span class="kwd">forall</span> <span class="id">nvl</span>, <span class="id">vagree_list</span> <span class="id">vl1</span> <span class="id">vl2</span> <span class="id">nvl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3194')">Proof.</div>
<div class="proofscript" id="proof3194">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nvl</span>; <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">lessdef_vagree_list</span> <span class="id">vagree_lessdef_list</span>: <span class="id">na</span>.<br/>
<br/>
<h2> Ordering and least upper bound between value needs </h2>
<br/>
<span class="kwd">Inductive</span> <span class="id">nge</span>: <span class="id">nval</span> -&gt; <span class="id">nval</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">nge_nothing</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">nge</span> <span class="id">All</span> <span class="id">x</span><br/>
&nbsp;&nbsp;| <span class="id">nge_all</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">nge</span> <span class="id">x</span> <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">nge_int</span>: <span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">i</span>, 0 &lt;= <span class="id">i</span> &lt; <span class="id">Int.zwordsize</span> -&gt; <span class="id">Int.testbit</span> <span class="id">m2</span> <span class="id">i</span> = <span class="id">true</span> -&gt; <span class="id">Int.testbit</span> <span class="id">m1</span> <span class="id">i</span> = <span class="id">true</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nge</span> (<span class="id">I</span> <span class="id">m1</span>) (<span class="id">I</span> <span class="id">m2</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nge_refl</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">nge</span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3195')">Proof.</div>
<div class="proofscript" id="proof3195">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="id">Constructors</span> <span class="id">nge</span>: <span class="id">na</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">nge_refl</span>: <span class="id">na</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nge_trans</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">nge</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="kwd">forall</span> <span class="id">z</span>, <span class="id">nge</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">nge</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3196')">Proof.</div>
<div class="proofscript" id="proof3196">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">w</span> <span class="id">VG</span>; <span class="id">inv</span> <span class="id">VG</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nge_agree</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">nge</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> -&gt; <span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3197')">Proof.</div>
<div class="proofscript" id="proof3197">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">v</span>, <span class="id">w</span>; <span class="tactic">intuition</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">nlub</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">nval</span>) : <span class="id">nval</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span>, <span class="id">y</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span>, <span class="id">_</span> =&gt; <span class="id">y</span><br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">Nothing</span> =&gt; <span class="id">x</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m1</span>, <span class="id">I</span> <span class="id">m2</span> =&gt; <span class="id">I</span> (<span class="id">Int.or</span> <span class="id">m1</span> <span class="id">m2</span>)<br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nge_lub_l</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">nge</span> (<span class="id">nlub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3198')">Proof.</div>
<div class="proofscript" id="proof3198">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nlub</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nge_lub_r</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">nge</span> (<span class="id">nlub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3199')">Proof.</div>
<div class="proofscript" id="proof3199">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nlub</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">orb_true_r</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Properties of agreement between integers </h2>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_refl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">m</span>, <span class="id">iagree</span> <span class="id">p</span> <span class="id">p</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3200')">Proof.</div>
<div class="proofscript" id="proof3200">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">eq_same_bits</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">x</span> = <span class="id">y</span> -&gt; <span class="id">Int.testbit</span> <span class="id">x</span> <span class="id">i</span> = <span class="id">Int.testbit</span> <span class="id">y</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3201')">Proof.</div>
<div class="proofscript" id="proof3201">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_and_eq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">mask</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> <span class="id">mask</span> &lt;-&gt; <span class="id">Int.and</span> <span class="id">x</span> <span class="id">mask</span> = <span class="id">Int.and</span> <span class="id">y</span> <span class="id">mask</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3202')">Proof.</div>
<div class="proofscript" id="proof3202">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">Int.bit_solve</span>. <span class="id">specialize</span> (<span class="id">H</span> <span class="id">i</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.testbit</span> <span class="id">mask</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">andb_true_r</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">andb_false_r</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> (<span class="id">eq_same_bits</span> <span class="id">i</span>); <span class="tactic">eauto</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> ! <span class="id">andb_true_r</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_mone</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span>, <span class="id">iagree</span> <span class="id">p</span> <span class="id">q</span> <span class="id">Int.mone</span> -&gt; <span class="id">p</span> = <span class="id">q</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3203')">Proof.</div>
<div class="proofscript" id="proof3203">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">iagree_and_eq</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.and_mone</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_zero</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span>, <span class="id">iagree</span> <span class="id">p</span> <span class="id">q</span> <span class="id">Int.zero</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3204')">Proof.</div>
<div class="proofscript" id="proof3204">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">iagree_and_eq</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.and_zero</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_and</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">n</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.and</span> <span class="id">m</span> <span class="id">n</span>) -&gt; <span class="id">iagree</span> (<span class="id">Int.and</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.and</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3205')">Proof.</div>
<div class="proofscript" id="proof3205">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">iagree_and_eq</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> ! <span class="id">Int.and_assoc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">Int.and_commut</span> <span class="id">n</span>). <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_not</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span> -&gt; <span class="id">iagree</span> (<span class="id">Int.not</span> <span class="id">x</span>) (<span class="id">Int.not</span> <span class="id">y</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3206')">Proof.</div>
<div class="proofscript" id="proof3206">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>. <span class="tactic">f_equal</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_not</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">iagree</span> (<span class="id">Int.not</span> <span class="id">x</span>) (<span class="id">Int.not</span> <span class="id">y</span>) <span class="id">m</span> -&gt; <span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3207')">Proof.</div>
<div class="proofscript" id="proof3207">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- (<span class="id">Int.not_involutive</span> <span class="id">x</span>). <span class="tactic">rewrite</span> &lt;- (<span class="id">Int.not_involutive</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_not</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_or</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">n</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.and</span> <span class="id">m</span> (<span class="id">Int.not</span> <span class="id">n</span>)) -&gt; <span class="id">iagree</span> (<span class="id">Int.or</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.or</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3208')">Proof.</div>
<div class="proofscript" id="proof3208">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">iagree_not</span>'. <span class="tactic">rewrite</span> ! <span class="id">Int.not_or_and_not</span>. <span class="tactic">apply</span> <span class="id">iagree_and</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_not</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_bitwise_binop</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sem</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">i</span>, 0 &lt;= <span class="id">i</span> &lt; <span class="id">Int.zwordsize</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Int.testbit</span> (<span class="id">f</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">i</span> = <span class="id">sem</span> (<span class="id">Int.testbit</span> <span class="id">x</span> <span class="id">i</span>) (<span class="id">Int.testbit</span> <span class="id">y</span> <span class="id">i</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x1</span> <span class="id">x2</span> <span class="id">y1</span> <span class="id">y2</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x1</span> <span class="id">y1</span> <span class="id">m</span> -&gt; <span class="id">iagree</span> <span class="id">x2</span> <span class="id">y2</span> <span class="id">m</span> -&gt; <span class="id">iagree</span> (<span class="id">f</span> <span class="id">x1</span> <span class="id">x2</span>) (<span class="id">f</span> <span class="id">y1</span> <span class="id">y2</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3209')">Proof.</div>
<div class="proofscript" id="proof3209">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">H</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">f_equal</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_shl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.shru</span> <span class="id">m</span> <span class="id">n</span>) -&gt; <span class="id">iagree</span> (<span class="id">Int.shl</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.shl</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3210')">Proof.</div>
<div class="proofscript" id="proof3210">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i</span> (<span class="id">Int.unsigned</span> <span class="id">n</span>)).<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">generalize</span> (<span class="id">Int.unsigned_range</span> <span class="id">n</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_shru</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">i</span> - <span class="id">Int.unsigned</span> <span class="id">n</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="kwd">with</span> <span class="id">i</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zlt_true</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_shru</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>) -&gt; <span class="id">iagree</span> (<span class="id">Int.shru</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.shru</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3211')">Proof.</div>
<div class="proofscript" id="proof3211">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="id">Int.zwordsize</span>).<br/>
- <span class="tactic">generalize</span> (<span class="id">Int.unsigned_range</span> <span class="id">n</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_shl</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span> - <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="kwd">with</span> <span class="id">i</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zlt_false</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_shr_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">Int.shru</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>) <span class="id">n</span> = <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>) -&gt; <span class="id">iagree</span> (<span class="id">Int.shr</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.shr</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3212')">Proof.</div>
<div class="proofscript" id="proof3212">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_shru</span> <span class="kwd">in</span> <span class="id">H2</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">Int.bits_shr</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="id">Int.zwordsize</span>).<br/>
- <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">generalize</span> (<span class="id">Int.unsigned_range</span> <span class="id">n</span>); <span class="tactic">omega</span>.<br/>
- <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_shr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">Int.or</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>) (<span class="id">Int.repr</span> <span class="id">Int.min_signed</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">iagree</span> (<span class="id">Int.shr</span> <span class="id">x</span> <span class="id">n</span>) (<span class="id">Int.shr</span> <span class="id">y</span> <span class="id">n</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3213')">Proof.</div>
<div class="proofscript" id="proof3213">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.bits_shr</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Int.unsigned_range</span> <span class="id">n</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">j</span> := <span class="kwd">if</span> <span class="id">zlt</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="id">Int.zwordsize</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">Int.zwordsize</span> - 1).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (0 &lt;= <span class="id">j</span> &lt; <span class="id">Int.zwordsize</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">j</span>; <span class="tactic">destruct</span> (<span class="id">zlt</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="id">Int.zwordsize</span>); <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">orb_true_intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">j</span>; <span class="tactic">destruct</span> (<span class="id">zlt</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="id">Int.zwordsize</span>).<br/>
- <span class="id">left</span>. <span class="tactic">rewrite</span> <span class="id">zlt_false</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">i</span> + <span class="id">Int.unsigned</span> <span class="id">n</span> - <span class="id">Int.unsigned</span> <span class="id">n</span>) <span class="kwd">with</span> <span class="id">i</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="id">right</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_rol</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span> <span class="id">m</span> <span class="id">amount</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">p</span> <span class="id">q</span> (<span class="id">Int.ror</span> <span class="id">m</span> <span class="id">amount</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">iagree</span> (<span class="id">Int.rol</span> <span class="id">p</span> <span class="id">amount</span>) (<span class="id">Int.rol</span> <span class="id">q</span> <span class="id">amount</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3214')">Proof.</div>
<div class="proofscript" id="proof3214">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">Int.zwordsize</span> &gt; 0) <span class="tactic">by</span> (<span class="tactic">compute</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.bits_rol</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z_mod_lt</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.bits_ror</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (((<span class="id">i</span> - <span class="id">Int.unsigned</span> <span class="id">amount</span>) <span class="id">mod</span> <span class="id">Int.zwordsize</span> + <span class="id">Int.unsigned</span> <span class="id">amount</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">mod</span> <span class="id">Int.zwordsize</span>) <span class="kwd">with</span> <span class="id">i</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_small_eq</span> <span class="kwd">with</span> <span class="id">Int.zwordsize</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_trans</span> <span class="kwd">with</span> ((<span class="id">i</span> - <span class="id">Int.unsigned</span> <span class="id">amount</span>) + <span class="id">Int.unsigned</span> <span class="id">amount</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_refl2</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Int.eqmod_trans</span>. 2: <span class="tactic">apply</span> <span class="id">Int.eqmod_mod</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_add</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_mod</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z_mod_lt</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z_mod_lt</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_ror</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">q</span> <span class="id">m</span> <span class="id">amount</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">p</span> <span class="id">q</span> (<span class="id">Int.rol</span> <span class="id">m</span> <span class="id">amount</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">iagree</span> (<span class="id">Int.ror</span> <span class="id">p</span> <span class="id">amount</span>) (<span class="id">Int.ror</span> <span class="id">q</span> <span class="id">amount</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3215')">Proof.</div>
<div class="proofscript" id="proof3215">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.ror_rol_neg</span> <span class="tactic">by</span> <span class="tactic">apply</span> <span class="id">int_wordsize_divides_modulus</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_rol</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.ror_rol_neg</span> <span class="tactic">by</span> <span class="tactic">apply</span> <span class="id">int_wordsize_divides_modulus</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.neg_involutive</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eqmod_iagree</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">x</span> <span class="id">y</span>,<br/>
&nbsp;&nbsp;<span class="id">Int.eqmod</span> (<span class="id">two_p</span> (<span class="id">Int.size</span> <span class="id">m</span>)) <span class="id">x</span> <span class="id">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">iagree</span> (<span class="id">Int.repr</span> <span class="id">x</span>) (<span class="id">Int.repr</span> <span class="id">y</span>) <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3216')">Proof.</div>
<div class="proofscript" id="proof3216">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">set</span> (<span class="id">p</span> := <span class="id">nat_of_Z</span> (<span class="id">Int.size</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Int.size_range</span> <span class="id">m</span>); <span class="tactic">intros</span> <span class="id">RANGE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EQ</span>: <span class="id">Int.size</span> <span class="id">m</span> = <span class="id">Z_of_nat</span> <span class="id">p</span>). { <span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">nat_of_Z_eq</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">two_power_nat_two_p</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Int.testbit_repr</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i</span> (<span class="id">Int.size</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Int.same_bits_eqmod</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Int.testbit</span> <span class="id">m</span> <span class="id">i</span> = <span class="id">false</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Int.bits_size_2</span>; <span class="tactic">omega</span>).<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">complete_mask</span> (<span class="id">m</span>: <span class="id">int</span>) := <span class="id">Int.zero_ext</span> (<span class="id">Int.size</span> <span class="id">m</span>) <span class="id">Int.mone</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">iagree_eqmod</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">x</span> <span class="id">y</span> (<span class="id">complete_mask</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Int.eqmod</span> (<span class="id">two_p</span> (<span class="id">Int.size</span> <span class="id">m</span>)) (<span class="id">Int.unsigned</span> <span class="id">x</span>) (<span class="id">Int.unsigned</span> <span class="id">y</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3217')">Proof.</div>
<div class="proofscript" id="proof3217">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">set</span> (<span class="id">p</span> := <span class="id">nat_of_Z</span> (<span class="id">Int.size</span> <span class="id">m</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Int.size_range</span> <span class="id">m</span>); <span class="tactic">intros</span> <span class="id">RANGE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EQ</span>: <span class="id">Int.size</span> <span class="id">m</span> = <span class="id">Z_of_nat</span> <span class="id">p</span>). { <span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">nat_of_Z_eq</span>. <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">two_power_nat_two_p</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqmod_same_bits</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">complete_mask</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zlt_true</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_mone</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">complete_mask_idem</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>, <span class="id">complete_mask</span> (<span class="id">complete_mask</span> <span class="id">m</span>) = <span class="id">complete_mask</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3218')">Proof.</div>
<div class="proofscript" id="proof3218">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">complete_mask</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">Int.eq_dec</span> <span class="id">m</span> <span class="id">Int.zero</span>).<br/>
+ <span class="tactic">subst</span> <span class="id">m</span>; <span class="tactic">reflexivity</span>.<br/>
+ <span class="tactic">assert</span> (<span class="id">Int.unsigned</span> <span class="id">m</span> &lt;&gt; 0).<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">elim</span> <span class="id">n</span>. <span class="tactic">rewrite</span> &lt;- (<span class="id">Int.repr_unsigned</span> <span class="id">m</span>). <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (0 &lt; <span class="id">Int.size</span> <span class="id">m</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Int.Zsize_pos</span>'. <span class="tactic">generalize</span> (<span class="id">Int.unsigned_range</span> <span class="id">m</span>); <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">Int.size_range</span> <span class="id">m</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">Int.bits_size_4</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">zlt_true</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.bits_mone</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">apply</span> <span class="id">zlt_false</span>; <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<h2> Abstract operations over value needs. </h2>
<br/>
<span class="kwd">Ltac</span> <span class="id">InvAgree</span> :=<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">vagree</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> (<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> || <span class="tactic">exact</span> <span class="id">Logic.I</span> ||<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id">False</span> |- <span class="id">_</span> ] =&gt; <span class="id">contradiction</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="kwd">match</span> ?<span class="id">v</span> <span class="kwd">with</span> <span class="id">Vundef</span> =&gt; <span class="id">_</span> | <span class="id">Vint</span> <span class="id">_</span> =&gt; <span class="id">_</span> | <span class="id">Vlong</span> <span class="id">_</span> =&gt; <span class="id">_</span> | <span class="id">Vfloat</span> <span class="id">_</span> =&gt; <span class="id">_</span> | <span class="id">Vsingle</span> <span class="id">_</span> =&gt; <span class="id">_</span> | <span class="id">Vptr</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">_</span> <span class="kwd">end</span> |- <span class="id">_</span> ] =&gt; <span class="tactic">destruct</span> <span class="id">v</span><br/>
&nbsp;&nbsp;| [ |- <span class="id">context</span> [<span class="kwd">if</span> <span class="id">Archi.ptr64</span> <span class="kwd">then</span> <span class="id">_</span> <span class="kwd">else</span> <span class="id">_</span>] ] =&gt; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:?<br/>
&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
<br/>
<div class="doc">And immediate, or immediate </div>
<br/>
<span class="kwd">Definition</span> <span class="id">andimm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.and</span> <span class="id">m</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> <span class="id">n</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">andimm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">andimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.and</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.and</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3219')">Proof.</div>
<div class="proofscript" id="proof3219">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">andimm</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">unfold</span> <span class="id">Val.and</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_and</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">rewrite</span> <span class="id">iagree_and_eq</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">orimm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.and</span> <span class="id">m</span> (<span class="id">Int.not</span> <span class="id">n</span>))<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">I</span> (<span class="id">Int.not</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">orimm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">orimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.or</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.or</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3220')">Proof.</div>
<div class="proofscript" id="proof3220">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">orimm</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.or</span>; <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_or</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">iagree_mone</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_or</span>. <span class="tactic">rewrite</span> <span class="id">Int.and_commut</span>. <span class="tactic">rewrite</span> <span class="id">Int.and_mone</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Bitwise operations: and, or, xor, not </div>
<br/>
<span class="kwd">Definition</span> <span class="id">bitwise</span> (<span class="id">x</span>: <span class="id">nval</span>) := <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">bitwise_idem</span>: <span class="kwd">forall</span> <span class="id">nv</span>, <span class="id">bitwise</span> (<span class="id">bitwise</span> <span class="id">nv</span>) = <span class="id">bitwise</span> <span class="id">nv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3221')">Proof.</div>
<div class="proofscript" id="proof3221">
 <span class="tactic">auto</span>. Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">vagree_bitwise_binop</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">p1</span> <span class="id">p2</span> <span class="id">q1</span> <span class="id">q2</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">iagree</span> <span class="id">p1</span> <span class="id">q1</span> <span class="id">m</span> -&gt; <span class="id">iagree</span> <span class="id">p2</span> <span class="id">q2</span> <span class="id">m</span> -&gt; <span class="id">iagree</span> (<span class="id">f</span> <span class="id">p1</span> <span class="id">p2</span>) (<span class="id">f</span> <span class="id">q1</span> <span class="id">q2</span>) <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="kwd">match</span> <span class="id">v1</span>, <span class="id">v2</span> <span class="kwd">with</span> <span class="id">Vint</span> <span class="id">i1</span>, <span class="id">Vint</span> <span class="id">i2</span> =&gt; <span class="id">Vint</span>(<span class="id">f</span> <span class="id">i1</span> <span class="id">i2</span>) | <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">Vundef</span> <span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">match</span> <span class="id">w1</span>, <span class="id">w2</span> <span class="kwd">with</span> <span class="id">Vint</span> <span class="id">i1</span>, <span class="id">Vint</span> <span class="id">i2</span> =&gt; <span class="id">Vint</span>(<span class="id">f</span> <span class="id">i1</span> <span class="id">i2</span>) | <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">Vundef</span> <span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3222')">Proof.</div>
<div class="proofscript" id="proof3222">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">bitwise</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">w1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">and_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.and</span> <span class="id">v1</span> <span class="id">v2</span>) (<span class="id">Val.and</span> <span class="id">w1</span> <span class="id">w2</span>) <span class="id">x</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">vagree_bitwise_binop</span> <span class="id">Int.and</span> (<span class="id">iagree_bitwise_binop</span> <span class="id">andb</span> <span class="id">Int.and</span> <span class="id">Int.bits_and</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">or_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.or</span> <span class="id">v1</span> <span class="id">v2</span>) (<span class="id">Val.or</span> <span class="id">w1</span> <span class="id">w2</span>) <span class="id">x</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">vagree_bitwise_binop</span> <span class="id">Int.or</span> (<span class="id">iagree_bitwise_binop</span> <span class="id">orb</span> <span class="id">Int.or</span> <span class="id">Int.bits_or</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">xor_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.xor</span> <span class="id">v1</span> <span class="id">v2</span>) (<span class="id">Val.xor</span> <span class="id">w1</span> <span class="id">w2</span>) <span class="id">x</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">vagree_bitwise_binop</span> <span class="id">Int.xor</span> (<span class="id">iagree_bitwise_binop</span> <span class="id">xorb</span> <span class="id">Int.xor</span> <span class="id">Int.bits_xor</span>)).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">notint_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">bitwise</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> (<span class="id">Val.notint</span> <span class="id">v</span>) (<span class="id">Val.notint</span> <span class="id">w</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3223')">Proof.</div>
<div class="proofscript" id="proof3223">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> ! <span class="id">Val.not_xor</span>. <span class="tactic">apply</span> <span class="id">xor_sound</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Shifts and rotates </div>
<br/>
<span class="kwd">Definition</span> <span class="id">shlimm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.shru</span> <span class="id">m</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> (<span class="id">Int.shru</span> <span class="id">Int.mone</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">shlimm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">shlimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.shl</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.shl</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3224')">Proof.</div>
<div class="proofscript" id="proof3224">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">shlimm</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Val.shl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">n</span> <span class="id">Int.iwordsize</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_shl</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">iagree_mone</span>. <span class="tactic">apply</span> <span class="id">iagree_shl</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">shruimm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> (<span class="id">Int.shl</span> <span class="id">Int.mone</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">shruimm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">shruimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.shru</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.shru</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3225')">Proof.</div>
<div class="proofscript" id="proof3225">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">shruimm</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Val.shru</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">n</span> <span class="id">Int.iwordsize</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_shru</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">iagree_mone</span>. <span class="tactic">apply</span> <span class="id">iagree_shru</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">shrimm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="kwd">let</span> <span class="id">m</span>' := <span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">Int.eq_dec</span> (<span class="id">Int.shru</span> <span class="id">m</span>' <span class="id">n</span>) <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">Int.or</span> <span class="id">m</span>' (<span class="id">Int.repr</span> <span class="id">Int.min_signed</span>))<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> (<span class="id">Int.or</span> (<span class="id">Int.shl</span> <span class="id">Int.mone</span> <span class="id">n</span>) (<span class="id">Int.repr</span> <span class="id">Int.min_signed</span>))<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">shrimm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">shrimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.shr</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.shr</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3226')">Proof.</div>
<div class="proofscript" id="proof3226">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">shrimm</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Val.shr</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">n</span> <span class="id">Int.iwordsize</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq_dec</span> (<span class="id">Int.shru</span> (<span class="id">Int.shl</span> <span class="id">m</span> <span class="id">n</span>) <span class="id">n</span>) <span class="id">m</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_shr_1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_shr</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">iagree_mone</span>. <span class="tactic">apply</span> <span class="id">iagree_shr</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">v</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">rol</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">amount</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.ror</span> <span class="id">m</span> <span class="id">amount</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">rol_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">rol</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.rol</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.rol</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3227')">Proof.</div>
<div class="proofscript" id="proof3227">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rol</span>, <span class="id">Val.rol</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_rol</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">ror</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">amount</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.rol</span> <span class="id">m</span> <span class="id">amount</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">ror_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">ror</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.ror</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) (<span class="id">Val.ror</span> <span class="id">w</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3228')">Proof.</div>
<div class="proofscript" id="proof3228">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ror</span>, <span class="id">Val.ror</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">iagree_ror</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">rolm</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">amount</span> <span class="id">mask</span>: <span class="id">int</span>) := <span class="id">rol</span> (<span class="id">andimm</span> <span class="id">x</span> <span class="id">mask</span>) <span class="id">amount</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">rolm_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">amount</span> <span class="id">mask</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">rolm</span> <span class="id">x</span> <span class="id">amount</span> <span class="id">mask</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.rolm</span> <span class="id">v</span> <span class="id">amount</span> <span class="id">mask</span>) (<span class="id">Val.rolm</span> <span class="id">w</span> <span class="id">amount</span> <span class="id">mask</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3229')">Proof.</div>
<div class="proofscript" id="proof3229">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rolm</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">X</span>: <span class="kwd">forall</span> <span class="id">u</span>, <span class="id">Val.rolm</span> <span class="id">u</span> <span class="id">amount</span> <span class="id">mask</span> = <span class="id">Val.and</span> (<span class="id">Val.rol</span> <span class="id">u</span> (<span class="id">Vint</span> <span class="id">amount</span>)) (<span class="id">Vint</span> <span class="id">mask</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">u</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">X</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">andimm_sound</span>. <span class="tactic">apply</span> <span class="id">rol_sound</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Modular arithmetic operations: add, mul, opposite.
    (But not subtraction because of the pointer - pointer case. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">modarith</span> (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">complete_mask</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">modarith</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">modarith</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.add</span> <span class="id">v1</span> <span class="id">v2</span>) (<span class="id">Val.add</span> <span class="id">w1</span> <span class="id">w2</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3230')">Proof.</div>
<div class="proofscript" id="proof3230">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">modarith</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.add</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eqmod_iagree</span>. <span class="tactic">apply</span> <span class="id">Int.eqmod_add</span>; <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">w1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">modarith_idem</span>: <span class="kwd">forall</span> <span class="id">nv</span>, <span class="id">modarith</span> (<span class="id">modarith</span> <span class="id">nv</span>) = <span class="id">modarith</span> <span class="id">nv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3231')">Proof.</div>
<div class="proofscript" id="proof3231">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nv</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">f_equal</span>; <span class="tactic">apply</span> <span class="id">complete_mask_idem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mul_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v1</span> <span class="id">w1</span> <span class="id">v2</span> <span class="id">w2</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">w1</span> (<span class="id">modarith</span> <span class="id">x</span>) -&gt; <span class="id">vagree</span> <span class="id">v2</span> <span class="id">w2</span> (<span class="id">modarith</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.mul</span> <span class="id">v1</span> <span class="id">v2</span>) (<span class="id">Val.mul</span> <span class="id">w1</span> <span class="id">w2</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3232')">Proof.</div>
<div class="proofscript" id="proof3232">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mul</span>, <span class="id">add</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.mul</span>; <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">eqmod_iagree</span>. <span class="tactic">apply</span> <span class="id">Int.eqmod_mult</span>; <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">w1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">neg_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">modarith</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.neg</span> <span class="id">v</span>) (<span class="id">Val.neg</span> <span class="id">w</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3233')">Proof.</div>
<div class="proofscript" id="proof3233">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.neg</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eqmod_iagree</span>. <span class="tactic">apply</span> <span class="id">Int.eqmod_neg</span>. <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Conversions: zero extension, sign extension, single-of-float </div>
<br/>
<span class="kwd">Definition</span> <span class="id">zero_ext</span> (<span class="id">n</span>: <span class="id">Z</span>) (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">Int.mone</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">zero_ext_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">zero_ext</span> <span class="id">n</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.zero_ext</span> <span class="id">n</span> <span class="id">v</span>) (<span class="id">Val.zero_ext</span> <span class="id">n</span> <span class="id">w</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3234')">Proof.</div>
<div class="proofscript" id="proof3234">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">zero_ext</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.zero_ext</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>); <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">zlt_true</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.zero_ext</span>; <span class="id">InvAgree</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id">Int.bit_solve</span>; <span class="tactic">try</span> <span class="tactic">omega</span>. <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>); <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>. <span class="tactic">apply</span> <span class="id">zlt_true</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sign_ext</span> (<span class="id">n</span>: <span class="id">Z</span>) (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">I</span> (<span class="id">Int.or</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">m</span>) (<span class="id">Int.shl</span> <span class="id">Int.one</span> (<span class="id">Int.repr</span> (<span class="id">n</span> - 1))))<br/>
&nbsp;&nbsp;| <span class="id">All</span> =&gt; <span class="id">I</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">Int.mone</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sign_ext_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">sign_ext</span> <span class="id">n</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt; <span class="id">n</span> &lt; <span class="id">Int.zwordsize</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.sign_ext</span> <span class="id">n</span> <span class="id">v</span>) (<span class="id">Val.sign_ext</span> <span class="id">n</span> <span class="id">w</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3235')">Proof.</div>
<div class="proofscript" id="proof3235">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sign_ext</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.sign_ext</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">j</span> := <span class="kwd">if</span> <span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span> <span class="kwd">then</span> <span class="id">i1</span> <span class="kwd">else</span> <span class="id">n</span> - 1).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (0 &lt;= <span class="id">j</span> &lt; <span class="id">Int.zwordsize</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">j</span>; <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>); <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>. <span class="tactic">apply</span> <span class="id">orb_true_intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">j</span>; <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">rewrite</span> <span class="id">zlt_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">rewrite</span> <span class="id">Int.unsigned_repr</span>. <span class="tactic">rewrite</span> <span class="id">zlt_false</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">n</span> - 1 - (<span class="id">n</span> - 1)) <span class="kwd">with</span> 0 <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Int.wordsize_max_unsigned</span>; <span class="tactic">omega</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Val.sign_ext</span>; <span class="id">InvAgree</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Val.lessdef_same</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="id">Int.bit_solve</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">j</span> := <span class="kwd">if</span> <span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span> <span class="kwd">then</span> <span class="id">i1</span> <span class="kwd">else</span> <span class="id">n</span> - 1).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (0 &lt;= <span class="id">j</span> &lt; <span class="id">Int.zwordsize</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">j</span>; <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>); <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zlt_true</span>. <span class="tactic">apply</span> <span class="id">Int.bits_mone</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">j</span>. <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>); <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The needs of a memory store concerning the value being stored. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">store_argument</span> (<span class="id">chunk</span>: <span class="id">memory_chunk</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">chunk</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Mint8signed</span> | <span class="id">Mint8unsigned</span> =&gt; <span class="id">I</span> (<span class="id">Int.repr</span> 255)<br/>
&nbsp;&nbsp;| <span class="id">Mint16signed</span> | <span class="id">Mint16unsigned</span> =&gt; <span class="id">I</span> (<span class="id">Int.repr</span> 65535)<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_argument_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">v</span> <span class="id">w</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">store_argument</span> <span class="id">chunk</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">memval_lessdef</span> (<span class="id">encode_val</span> <span class="id">chunk</span> <span class="id">v</span>) (<span class="id">encode_val</span> <span class="id">chunk</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3236')">Proof.</div>
<div class="proofscript" id="proof3236">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">UNDEF</span>: <span class="id">list_forall2</span> <span class="id">memval_lessdef</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">list_repeat</span> (<span class="id">size_chunk_nat</span> <span class="id">chunk</span>) <span class="id">Undef</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">encode_val</span> <span class="id">chunk</span> <span class="id">w</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">encode_val_length</span> <span class="id">chunk</span> <span class="id">w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">repeat_Undef_inject_any</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SAME</span>: <span class="kwd">forall</span> <span class="id">vl1</span> <span class="id">vl2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">vl1</span> = <span class="id">vl2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">memval_lessdef</span> <span class="id">vl1</span> <span class="id">vl2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">vl2</span>. <span class="id">revert</span> <span class="id">vl1</span>. <span class="tactic">induction</span> <span class="id">vl1</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">memval_lessdef_refl</span>.<br/>
&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">store_argument</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">SAME</span>. <span class="tactic">simpl</span>; <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">encode_int_8_mod</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> 8 <span class="kwd">with</span> (<span class="id">Int.size</span> (<span class="id">Int.repr</span> 255)). <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">SAME</span>. <span class="tactic">simpl</span>; <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">encode_int_8_mod</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> 8 <span class="kwd">with</span> (<span class="id">Int.size</span> (<span class="id">Int.repr</span> 255)). <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">SAME</span>. <span class="tactic">simpl</span>; <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">encode_int_16_mod</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> 16 <span class="kwd">with</span> (<span class="id">Int.size</span> (<span class="id">Int.repr</span> 65535)). <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvAgree</span>. <span class="tactic">apply</span> <span class="id">SAME</span>. <span class="tactic">simpl</span>; <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">encode_int_16_mod</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> 16 <span class="kwd">with</span> (<span class="id">Int.size</span> (<span class="id">Int.repr</span> 65535)). <span class="tactic">apply</span> <span class="id">iagree_eqmod</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">encode_val_inject</span>. <span class="tactic">rewrite</span> <span class="id">val_inject_id</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">store_argument_load_result</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">v</span> <span class="id">w</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">store_argument</span> <span class="id">chunk</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef</span> (<span class="id">Val.load_result</span> <span class="id">chunk</span> <span class="id">v</span>) (<span class="id">Val.load_result</span> <span class="id">chunk</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3237')">Proof.</div>
<div class="proofscript" id="proof3237">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_argument</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>;<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">using</span> <span class="id">Val.load_result_lessdef</span>; <span class="id">InvAgree</span>; <span class="tactic">simpl</span>.<br/>
- <span class="tactic">apply</span> <span class="id">sign_ext_sound</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">Vint</span> <span class="id">i</span>) (<span class="id">w</span> := <span class="id">Vint</span> <span class="id">i0</span>) (<span class="id">x</span> := <span class="id">All</span>) (<span class="id">n</span> := 8).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">compute</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">zero_ext_sound</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">Vint</span> <span class="id">i</span>) (<span class="id">w</span> := <span class="id">Vint</span> <span class="id">i0</span>) (<span class="id">x</span> := <span class="id">All</span>) (<span class="id">n</span> := 8).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
- <span class="tactic">apply</span> <span class="id">sign_ext_sound</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">Vint</span> <span class="id">i</span>) (<span class="id">w</span> := <span class="id">Vint</span> <span class="id">i0</span>) (<span class="id">x</span> := <span class="id">All</span>) (<span class="id">n</span> := 16).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">compute</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">zero_ext_sound</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">Vint</span> <span class="id">i</span>) (<span class="id">w</span> := <span class="id">Vint</span> <span class="id">i0</span>) (<span class="id">x</span> := <span class="id">All</span>) (<span class="id">n</span> := 16).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The needs of a comparison </div>
<br/>
<span class="kwd">Definition</span> <span class="id">maskzero</span> (<span class="id">n</span>: <span class="id">int</span>) := <span class="id">I</span> <span class="id">n</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">maskzero_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">n</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">maskzero</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.maskzero_bool</span> <span class="id">v</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.maskzero_bool</span> <span class="id">w</span> <span class="id">n</span> = <span class="id">Some</span> <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3238')">Proof.</div>
<div class="proofscript" id="proof3238">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">maskzero</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.maskzero_bool</span>; <span class="id">InvAgree</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">iagree_and_eq</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The default abstraction: if the result is unused, the arguments are
  unused; otherwise, the arguments are needed in full. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">default</span> (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">Nothing</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">All</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">DEFAULT</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variables</span> <span class="id">m1</span> <span class="id">m2</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">PERM</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">valid_pointer_inj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">ofs</span> <span class="id">b2</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_id</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_pointer</span> <span class="id">m1</span> <span class="id">b1</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_pointer</span> <span class="id">m2</span> <span class="id">b2</span> (<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>))) = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3239')">Proof.</div>
<div class="proofscript" id="proof3239">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">inject_id</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.valid_pointer_nonempty_perm</span> <span class="kwd">in</span> *. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">weak_valid_pointer_inj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">ofs</span> <span class="id">b2</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_id</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.weak_valid_pointer</span> <span class="id">m1</span> <span class="id">b1</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.weak_valid_pointer</span> <span class="id">m2</span> <span class="id">b2</span> (<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>))) = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3240')">Proof.</div>
<div class="proofscript" id="proof3240">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">inject_id</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Mem.weak_valid_pointer_spec</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">Mem.valid_pointer_nonempty_perm</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>; [<span class="id">left</span>|<span class="id">right</span>]; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">weak_valid_pointer_no_overflow</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">ofs</span> <span class="id">b2</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_id</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.weak_valid_pointer</span> <span class="id">m1</span> <span class="id">b1</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3241')">Proof.</div>
<div class="proofscript" id="proof3241">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">inject_id</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">Zplus_0_r</span>. <span class="tactic">apply</span> <span class="id">Ptrofs.unsigned_range_2</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Let</span> <span class="id">valid_different_pointers_inj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b1</span> <span class="id">ofs1</span> <span class="id">b2</span> <span class="id">ofs2</span> <span class="id">b1</span>' <span class="id">delta1</span> <span class="id">b2</span>' <span class="id">delta2</span>,<br/>
&nbsp;&nbsp;<span class="id">b1</span> &lt;&gt; <span class="id">b2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_pointer</span> <span class="id">m1</span> <span class="id">b1</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs1</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_pointer</span> <span class="id">m1</span> <span class="id">b2</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs2</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_id</span> <span class="id">b1</span> = <span class="id">Some</span> (<span class="id">b1</span>', <span class="id">delta1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_id</span> <span class="id">b2</span> = <span class="id">Some</span> (<span class="id">b2</span>', <span class="id">delta2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">b1</span>' &lt;&gt; <span class="id">b2</span>' \/<br/>
&nbsp;&nbsp;<span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs1</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta1</span>)) &lt;&gt; <span class="id">Ptrofs.unsigned</span> (<span class="id">Ptrofs.add</span> <span class="id">ofs2</span> (<span class="id">Ptrofs.repr</span> <span class="id">delta2</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3242')">Proof.</div>
<div class="proofscript" id="proof3242">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">inject_id</span>; <span class="tactic">intros</span>. <span class="id">left</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">default_needs_of_condition_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cond</span> <span class="id">args1</span> <span class="id">b</span> <span class="id">args2</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_condition</span> <span class="id">cond</span> <span class="id">args1</span> <span class="id">m1</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree_list</span> <span class="id">args1</span> <span class="id">args2</span> <span class="id">nil</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_condition</span> <span class="id">cond</span> <span class="id">args2</span> <span class="id">m2</span> = <span class="id">Some</span> <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3243')">Proof.</div>
<div class="proofscript" id="proof3243">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">eval_condition_inj</span> <span class="kwd">with</span> (<span class="id">f</span> := <span class="id">inject_id</span>) (<span class="id">m1</span> := <span class="id">m1</span>) (<span class="id">vl1</span> := <span class="id">args1</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">val_inject_list_lessdef</span>. <span class="tactic">apply</span> <span class="id">lessdef_vagree_list</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">default_needs_of_operation_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">args1</span> <span class="id">v1</span> <span class="id">args2</span> <span class="id">nv</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">op</span> <span class="id">args1</span> <span class="id">m1</span> = <span class="id">Some</span> <span class="id">v1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree_list</span> <span class="id">args1</span> <span class="id">args2</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;\/ <span class="id">vagree_list</span> <span class="id">args1</span> <span class="id">args2</span> (<span class="id">default</span> <span class="id">nv</span> :: <span class="id">nil</span>)<br/>
&nbsp;&nbsp;\/ <span class="id">vagree_list</span> <span class="id">args1</span> <span class="id">args2</span> (<span class="id">default</span> <span class="id">nv</span> :: <span class="id">default</span> <span class="id">nv</span> :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">nv</span> &lt;&gt; <span class="id">Nothing</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">op</span> <span class="id">args2</span> <span class="id">m2</span> = <span class="id">Some</span> <span class="id">v2</span><br/>
&nbsp;&nbsp;/\ <span class="id">vagree</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">nv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3244')">Proof.</div>
<div class="proofscript" id="proof3244">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">default</span> <span class="id">nv</span> = <span class="id">All</span>) <span class="tactic">by</span> (<span class="tactic">destruct</span> <span class="id">nv</span>; <span class="tactic">simpl</span>; <span class="tactic">congruence</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef_list</span> <span class="id">args1</span> <span class="id">args2</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>. <span class="id">inv</span> <span class="id">H8</span>; <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">na</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">eval_operation_inj</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">ge</span> <span class="id">ge</span> <span class="id">inject_id</span>).<br/>
&nbsp;&nbsp;<span class="id">eassumption</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">op</span>). <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">val_inject_lessdef</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">val_inject_lessdef</span>. <span class="id">instantiate</span> (1 := <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>). <span class="id">instantiate</span> (1 := <span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">val_inject_list_lessdef</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">vagree_lessdef</span>. <span class="tactic">apply</span> <span class="id">val_inject_lessdef</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">DEFAULT</span>.<br/>
<br/>
<h2> Detecting operations that are redundant and can be turned into a move </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">andimm_redundant</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">Int.eq_dec</span> (<span class="id">Int.and</span> <span class="id">m</span> (<span class="id">Int.not</span> <span class="id">n</span>)) <span class="id">Int.zero</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">andimm_redundant_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">andimm_redundant</span> <span class="id">x</span> <span class="id">n</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">andimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.and</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3245')">Proof.</div>
<div class="proofscript" id="proof3245">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">andimm_redundant</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">InvBooleans</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">unfold</span> <span class="id">Val.and</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> (<span class="id">eq_same_bits</span> <span class="id">i1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.testbit</span> <span class="id">n</span> <span class="id">i1</span>) <span class="id">eqn</span>:<span class="id">N</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">andb_true_r</span>. <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>, <span class="id">N</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">orimm_redundant</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">n</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">Int.eq_dec</span> (<span class="id">Int.and</span> <span class="id">m</span> <span class="id">n</span>) <span class="id">Int.zero</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">orimm_redundant_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">orimm_redundant</span> <span class="id">x</span> <span class="id">n</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">orimm</span> <span class="id">x</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.or</span> <span class="id">v</span> (<span class="id">Vint</span> <span class="id">n</span>)) <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3246')">Proof.</div>
<div class="proofscript" id="proof3246">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">orimm_redundant</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvBooleans</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">unfold</span> <span class="id">Val.or</span>; <span class="id">InvAgree</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">iagree_not</span>'. <span class="tactic">rewrite</span> <span class="id">Int.not_or_and_not</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">andimm_redundant_sound</span> (<span class="id">Vint</span> (<span class="id">Int.not</span> <span class="id">i</span>)) (<span class="id">Vint</span> (<span class="id">Int.not</span> <span class="id">i0</span>)) (<span class="id">I</span> <span class="id">m</span>) (<span class="id">Int.not</span> <span class="id">n</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Int.not_involutive</span>. <span class="tactic">apply</span> <span class="id">proj_sumbool_is_true</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">iagree_not</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">rolm_redundant</span> (<span class="id">x</span>: <span class="id">nval</span>) (<span class="id">amount</span> <span class="id">mask</span>: <span class="id">int</span>) :=<br/>
&nbsp;&nbsp;<span class="id">Int.eq_dec</span> <span class="id">amount</span> <span class="id">Int.zero</span> &amp;&amp; <span class="id">andimm_redundant</span> <span class="id">x</span> <span class="id">mask</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">rolm_redundant_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">amount</span> <span class="id">mask</span>,<br/>
&nbsp;&nbsp;<span class="id">rolm_redundant</span> <span class="id">x</span> <span class="id">amount</span> <span class="id">mask</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">rolm</span> <span class="id">x</span> <span class="id">amount</span> <span class="id">mask</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.rolm</span> <span class="id">v</span> <span class="id">amount</span> <span class="id">mask</span>) <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3247')">Proof.</div>
<div class="proofscript" id="proof3247">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rolm_redundant</span>; <span class="tactic">intros</span>; <span class="id">InvBooleans</span>. <span class="tactic">subst</span> <span class="id">amount</span>. <span class="tactic">rewrite</span> <span class="id">Val.rolm_zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">andimm_redundant_sound</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">n</span>, <span class="id">Int.ror</span> <span class="id">n</span> <span class="id">Int.zero</span> = <span class="id">n</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Int.ror_rol_neg</span> <span class="tactic">by</span> <span class="tactic">apply</span> <span class="id">int_wordsize_divides_modulus</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.neg_zero</span>. <span class="tactic">apply</span> <span class="id">Int.rol_zero</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">rolm</span>, <span class="id">rol</span>, <span class="id">andimm</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">zero_ext_redundant</span> (<span class="id">n</span>: <span class="id">Z</span>) (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">Int.eq_dec</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">m</span>) <span class="id">m</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">zero_ext_redundant_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">zero_ext_redundant</span> <span class="id">n</span> <span class="id">x</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">zero_ext</span> <span class="id">n</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.zero_ext</span> <span class="id">n</span> <span class="id">v</span>) <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3248')">Proof.</div>
<div class="proofscript" id="proof3248">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">zero_ext_redundant</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">InvAgree</span>. <span class="tactic">simpl</span>. <span class="id">InvBooleans</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>). <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">zlt_false</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">sign_ext_redundant</span> (<span class="id">n</span>: <span class="id">Z</span>) (<span class="id">x</span>: <span class="id">nval</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Nothing</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">I</span> <span class="id">m</span> =&gt; <span class="id">Int.eq_dec</span> (<span class="id">Int.zero_ext</span> <span class="id">n</span> <span class="id">m</span>) <span class="id">m</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sign_ext_redundant_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">w</span> <span class="id">x</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">sign_ext_redundant</span> <span class="id">n</span> <span class="id">x</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v</span> <span class="id">w</span> (<span class="id">sign_ext</span> <span class="id">n</span> <span class="id">x</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt; <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">vagree</span> (<span class="id">Val.sign_ext</span> <span class="id">n</span> <span class="id">v</span>) <span class="id">w</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3249')">Proof.</div>
<div class="proofscript" id="proof3249">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sign_ext_redundant</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">InvAgree</span>. <span class="tactic">simpl</span>. <span class="id">InvBooleans</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">ints</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">i1</span> <span class="id">n</span>). <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.bits_or</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H3</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.bits_zero_ext</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">zlt_false</span> <span class="kwd">in</span> <span class="id">H3</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<h1> Neededness for register environments </h1>
<br/>
<span class="kwd">Module</span> <span class="id">NVal</span> &lt;: <span class="id">SEMILATTICE</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">t</span> := <span class="id">nval</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">eq</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) := (<span class="id">x</span> = <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">eq_refl</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">x</span> := (@<span class="id">refl_equal</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">eq_sym</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">eq</span> <span class="id">y</span> <span class="id">x</span> := (@<span class="id">sym_equal</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">eq_trans</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">eq</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">eq</span> <span class="id">x</span> <span class="id">z</span> := (@<span class="id">trans_equal</span> <span class="id">t</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">beq</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) : <span class="id">bool</span> := <span class="id">proj_sumbool</span> (<span class="id">eq_nval</span> <span class="id">x</span> <span class="id">y</span>).<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">beq_correct</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">beq</span> <span class="id">x</span> <span class="id">y</span> = <span class="id">true</span> -&gt; <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3250')">Proof.</div>
<div class="proofscript" id="proof3250">
 <span class="tactic">unfold</span> <span class="id">beq</span>; <span class="tactic">intros</span>. <span class="id">InvBooleans</span>. <span class="tactic">auto</span>. Qed.</div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ge</span> := <span class="id">nge</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_refl</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">ge</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3251')">Proof.</div>
<div class="proofscript" id="proof3251">
 <span class="tactic">unfold</span> <span class="id">eq</span>, <span class="id">ge</span>; <span class="tactic">intros</span>. <span class="tactic">subst</span> <span class="id">y</span>. <span class="tactic">apply</span> <span class="id">nge_refl</span>. Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_trans</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>, <span class="id">ge</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">ge</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">ge</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3252')">Proof.</div>
<div class="proofscript" id="proof3252">
 <span class="tactic">unfold</span> <span class="id">ge</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">nge_trans</span>; <span class="tactic">eauto</span>. Qed.</div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">bot</span> : <span class="id">t</span> := <span class="id">Nothing</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_bot</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ge</span> <span class="id">x</span> <span class="id">bot</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3253')">Proof.</div>
<div class="proofscript" id="proof3253">
 <span class="tactic">intros</span>. <span class="id">constructor</span>. Qed.</div>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">lub</span> := <span class="id">nlub</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_lub_left</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">ge</span> (<span class="id">lub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Proof</span> <span class="id">nge_lub_l</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_lub_right</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">ge</span> (<span class="id">lub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">y</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Proof</span> <span class="id">nge_lub_r</span>.<br/>
<span class="kwd">End</span> <span class="id">NVal</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">NE</span> := <span class="id">LPMap1</span>(<span class="id">NVal</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nenv</span> := <span class="id">NE.t</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">nreg</span> (<span class="id">ne</span>: <span class="id">nenv</span>) (<span class="id">r</span>: <span class="id">reg</span>) := <span class="id">NE.get</span> <span class="id">r</span> <span class="id">ne</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">eagree</span> (<span class="id">e1</span> <span class="id">e2</span>: <span class="id">regset</span>) (<span class="id">ne</span>: <span class="id">nenv</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">vagree</span> <span class="id">e1</span>#<span class="id">r</span> <span class="id">e2</span>#<span class="id">r</span> (<span class="id">NE.get</span> <span class="id">r</span> <span class="id">ne</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nreg_agree</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rs1</span> <span class="id">rs2</span> <span class="id">ne</span> <span class="id">r</span>, <span class="id">eagree</span> <span class="id">rs1</span> <span class="id">rs2</span> <span class="id">ne</span> -&gt; <span class="id">vagree</span> <span class="id">rs1</span>#<span class="id">r</span> <span class="id">rs2</span>#<span class="id">r</span> (<span class="id">nreg</span> <span class="id">ne</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3254')">Proof.</div>
<div class="proofscript" id="proof3254">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">nreg_agree</span>: <span class="id">na</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_ge</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> <span class="id">ne</span>',<br/>
&nbsp;&nbsp;<span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> -&gt; <span class="id">NE.ge</span> <span class="id">ne</span> <span class="id">ne</span>' -&gt; <span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3255')">Proof.</div>
<div class="proofscript" id="proof3255">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">nge_agree</span> <span class="kwd">with</span> (<span class="id">NE.get</span> <span class="id">r</span> <span class="id">ne</span>); <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_bot</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span>, <span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">NE.bot</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3256')">Proof.</div>
<div class="proofscript" id="proof3256">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">NE.get_bot</span>. <span class="tactic">exact</span> <span class="id">Logic.I</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_same</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">ne</span>, <span class="id">eagree</span> <span class="id">e</span> <span class="id">e</span> <span class="id">ne</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3257')">Proof.</div>
<div class="proofscript" id="proof3257">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">vagree_same</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_update_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">nv</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> -&gt; <span class="id">vagree</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">nv</span> -&gt; <span class="id">eagree</span> (<span class="id">e1</span>#<span class="id">r</span> &lt;- <span class="id">v1</span>) (<span class="id">e2</span>#<span class="id">r</span> &lt;- <span class="id">v2</span>) (<span class="id">NE.set</span> <span class="id">r</span> <span class="id">nv</span> <span class="id">ne</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3258')">Proof.</div>
<div class="proofscript" id="proof3258">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">NE.gsspec</span>. <span class="tactic">rewrite</span> ! <span class="id">PMap.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_update</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">vagree</span> <span class="id">v1</span> <span class="id">v2</span> (<span class="id">nreg</span> <span class="id">ne</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> (<span class="id">NE.set</span> <span class="id">r</span> <span class="id">Nothing</span> <span class="id">ne</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eagree</span> (<span class="id">e1</span>#<span class="id">r</span> &lt;- <span class="id">v1</span>) (<span class="id">e2</span>#<span class="id">r</span> &lt;- <span class="id">v2</span>) <span class="id">ne</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3259')">Proof.</div>
<div class="proofscript" id="proof3259">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">specialize</span> (<span class="id">H0</span> <span class="id">r0</span>). <span class="tactic">rewrite</span> <span class="id">NE.gsspec</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">PMap.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">r0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eagree_update_dead</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> <span class="id">v1</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">nreg</span> <span class="id">ne</span> <span class="id">r</span> = <span class="id">Nothing</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eagree</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">ne</span> -&gt; <span class="id">eagree</span> (<span class="id">e1</span>#<span class="id">r</span> &lt;- <span class="id">v1</span>) <span class="id">e2</span> <span class="id">ne</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3260')">Proof.</div>
<div class="proofscript" id="proof3260">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gsspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">auto</span>. <span class="tactic">subst</span>. <span class="tactic">unfold</span> <span class="id">nreg</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Neededness for memory locations </h1>
<br/>
<span class="kwd">Inductive</span> <span class="id">nmem</span> : <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> (<span class="id">stk</span>: <span class="id">ISet.t</span>) (<span class="id">gl</span>: <span class="id">PTree.t</span> <span class="id">ISet.t</span>).<br/>
<br/>
<div class="doc">Interpretation of <span class="bracket"><span class="id">nmem</span></span>:
<ul>
<li>
 <span class="bracket"><span class="id">NMemDead</span></span>: all memory locations are unused (dead).  Acts as bottom.
</li>
<li>
 <span class="bracket"><span class="id">NMem</span> <span class="id">stk</span> <span class="id">gl</span></span>: all memory locations are used, except:
  - the stack locations whose offset is in the interval <span class="bracket"><span class="id">stk</span></span>
  - the global locations whose offset is in the corresponding entry of <span class="bracket"><span class="id">gl</span></span>.
</li>
</ul>
</div>
<br/>
<span class="kwd">Section</span> <span class="id">LOCATIONS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">block</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">nlive</span>: <span class="id">nmem</span> -&gt; <span class="id">block</span> -&gt; <span class="id">Z</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">nlive_intro</span>: <span class="kwd">forall</span> <span class="id">stk</span> <span class="id">gl</span> <span class="id">b</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">b</span> = <span class="id">sp</span> -&gt; ~<span class="id">ISet.In</span> <span class="id">ofs</span> <span class="id">stk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GL</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">iv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">gl</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">iv</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~<span class="id">ISet.In</span> <span class="id">ofs</span> <span class="id">iv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">nlive</span> (<span class="id">NMem</span> <span class="id">stk</span> <span class="id">gl</span>) <span class="id">b</span> <span class="id">ofs</span>.<br/>
<br/>
<div class="doc">All locations are live </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_all</span> := <span class="id">NMem</span> <span class="id">ISet.empty</span> (<span class="id">PTree.empty</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_all</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span>, <span class="id">nlive</span> <span class="id">nmem_all</span> <span class="id">b</span> <span class="id">ofs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3261')">Proof.</div>
<div class="proofscript" id="proof3261">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ISet.In_empty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Add a range of live locations to <span class="bracket"><span class="id">nm</span></span>.  The range starts at
  the abstract pointer <span class="bracket"><span class="id">p</span></span> and has length <span class="bracket"><span class="id">sz</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_add</span> (<span class="id">nm</span>: <span class="id">nmem</span>) (<span class="id">p</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) : <span class="id">nmem</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nm</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span> =&gt; <span class="id">nmem_all</span>       <span class="docright">(* very conservative, should never happen  *)</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> <span class="id">stk</span> <span class="id">gl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">p</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">iv</span> =&gt; <span class="id">NMem</span> <span class="id">stk</span> (<span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">ISet.remove</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">iv</span>) <span class="id">gl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">nm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Glo</span> <span class="id">id</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> <span class="id">stk</span> (<span class="id">PTree.remove</span> <span class="id">id</span> <span class="id">gl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Stk</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> (<span class="id">ISet.remove</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">stk</span>) <span class="id">gl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Stack</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> <span class="id">ISet.empty</span> <span class="id">gl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">nmem_all</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_add</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> <span class="id">nm</span> <span class="id">sz</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> &lt;= <span class="id">i</span> &lt; <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nlive</span> (<span class="id">nmem_add</span> <span class="id">nm</span> <span class="id">p</span> <span class="id">sz</span>) <span class="id">b</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3262')">Proof.</div>
<div class="proofscript" id="proof3262">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">nmem_add</span>. <span class="tactic">destruct</span> <span class="id">nm</span>. <span class="tactic">apply</span> <span class="id">nlive_all</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">nlive_all</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Gl&nbsp;id&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv</span>|] <span class="id">eqn</span>:<span class="id">NG</span>.<br/>
&nbsp;&nbsp;+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">id0</span> = <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_vars_inj</span>; <span class="tactic">eauto</span>). <span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gss</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="id">inv</span> <span class="id">H5</span>. <span class="tactic">rewrite</span> <span class="id">ISet.In_remove</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> <span class="id">A</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">id0</span> = <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_vars_inj</span>; <span class="tactic">eauto</span>). <span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Glo&nbsp;id&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">id0</span> = <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">Genv.genv_vars_inj</span>; <span class="tactic">eauto</span>). <span class="tactic">subst</span> <span class="id">id0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.grs</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Stk&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_remove</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> <span class="id">A</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">bc</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Stack&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ISet.In_empty</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">bc</span> <span class="id">b</span> = <span class="id">BCglob</span> <span class="id">id</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>). <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">incl_nmem_add</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nm</span> <span class="id">b</span> <span class="id">i</span> <span class="id">p</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">nlive</span> <span class="id">nm</span> <span class="id">b</span> <span class="id">i</span> -&gt; <span class="id">nlive</span> (<span class="id">nmem_add</span> <span class="id">nm</span> <span class="id">p</span> <span class="id">sz</span>) <span class="id">b</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3263')">Proof.</div>
<div class="proofscript" id="proof3263">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>. <span class="tactic">unfold</span> <span class="id">nmem_add</span>; <span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">nlive_all</span>).<br/>
- <span class="comment">(*&nbsp;Gl&nbsp;id&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv</span>|] <span class="id">eqn</span>:<span class="id">NG</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>); <span class="tactic">eauto</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_remove</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">GL</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;Glo&nbsp;id&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.grspec</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">id0</span> <span class="id">id</span>). <span class="tactic">congruence</span>. <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;Stk&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_remove</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">STK</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;Stack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ISet.In_empty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Remove a range of locations from <span class="bracket"><span class="id">nm</span></span>, marking these locations as dead.
  The range starts at the abstract pointer <span class="bracket"><span class="id">p</span></span> and has length <span class="bracket"><span class="id">sz</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_remove</span> (<span class="id">nm</span>: <span class="id">nmem</span>) (<span class="id">p</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) : <span class="id">nmem</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nm</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span> =&gt; <span class="id">NMemDead</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> <span class="id">stk</span> <span class="id">gl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">p</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">iv</span>' :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">iv</span> =&gt; <span class="id">ISet.add</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">iv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span>    =&gt; <span class="id">ISet.interval</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> <span class="id">stk</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">iv</span>' <span class="id">gl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Stk</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> (<span class="id">ISet.add</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">stk</span>) <span class="id">gl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">nm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_remove</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> <span class="id">nm</span> <span class="id">sz</span> <span class="id">b</span>' <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nlive</span> <span class="id">nm</span> <span class="id">b</span>' <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">b</span>' &lt;&gt; <span class="id">b</span> \/ <span class="id">i</span> &lt; <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> \/ <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span> &lt;= <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nlive</span> (<span class="id">nmem_remove</span> <span class="id">nm</span> <span class="id">p</span> <span class="id">sz</span>) <span class="id">b</span>' <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3264')">Proof.</div>
<div class="proofscript" id="proof3264">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H2</span>; <span class="tactic">subst</span>. <span class="tactic">unfold</span> <span class="id">nmem_remove</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;Gl&nbsp;id&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">iv</span>' := <span class="kwd">match</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">iv</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ISet.add</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">iv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ISet.interval</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
+ <span class="id">inv</span> <span class="id">H6</span>. <span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">congruence</span>. <span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv0</span>|] <span class="id">eqn</span>:<span class="id">NG</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">iv</span>'; <span class="tactic">rewrite</span> <span class="id">ISet.In_add</span>. <span class="tactic">intros</span> [<span class="id">P</span>|<span class="id">P</span>]. <span class="tactic">omega</span>. <span class="id">eelim</span> <span class="id">GL</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">iv</span>'; <span class="tactic">rewrite</span> <span class="id">ISet.In_interval</span>. <span class="tactic">omega</span>.<br/>
+ <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;Stk&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H3</span>. <span class="tactic">subst</span> <span class="id">b</span>'. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_add</span>. <span class="tactic">intros</span> [<span class="id">P</span>|<span class="id">P</span>]. <span class="tactic">omega</span>. <span class="tactic">eapply</span> <span class="id">STK</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Test (conservatively) whether some locations in the range delimited
  by <span class="bracket"><span class="id">p</span></span> and <span class="bracket"><span class="id">sz</span></span> can be live in <span class="bracket"><span class="id">nm</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_contains</span> (<span class="id">nm</span>: <span class="id">nmem</span>) (<span class="id">p</span>: <span class="id">aptr</span>) (<span class="id">sz</span>: <span class="id">Z</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nm</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> <span class="id">stk</span> <span class="id">gl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">p</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Gl</span> <span class="id">id</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">iv</span> =&gt; <span class="id">negb</span> (<span class="id">ISet.contains</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">iv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Stk</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">negb</span> (<span class="id">ISet.contains</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">stk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">true</span>  <span class="docright">(* conservative answer  *)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_contains</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> <span class="id">nm</span> <span class="id">sz</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">genv_match</span> <span class="id">bc</span> <span class="id">ge</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bc</span> <span class="id">sp</span> = <span class="id">BCstack</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">pmatch</span> <span class="id">bc</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">nmem_contains</span> <span class="id">nm</span> <span class="id">p</span> <span class="id">sz</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> &lt;= <span class="id">i</span> &lt; <span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;~(<span class="id">nlive</span> <span class="id">nm</span> <span class="id">b</span> <span class="id">i</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3265')">Proof.</div>
<div class="proofscript" id="proof3265">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nmem_contains</span>; <span class="tactic">intros</span>. <span class="tactic">red</span>; <span class="tactic">intros</span> <span class="id">L</span>; <span class="id">inv</span> <span class="id">L</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="comment">(*&nbsp;Gl&nbsp;id&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv</span>|] <span class="id">eqn</span>:<span class="id">HG</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ISet.contains</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">iv</span>) <span class="id">eqn</span>:<span class="id">IC</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.contains_spec</span> <span class="kwd">in</span> <span class="id">IC</span>. <span class="id">eelim</span> <span class="id">GL</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;Stk&nbsp;ofs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ISet.contains</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span>) (<span class="id">Ptrofs.unsigned</span> <span class="id">ofs</span> + <span class="id">sz</span>) <span class="id">stk</span>) <span class="id">eqn</span>:<span class="id">IC</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.contains_spec</span> <span class="kwd">in</span> <span class="id">IC</span>. <span class="id">eelim</span> <span class="id">STK</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">bc_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Kill all stack locations between 0 and <span class="bracket"><span class="id">sz</span></span>, and mark everything else
  as live.  This reflects the effect of freeing the stack block at
  a <span class="bracket"><span class="id">Ireturn</span></span> or <span class="bracket"><span class="id">Itailcall</span></span> instruction. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_dead_stack</span> (<span class="id">sz</span>: <span class="id">Z</span>) :=<br/>
&nbsp;&nbsp;<span class="id">NMem</span> (<span class="id">ISet.interval</span> 0 <span class="id">sz</span>) (<span class="id">PTree.empty</span> <span class="id">_</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_dead_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sz</span> <span class="id">b</span>' <span class="id">i</span>, <span class="id">b</span>' &lt;&gt; <span class="id">sp</span> \/ ~(0 &lt;= <span class="id">i</span> &lt; <span class="id">sz</span>) -&gt; <span class="id">nlive</span> (<span class="id">nmem_dead_stack</span> <span class="id">sz</span>) <span class="id">b</span>' <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3266')">Proof.</div>
<div class="proofscript" id="proof3266">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">ISet.In_interval</span>. <span class="tactic">intuition</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Least upper bound </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_lub</span> (<span class="id">nm1</span> <span class="id">nm2</span>: <span class="id">nmem</span>) : <span class="id">nmem</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nm1</span>, <span class="id">nm2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span>, <span class="id">_</span> =&gt; <span class="id">nm2</span><br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">NMemDead</span> =&gt; <span class="id">nm1</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> <span class="id">stk1</span> <span class="id">gl1</span>, <span class="id">NMem</span> <span class="id">stk2</span> <span class="id">gl2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NMem</span> (<span class="id">ISet.inter</span> <span class="id">stk1</span> <span class="id">stk2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PTree.combine</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">o1</span> <span class="id">o2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">o1</span>, <span class="id">o2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">iv1</span>, <span class="id">Some</span> <span class="id">iv2</span> =&gt; <span class="id">Some</span>(<span class="id">ISet.inter</span> <span class="id">iv1</span> <span class="id">iv2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">gl1</span> <span class="id">gl2</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_lub_l</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nm1</span> <span class="id">nm2</span> <span class="id">b</span> <span class="id">i</span>, <span class="id">nlive</span> <span class="id">nm1</span> <span class="id">b</span> <span class="id">i</span> -&gt; <span class="id">nlive</span> (<span class="id">nmem_lub</span> <span class="id">nm1</span> <span class="id">nm2</span>) <span class="id">b</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3267')">Proof.</div>
<div class="proofscript" id="proof3267">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>. <span class="tactic">destruct</span> <span class="id">nm2</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">ISet.In_inter</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">STK</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.gcombine</span> <span class="kwd">in</span> <span class="id">H1</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv1</span>|] <span class="id">eqn</span>:<span class="id">NG1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl0</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv2</span>|] <span class="id">eqn</span>:<span class="id">NG2</span>; <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_inter</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">GL</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nlive_lub_r</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nm1</span> <span class="id">nm2</span> <span class="id">b</span> <span class="id">i</span>, <span class="id">nlive</span> <span class="id">nm2</span> <span class="id">b</span> <span class="id">i</span> -&gt; <span class="id">nlive</span> (<span class="id">nmem_lub</span> <span class="id">nm1</span> <span class="id">nm2</span>) <span class="id">b</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3268')">Proof.</div>
<div class="proofscript" id="proof3268">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>. <span class="tactic">destruct</span> <span class="id">nm1</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">ISet.In_inter</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">STK</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">PTree.gcombine</span> <span class="kwd">in</span> <span class="id">H1</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl0</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv1</span>|] <span class="id">eqn</span>:<span class="id">NG1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">gl</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv2</span>|] <span class="id">eqn</span>:<span class="id">NG2</span>; <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.In_inter</span>. <span class="tactic">intros</span> [<span class="id">P</span> <span class="id">Q</span>]. <span class="id">eelim</span> <span class="id">GL</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Boolean-valued equality test </div>
<br/>
<span class="kwd">Definition</span> <span class="id">nmem_beq</span> (<span class="id">nm1</span> <span class="id">nm2</span>: <span class="id">nmem</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">nm1</span>, <span class="id">nm2</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">NMemDead</span>, <span class="id">NMemDead</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">NMem</span> <span class="id">stk1</span> <span class="id">gl1</span>, <span class="id">NMem</span> <span class="id">stk2</span> <span class="id">gl2</span> =&gt; <span class="id">ISet.beq</span> <span class="id">stk1</span> <span class="id">stk2</span> &amp;&amp; <span class="id">PTree.beq</span> <span class="id">ISet.beq</span> <span class="id">gl1</span> <span class="id">gl2</span><br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">nmem_beq_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">nm1</span> <span class="id">nm2</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">nmem_beq</span> <span class="id">nm1</span> <span class="id">nm2</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">nlive</span> <span class="id">nm1</span> <span class="id">b</span> <span class="id">ofs</span> &lt;-&gt; <span class="id">nlive</span> <span class="id">nm2</span> <span class="id">b</span> <span class="id">ofs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3269')">Proof.</div>
<div class="proofscript" id="proof3269">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">nmem_beq</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nm1</span> <span class="kwd">as</span> [ | <span class="id">stk1</span> <span class="id">gl1</span>]; <span class="tactic">destruct</span> <span class="id">nm2</span> <span class="kwd">as</span> [ | <span class="id">stk2</span> <span class="id">gl2</span>]; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">split</span>; <span class="tactic">intros</span> <span class="id">L</span>; <span class="id">inv</span> <span class="id">L</span>.<br/>
- <span class="id">InvBooleans</span>. <span class="tactic">rewrite</span> <span class="id">ISet.beq_spec</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">PTree.beq_correct</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span> <span class="id">L</span>; <span class="id">inv</span> <span class="id">L</span>; <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
+ <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
+ <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">id</span>). <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">gl1</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv1</span>|] <span class="id">eqn</span>: <span class="id">NG</span>; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.beq_spec</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H1</span>. <span class="tactic">eauto</span>.<br/>
+ <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
+ <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">id</span>). <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">gl2</span>!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">iv2</span>|] <span class="id">eqn</span>: <span class="id">NG</span>; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">ISet.beq_spec</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">LOCATIONS</span>.<br/>
<br/>
<br/>
<h1> The lattice for dataflow analysis </h1>
<br/>
<span class="kwd">Module</span> <span class="id">NA</span> &lt;: <span class="id">SEMILATTICE</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">t</span> := (<span class="id">nenv</span> * <span class="id">nmem</span>)%<span class="id">type</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">eq</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NE.eq</span> (<span class="id">fst</span> <span class="id">x</span>) (<span class="id">fst</span> <span class="id">y</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">b</span> <span class="id">ofs</span>, <span class="id">nlive</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">snd</span> <span class="id">x</span>) <span class="id">b</span> <span class="id">ofs</span> &lt;-&gt; <span class="id">nlive</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">snd</span> <span class="id">y</span>) <span class="id">b</span> <span class="id">ofs</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">eq_refl</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3270')">Proof.</div>
<div class="proofscript" id="proof3270">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eq</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">NE.eq_refl</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">eq_sym</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">eq</span> <span class="id">y</span> <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3271')">Proof.</div>
<div class="proofscript" id="proof3271">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eq</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">NE.eq_sym</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">eq_trans</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">eq</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">eq</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3272')">Proof.</div>
<div class="proofscript" id="proof3272">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eq</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>, <span class="id">z</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>] [<span class="id">C</span> <span class="id">D</span>]; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NE.eq_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">beq</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NE.beq</span> (<span class="id">fst</span> <span class="id">x</span>) (<span class="id">fst</span> <span class="id">y</span>) &amp;&amp; <span class="id">nmem_beq</span> (<span class="id">snd</span> <span class="id">x</span>) (<span class="id">snd</span> <span class="id">y</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">beq_correct</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">beq</span> <span class="id">x</span> <span class="id">y</span> = <span class="id">true</span> -&gt; <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3273')">Proof.</div>
<div class="proofscript" id="proof3273">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">beq</span>, <span class="id">eq</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="id">InvBooleans</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NE.beq_correct</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">nmem_beq_sound</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">ge</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NE.ge</span> (<span class="id">fst</span> <span class="id">x</span>) (<span class="id">fst</span> <span class="id">y</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">sp</span> <span class="id">b</span> <span class="id">ofs</span>, <span class="id">nlive</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">snd</span> <span class="id">y</span>) <span class="id">b</span> <span class="id">ofs</span> -&gt; <span class="id">nlive</span> <span class="id">ge</span> <span class="id">sp</span> (<span class="id">snd</span> <span class="id">x</span>) <span class="id">b</span> <span class="id">ofs</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_refl</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">eq</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">ge</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3274')">Proof.</div>
<div class="proofscript" id="proof3274">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">eq</span>, <span class="id">ge</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NE.ge_refl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_trans</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">z</span>, <span class="id">ge</span> <span class="id">x</span> <span class="id">y</span> -&gt; <span class="id">ge</span> <span class="id">y</span> <span class="id">z</span> -&gt; <span class="id">ge</span> <span class="id">x</span> <span class="id">z</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3275')">Proof.</div>
<div class="proofscript" id="proof3275">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ge</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>, <span class="id">z</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>] [<span class="id">C</span> <span class="id">D</span>]; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">NE.ge_trans</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">bot</span> : <span class="id">t</span> := (<span class="id">NE.bot</span>, <span class="id">NMemDead</span>).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_bot</span>: <span class="kwd">forall</span> <span class="id">x</span>, <span class="id">ge</span> <span class="id">x</span> <span class="id">bot</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3276')">Proof.</div>
<div class="proofscript" id="proof3276">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ge</span>, <span class="id">bot</span>; <span class="tactic">destruct</span> <span class="id">x</span>; <span class="tactic">simpl</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NE.ge_bot</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
&nbsp;&nbsp;<span class="kwd">Definition</span> <span class="id">lub</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">t</span>) : <span class="id">t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">NE.lub</span> (<span class="id">fst</span> <span class="id">x</span>) (<span class="id">fst</span> <span class="id">y</span>), <span class="id">nmem_lub</span> (<span class="id">snd</span> <span class="id">x</span>) (<span class="id">snd</span> <span class="id">y</span>)).<br/>
<br/>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_lub_left</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">ge</span> (<span class="id">lub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">x</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3277')">Proof.</div>
<div class="proofscript" id="proof3277">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ge</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NE.ge_lub_left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">nlive_lub_l</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
&nbsp;&nbsp;<span class="kwd">Lemma</span> <span class="id">ge_lub_right</span>: <span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span>, <span class="id">ge</span> (<span class="id">lub</span> <span class="id">x</span> <span class="id">y</span>) <span class="id">y</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3278')">Proof.</div>
<div class="proofscript" id="proof3278">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ge</span>; <span class="tactic">destruct</span> <span class="id">x</span>, <span class="id">y</span>; <span class="tactic">simpl</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NE.ge_lub_right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">nlive_lub_r</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">NA</span>.<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
