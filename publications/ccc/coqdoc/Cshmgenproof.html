<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Cshmgenproof</title>
<meta name="description" content="Documentation of Coq module Cshmgenproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Cshmgenproof</h1>
<div class="coq">
<br/>
<h1> Correctness of the translation from Clight to C#minor. </h1>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Errors</span> <span class="id">Maps</span> <span class="id">Integers</span> <span class="id">Floats</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Events</span> <span class="id">Memory</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Ctypes</span> <span class="id">Cop</span> <span class="id">Clight</span> <span class="id">Cminor</span> <span class="id">Csharpminor</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Cshmgen</span>.<br/>
<br/>
<h1> Relational specification of the transformation </h1>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_fundef</span> (<span class="id">p</span>: <span class="id">Clight.program</span>) : <span class="id">Clight.fundef</span> -&gt; <span class="id">Csharpminor.fundef</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_fundef_internal</span>: <span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_function</span> <span class="id">p</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_fundef</span> <span class="id">p</span> (<span class="id">Ctypes.Internal</span> <span class="id">f</span>) (<span class="id">AST.Internal</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_fundef_external</span>: <span class="kwd">forall</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ef_sig</span> <span class="id">ef</span> = <span class="id">signature_of_type</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_fundef</span> <span class="id">p</span> (<span class="id">Ctypes.External</span> <span class="id">ef</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>) (<span class="id">AST.External</span> <span class="id">ef</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_varinfo</span> (<span class="id">v</span>: <span class="id">type</span>) (<span class="id">tv</span>: <span class="id">unit</span>) := <span class="id">True</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">Clight.program</span>) (<span class="id">tp</span>: <span class="id">Csharpminor.program</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">match_program_gen</span> <span class="id">match_fundef</span> <span class="id">match_varinfo</span> <span class="id">p</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transl_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4472')">Proof.</div>
<div class="proofscript" id="proof4472">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_program</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_transform_partial_program2</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">H</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">f</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
+ <span class="id">monadInv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">destruct</span> (<span class="id">signature_eq</span> (<span class="id">ef_sig</span> <span class="id">e</span>) (<span class="id">signature_of_type</span> <span class="id">t</span> <span class="id">t0</span> <span class="id">c</span>)); <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Properties of operations over types </h1>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_params_types</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">params</span>,<br/>
&nbsp;&nbsp;<span class="id">map</span> <span class="id">typ_of_type</span> (<span class="id">map</span> <span class="id">snd</span> <span class="id">params</span>) = <span class="id">typlist_of_typelist</span> (<span class="id">type_of_params</span> <span class="id">params</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4473')">Proof.</div>
<div class="proofscript" id="proof4473">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">params</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]; <span class="tactic">simpl</span>. <span class="tactic">f_equal</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_fundef_sig1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>,<br/>
&nbsp;&nbsp;<span class="id">match_fundef</span> <span class="id">ce</span> <span class="id">f</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">classify_fun</span> (<span class="id">type_of_fundef</span> <span class="id">f</span>) = <span class="id">fun_case_f</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">funsig</span> <span class="id">tf</span> = <span class="id">signature_of_type</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4474')">Proof.</div>
<div class="proofscript" id="proof4474">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H1</span>. <span class="tactic">simpl</span>. <span class="tactic">inversion</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">signature_of_function</span>, <span class="id">signature_of_type</span>.<br/>
&nbsp;&nbsp;<span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="id">transl_params_types</span>.<br/>
- <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">funsig</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_fundef_sig2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>,<br/>
&nbsp;&nbsp;<span class="id">match_fundef</span> <span class="id">ce</span> <span class="id">f</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">type_of_fundef</span> <span class="id">f</span> = <span class="id">Tfunction</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">funsig</span> <span class="id">tf</span> = <span class="id">signature_of_type</span> <span class="id">args</span> <span class="id">res</span> <span class="id">cc</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4475')">Proof.</div>
<div class="proofscript" id="proof4475">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">transl_fundef_sig1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_sizeof</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">cunit</span> <span class="id">prog</span>: <span class="id">Clight.program</span>) <span class="id">t</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sizeof</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span> = <span class="id">OK</span> <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sz</span> = <span class="id">Ctypes.sizeof</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4476')">Proof.</div>
<div class="proofscript" id="proof4476">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sizeof</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">complete_type</span> (<span class="id">prog_comp_env</span> <span class="id">cunit</span>) <span class="id">t</span>) <span class="id">eqn</span>:<span class="id">C</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">Ctypes.sizeof_stable</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_alignof</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">cunit</span> <span class="id">prog</span>: <span class="id">Clight.program</span>) <span class="id">t</span> <span class="id">al</span>,<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">alignof</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span> = <span class="id">OK</span> <span class="id">al</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">al</span> = <span class="id">Ctypes.alignof</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4477')">Proof.</div>
<div class="proofscript" id="proof4477">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">alignof</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">complete_type</span> (<span class="id">prog_comp_env</span> <span class="id">cunit</span>) <span class="id">t</span>) <span class="id">eqn</span>:<span class="id">C</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">Ctypes.alignof_stable</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_alignof_blockcopy</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">cunit</span> <span class="id">prog</span>: <span class="id">Clight.program</span>) <span class="id">t</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sizeof</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span> = <span class="id">OK</span> <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sz</span> = <span class="id">Ctypes.sizeof</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span> /\<br/>
&nbsp;&nbsp;<span class="id">alignof_blockcopy</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span> = <span class="id">alignof_blockcopy</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4478')">Proof.</div>
<div class="proofscript" id="proof4478">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sizeof</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> (<span class="id">complete_type</span> (<span class="id">prog_comp_env</span> <span class="id">cunit</span>) <span class="id">t</span>) <span class="id">eqn</span>:<span class="id">C</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
- <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">Ctypes.sizeof_stable</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">revert</span> <span class="id">C</span>. <span class="tactic">induction</span> <span class="id">t</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_comp_env</span> <span class="id">cunit</span>)!<span class="id">i</span> <span class="kwd">as</span> [<span class="id">co</span>|] <span class="id">eqn</span>:<span class="id">X</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">erewrite</span> <span class="id">H1</span> <span class="tactic">by</span> <span class="tactic">eauto</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">field_offset_stable</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">cunit</span> <span class="id">prog</span>: <span class="id">Clight.program</span>) <span class="id">id</span> <span class="id">co</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cunit</span>.(<span class="id">prog_comp_env</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">co</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">prog</span>.(<span class="id">prog_comp_env</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">co</span> /\<br/>
&nbsp;&nbsp;<span class="id">field_offset</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> (<span class="id">co_members</span> <span class="id">co</span>) = <span class="id">field_offset</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> (<span class="id">co_members</span> <span class="id">co</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4479')">Proof.</div>
<div class="proofscript" id="proof4479">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">C</span>: <span class="id">composite_consistent</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">co</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">build_composite_env_consistent</span> <span class="kwd">with</span> <span class="id">cunit</span>.(<span class="id">prog_types</span>) <span class="id">id</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">prog_comp_env_eq</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">_</span> <span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">generalize</span> (<span class="id">co_consistent_complete</span> <span class="id">_</span> <span class="id">_</span> <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">field_offset</span>. <span class="tactic">generalize</span> 0. <span class="tactic">induction</span> (<span class="id">co_members</span> <span class="id">co</span>) <span class="kwd">as</span> [ | [<span class="id">f1</span> <span class="id">t1</span>] <span class="id">m</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">InvBooleans</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! (<span class="id">alignof_stable</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>) <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! (<span class="id">sizeof_stable</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>) <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">f</span> <span class="id">f1</span>); <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Properties of the translation functions </h1>
<br/>
<div class="doc">Transformation of expressions and statements. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_lvalue</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">loc</span> <span class="id">ofs</span> <span class="id">ce</span> <span class="id">ta</span>,<br/>
&nbsp;&nbsp;<span class="id">Clight.eval_lvalue</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">loc</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_expr</span> <span class="id">ce</span> <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">tb</span>, <span class="id">transl_lvalue</span> <span class="id">ce</span> <span class="id">a</span> = <span class="id">OK</span> <span class="id">tb</span> /\ <span class="id">make_load</span> <span class="id">tb</span> (<span class="id">typeof</span> <span class="id">a</span>) = <span class="id">OK</span> <span class="id">ta</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4480')">Proof.</div>
<div class="proofscript" id="proof4480">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ta</span>; <span class="tactic">intros</span> <span class="id">EVAL</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">EVAL</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>.<br/>
&nbsp;var&nbsp;local&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Eaddrof</span> <span class="id">id</span>); <span class="tactic">auto</span>.<br/>
&nbsp;var&nbsp;global&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Eaddrof</span> <span class="id">id</span>); <span class="tactic">auto</span>.<br/>
&nbsp;deref&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">exists</span> <span class="id">x</span>; <span class="tactic">auto</span>.<br/>
&nbsp;field&nbsp;struct&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">exists</span> <span class="id">x0</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;field&nbsp;union&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">exists</span> <span class="id">x0</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Properties of labeled statements </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_lbl_stmt_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">n</span> <span class="id">sl</span> <span class="id">tsl</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span> = <span class="id">OK</span> <span class="id">tsl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> (<span class="id">Clight.select_switch</span> <span class="id">n</span> <span class="id">sl</span>) = <span class="id">OK</span> (<span class="id">select_switch</span> <span class="id">n</span> <span class="id">tsl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4481')">Proof.</div>
<div class="proofscript" id="proof4481">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DFL</span>: <span class="kwd">forall</span> <span class="id">sl</span> <span class="id">tsl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span> = <span class="id">OK</span> <span class="id">tsl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> (<span class="id">Clight.select_switch_default</span> <span class="id">sl</span>) = <span class="id">OK</span> (<span class="id">select_switch_default</span> <span class="id">tsl</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CASE</span>: <span class="kwd">forall</span> <span class="id">sl</span> <span class="id">tsl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span> = <span class="id">OK</span> <span class="id">tsl</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Clight.select_switch_case</span> <span class="id">n</span> <span class="id">sl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">tsl</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">sl</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tsl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">select_switch_case</span> <span class="id">n</span> <span class="id">tsl</span> = <span class="id">Some</span> <span class="id">tsl</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span>' = <span class="id">OK</span> <span class="id">tsl</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">o</span>. <span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">z</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">EQ1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHsl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHsl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">specialize</span> (<span class="id">CASE</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>). <span class="tactic">unfold</span> <span class="id">Clight.select_switch</span>, <span class="id">select_switch</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Clight.select_switch_case</span> <span class="id">n</span> <span class="id">sl</span>) <span class="kwd">as</span> [<span class="id">sl</span>'|].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">CASE</span> <span class="kwd">as</span> [<span class="id">tsl</span>' [<span class="id">P</span> <span class="id">Q</span>]]. <span class="tactic">rewrite</span> <span class="id">P</span>, <span class="id">Q</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">CASE</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_lbl_stmt_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span> <span class="id">tsl</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">sl</span> = <span class="id">OK</span> <span class="id">tsl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">sl</span>) = <span class="id">OK</span> (<span class="id">seq_of_lbl_stmt</span> <span class="id">tsl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4482')">Proof.</div>
<div class="proofscript" id="proof4482">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> (<span class="id">IHsl</span> <span class="id">_</span> <span class="id">EQ1</span>). <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of Csharpminor construction functions </h1>
<br/>
<span class="kwd">Section</span> <span class="id">CONSTRUCTORS</span>.<br/>
<br/>
<span class="kwd">Variables</span> <span class="id">cunit</span> <span class="id">prog</span>: <span class="id">Clight.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ge</span>: <span class="id">genv</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_intconst_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_intconst</span> <span class="id">n</span>) (<span class="id">Vint</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4483')">Proof.</div>
<div class="proofscript" id="proof4483">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_intconst</span>. <span class="id">econstructor</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_floatconst_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_floatconst</span> <span class="id">n</span>) (<span class="id">Vfloat</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4484')">Proof.</div>
<div class="proofscript" id="proof4484">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_floatconst</span>. <span class="id">econstructor</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_singleconst_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_singleconst</span> <span class="id">n</span>) (<span class="id">Vsingle</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4485')">Proof.</div>
<div class="proofscript" id="proof4485">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_singleconst</span>. <span class="id">econstructor</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_longconst_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_longconst</span> <span class="id">n</span>) (<span class="id">Vlong</span> <span class="id">n</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4486')">Proof.</div>
<div class="proofscript" id="proof4486">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_floatconst</span>. <span class="id">econstructor</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_ptrofsconst_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_ptrofsconst</span> <span class="id">n</span>) (<span class="id">Vptrofs</span> (<span class="id">Ptrofs.repr</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4487')">Proof.</div>
<div class="proofscript" id="proof4487">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Vptrofs</span>, <span class="id">make_ptrofsconst</span>. <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>.<br/>
- <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int64</span> (<span class="id">Ptrofs.repr</span> <span class="id">n</span>)) <span class="kwd">with</span> (<span class="id">Int64.repr</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_longconst_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int</span> (<span class="id">Ptrofs.repr</span> <span class="id">n</span>)) <span class="kwd">with</span> (<span class="id">Int.repr</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_intconst_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_singleoffloat_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vfloat</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_singleoffloat</span> <span class="id">a</span>) (<span class="id">Vsingle</span> (<span class="id">Float.to_single</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4488')">Proof.</div>
<div class="proofscript" id="proof4488">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_floatofsingle_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">n</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vsingle</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_floatofsingle</span> <span class="id">a</span>) (<span class="id">Vfloat</span> (<span class="id">Float.of_single</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4489')">Proof.</div>
<div class="proofscript" id="proof4489">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_floatofint_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">n</span> <span class="id">sg</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vint</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_floatofint</span> <span class="id">a</span> <span class="id">sg</span>) (<span class="id">Vfloat</span>(<span class="id">cast_int_float</span> <span class="id">sg</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4490')">Proof.</div>
<div class="proofscript" id="proof4490">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_floatofint</span>, <span class="id">cast_int_float</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sg</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">make_intconst_correct</span> <span class="id">make_floatconst_correct</span> <span class="id">make_longconst_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">make_singleconst_correct</span> <span class="id">make_singleoffloat_correct</span> <span class="id">make_floatofsingle_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">make_floatofint_correct</span>: <span class="id">cshm</span>.<br/>
<span class="kwd">Hint</span> <span class="id">Constructors</span> <span class="id">eval_expr</span> <span class="id">eval_exprlist</span>: <span class="id">cshm</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 2 (@<span class="id">eq</span> <span class="id">trace</span> <span class="id">_</span> <span class="id">_</span>) =&gt; <span class="id">traceEq</span>: <span class="id">cshm</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cmpu_ne_zero_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vint</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_cmpu_ne_zero</span> <span class="id">a</span>) (<span class="id">Vint</span> (<span class="kwd">if</span> <span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span> <span class="kwd">then</span> <span class="id">Int.zero</span> <span class="kwd">else</span> <span class="id">Int.one</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4491')">Proof.</div>
<div class="proofscript" id="proof4491">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DEFAULT</span>: <span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">Ebinop</span> (<span class="id">Ocmpu</span> <span class="id">Cne</span>) <span class="id">a</span> (<span class="id">make_intconst</span> <span class="id">Int.zero</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Vint</span> (<span class="kwd">if</span> <span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span> <span class="kwd">then</span> <span class="id">Int.zero</span> <span class="kwd">else</span> <span class="id">Int.one</span>))).<br/>
&nbsp;&nbsp;{ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpu</span>, <span class="id">Val.cmpu_bool</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int.cmpu</span>. <span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span>); <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">CMP</span>: <span class="kwd">forall</span> <span class="id">ob</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.of_optbool</span> <span class="id">ob</span> = <span class="id">Vint</span> <span class="id">n</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span> = (<span class="kwd">if</span> <span class="id">Int.eq</span> <span class="id">n</span> <span class="id">Int.zero</span> <span class="kwd">then</span> <span class="id">Int.zero</span> <span class="kwd">else</span> <span class="id">Int.one</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ob</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_false</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Int.one_not_zero</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">Val.cmp_bool</span>) <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H6</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">Val.cmpu_bool</span>) <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H6</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">Val.cmpf_bool</span>) <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H6</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">destruct</span> (<span class="id">Val.cmpfs_bool</span>) <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H6</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpl</span> <span class="kwd">in</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Val.cmpl_bool</span> <span class="id">c</span> <span class="id">v1</span> <span class="id">v2</span>) <span class="kwd">as</span> [[]|]; <span class="id">inv</span> <span class="id">H6</span>; <span class="tactic">reflexivity</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>. <span class="id">decEq</span>. <span class="id">decEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span> <span class="kwd">in</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Val.cmplu_bool</span> (<span class="id">Mem.valid_pointer</span> <span class="id">m</span>) <span class="id">c</span> <span class="id">v1</span> <span class="id">v2</span>) <span class="kwd">as</span> [[]|]; <span class="id">inv</span> <span class="id">H6</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cmpu_ne_zero_correct_ptr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Archi.ptr64</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.weak_valid_pointer</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">i</span>) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_cmpu_ne_zero</span> <span class="id">a</span>) <span class="id">Vone</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4492')">Proof.</div>
<div class="proofscript" id="proof4492">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DEFAULT</span>: <span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">Ebinop</span> (<span class="id">Ocmpu</span> <span class="id">Cne</span>) <span class="id">a</span> (<span class="id">make_intconst</span> <span class="id">Int.zero</span>)) <span class="id">Vone</span>).<br/>
&nbsp;&nbsp;{ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpu</span>, <span class="id">Val.cmpu_bool</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.weak_valid_pointer</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>, <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Int.eq_true</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">OF_OPTBOOL</span>: <span class="kwd">forall</span> <span class="id">ob</span>, <span class="id">Some</span> (<span class="id">Val.of_optbool</span> <span class="id">ob</span>) &lt;&gt; <span class="id">Some</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ob</span> <span class="kwd">as</span> [[]|]; <span class="tactic">discriminate</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">OF_BOOL</span>: <span class="kwd">forall</span> <span class="id">ob</span>, <span class="id">option_map</span> <span class="id">Val.of_bool</span> <span class="id">ob</span> &lt;&gt; <span class="id">Some</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ob</span> <span class="kwd">as</span> [[]|]; <span class="tactic">discriminate</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">b0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="kwd">Ltac</span> <span class="id">OMelim</span>:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">H</span>: <span class="id">option_map</span> <span class="id">_</span> ?<span class="id">x</span> = <span class="id">_</span> |- <span class="id">_</span> =&gt; <span class="tactic">destruct</span> <span class="id">x</span> <span class="id">eqn</span>:?; <span class="id">inv</span> <span class="id">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_OPTBOOL</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H8</span>. <span class="id">instantiate</span> (1:= <span class="id">Some</span> <span class="id">false</span>). <span class="id">OMelim</span>. <span class="tactic">destruct</span> <span class="id">b0</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_OPTBOOL</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H8</span>. <span class="id">instantiate</span> (1:= <span class="id">Some</span> <span class="id">false</span>). <span class="id">OMelim</span>. <span class="tactic">destruct</span> <span class="id">b0</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_OPTBOOL</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H8</span>. <span class="id">instantiate</span> (1:= <span class="id">Some</span> <span class="id">false</span>). <span class="id">OMelim</span>. <span class="tactic">destruct</span> <span class="id">b0</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_OPTBOOL</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H8</span>. <span class="id">instantiate</span> (1:= <span class="id">Some</span> <span class="id">false</span>). <span class="id">OMelim</span>. <span class="tactic">destruct</span> <span class="id">b0</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_BOOL</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">inv</span> <span class="id">H</span>; <span class="id">eelim</span> <span class="id">OF_BOOL</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cast_int_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">n</span> <span class="id">sz</span> <span class="id">si</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vint</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_cast_int</span> <span class="id">a</span> <span class="id">sz</span> <span class="id">si</span>) (<span class="id">Vint</span> (<span class="id">cast_int_int</span> <span class="id">sz</span> <span class="id">si</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4493')">Proof.</div>
<div class="proofscript" id="proof4493">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_cast_int</span>, <span class="id">cast_int_int</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sz</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_cmpu_ne_zero_correct</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_longofint_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">n</span> <span class="id">si</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vint</span> <span class="id">n</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_longofint</span> <span class="id">a</span> <span class="id">si</span>) (<span class="id">Vlong</span> (<span class="id">cast_int_long</span> <span class="id">si</span> <span class="id">n</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4494')">Proof.</div>
<div class="proofscript" id="proof4494">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_longofint</span>, <span class="id">cast_int_long</span>. <span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">make_cast_int_correct</span> <span class="id">make_longofint_correct</span>: <span class="id">cshm</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">InvEval</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id">None</span> = <span class="id">Some</span> <span class="id">_</span> |- <span class="id">_</span> ] =&gt; <span class="tactic">discriminate</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="id">Some</span> <span class="id">_</span> = <span class="id">Some</span> <span class="id">_</span> |- <span class="id">_</span> ] =&gt; <span class="id">inv</span> <span class="id">H</span>; <span class="id">InvEval</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="kwd">match</span> ?<span class="id">x</span> <span class="kwd">with</span> <span class="id">Some</span> <span class="id">_</span> =&gt; <span class="id">_</span> | <span class="id">None</span> =&gt; <span class="id">_</span> <span class="kwd">end</span> = <span class="id">Some</span> <span class="id">_</span> |- <span class="id">_</span> ] =&gt; <span class="tactic">destruct</span> <span class="id">x</span> <span class="id">eqn</span>:?; <span class="id">InvEval</span><br/>
&nbsp;&nbsp;| [ <span class="id">H</span>: <span class="kwd">match</span> ?<span class="id">x</span> <span class="kwd">with</span> <span class="id">true</span> =&gt; <span class="id">_</span> | <span class="id">false</span> =&gt; <span class="id">_</span> <span class="kwd">end</span> = <span class="id">Some</span> <span class="id">_</span> |- <span class="id">_</span> ] =&gt; <span class="tactic">destruct</span> <span class="id">x</span> <span class="id">eqn</span>:?; <span class="id">InvEval</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cast_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">v</span> <span class="id">ty1</span> <span class="id">ty2</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">make_cast</span> <span class="id">ty1</span> <span class="id">ty2</span> <span class="id">a</span> = <span class="id">OK</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_cast</span> <span class="id">v</span> <span class="id">ty1</span> <span class="id">ty2</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">v</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4495')">Proof.</div>
<div class="proofscript" id="proof4495">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_cast</span>, <span class="id">sem_cast</span> <span class="kwd">in</span> *;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_cast</span> <span class="id">ty1</span> <span class="id">ty2</span>); <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">destruct</span> <span class="id">v</span>; <span class="id">InvEval</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
- <span class="comment">(*&nbsp;single&nbsp;-&gt;&nbsp;int&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_singleofint</span>, <span class="id">cast_int_float</span>. <span class="tactic">destruct</span> <span class="id">si1</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
- <span class="comment">(*&nbsp;float&nbsp;-&gt;&nbsp;int&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_cast_int_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cast_float_int</span> <span class="kwd">in</span> <span class="id">Heqo</span>. <span class="tactic">unfold</span> <span class="id">make_intoffloat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">Heqo</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;single&nbsp;-&gt;&nbsp;int&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_cast_int_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cast_single_int</span> <span class="kwd">in</span> <span class="id">Heqo</span>. <span class="tactic">unfold</span> <span class="id">make_intofsingle</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">Heqo</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;long&nbsp;-&gt;&nbsp;float&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_floatoflong</span>, <span class="id">cast_long_float</span>. <span class="tactic">destruct</span> <span class="id">si1</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
- <span class="comment">(*&nbsp;long&nbsp;-&gt;&nbsp;single&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_singleoflong</span>, <span class="id">cast_long_single</span>. <span class="tactic">destruct</span> <span class="id">si1</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
- <span class="comment">(*&nbsp;float&nbsp;-&gt;&nbsp;long&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cast_float_long</span> <span class="kwd">in</span> <span class="id">Heqo</span>. <span class="tactic">unfold</span> <span class="id">make_longoffloat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">Heqo</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;single&nbsp;-&gt;&nbsp;long&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cast_single_long</span> <span class="kwd">in</span> <span class="id">Heqo</span>. <span class="tactic">unfold</span> <span class="id">make_longofsingle</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">si2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">Heqo</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;int&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_cmpu_ne_zero_correct</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;pointer&nbsp;(32&nbsp;bits)&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmpu_ne_zero_correct_ptr</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;long&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>, <span class="id">Val.cmplu_bool</span>, <span class="id">Int64.cmpu</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i</span> <span class="id">Int64.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;pointer&nbsp;(64&nbsp;bits)&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>, <span class="id">Val.cmplu_bool</span>. <span class="tactic">unfold</span> <span class="id">Mem.weak_valid_pointer</span> <span class="kwd">in</span> <span class="id">Heqb1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heqb0</span>, <span class="id">Heqb1</span>. <span class="tactic">rewrite</span> <span class="id">Int64.eq_true</span>. <span class="tactic">reflexivity</span>.<br/>
- <span class="comment">(*&nbsp;float&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpf</span>, <span class="id">Val.cmpf_bool</span>. <span class="tactic">rewrite</span> <span class="id">Float.cmp_ne_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float.cmp</span> <span class="id">Ceq</span> <span class="id">f</span> <span class="id">Float.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;single&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpfs</span>, <span class="id">Val.cmpfs_bool</span>. <span class="tactic">rewrite</span> <span class="id">Float32.cmp_ne_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float32.cmp</span> <span class="id">Ceq</span> <span class="id">f</span> <span class="id">Float32.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;struct&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id1</span> <span class="id">id2</span>); <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;union&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">id1</span> <span class="id">id2</span>); <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_boolean_correct</span>:<br/>
&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> <span class="id">ty</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bool_val</span> <span class="id">v</span> <span class="id">ty</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vb</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_boolean</span> <span class="id">a</span> <span class="id">ty</span>) <span class="id">vb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.bool_of_val</span> <span class="id">vb</span> <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4496')">Proof.</div>
<div class="proofscript" id="proof4496">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">make_boolean</span>. <span class="tactic">unfold</span> <span class="id">bool_val</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_bool</span> <span class="id">ty</span>); <span class="tactic">destruct</span> <span class="id">v</span>; <span class="id">InvEval</span>.<br/>
- <span class="comment">(*&nbsp;int&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">make_cmpu_ne_zero_correct</span> <span class="kwd">with</span> (<span class="id">n</span> := <span class="id">i</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i</span> <span class="id">Int.zero</span>); <span class="tactic">simpl</span>; <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;ptr&nbsp;32&nbsp;bits&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">Vone</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">make_cmpu_ne_zero_correct_ptr</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;long&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i</span> <span class="id">Int64.zero</span>); <span class="tactic">simpl</span>; <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;ptr&nbsp;64&nbsp;bits&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">Vone</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>, <span class="id">Val.cmplu_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.weak_valid_pointer</span> <span class="kwd">in</span> <span class="id">Heqb0</span>. <span class="tactic">rewrite</span> <span class="id">Heqb0</span>, <span class="id">Heqb1</span>, <span class="id">Int64.eq_true</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;float&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpf</span>, <span class="id">Val.cmpf_bool</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">Float.cmp_ne_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float.cmp</span> <span class="id">Cne</span> <span class="id">f</span> <span class="id">Float.zero</span>); <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;single&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpfs</span>, <span class="id">Val.cmpfs_bool</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">Float32.cmp_ne_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float32.cmp</span> <span class="id">Cne</span> <span class="id">f</span> <span class="id">Float32.zero</span>); <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_neg_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem_neg</span> <span class="id">va</span> <span class="id">tya</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make_neg</span> <span class="id">a</span> <span class="id">tya</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4497')">Proof.</div>
<div class="proofscript" id="proof4497">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_neg</span>, <span class="id">make_neg</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_neg</span> <span class="id">tya</span>); <span class="id">inv</span> <span class="id">MAKE</span>; <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_absfloat_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem_absfloat</span> <span class="id">va</span> <span class="id">tya</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make_absfloat</span> <span class="id">a</span> <span class="id">tya</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4498')">Proof.</div>
<div class="proofscript" id="proof4498">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_absfloat</span>, <span class="id">make_absfloat</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_neg</span> <span class="id">tya</span>); <span class="id">inv</span> <span class="id">MAKE</span>; <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_floatoflong</span>, <span class="id">cast_long_float</span>. <span class="tactic">destruct</span> <span class="id">s</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">econstructor</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_notbool_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem_notbool</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make_notbool</span> <span class="id">a</span> <span class="id">tya</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4499')">Proof.</div>
<div class="proofscript" id="proof4499">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_notbool</span>, <span class="id">bool_val</span>, <span class="id">make_notbool</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_bool</span> <span class="id">tya</span>); <span class="id">inv</span> <span class="id">MAKE</span>; <span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">SEM</span>; <span class="id">InvEval</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpu</span>, <span class="id">Val.cmpu_bool</span>, <span class="id">Int.cmpu</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i</span> <span class="id">Int.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.weak_valid_pointer</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">i</span>)) <span class="id">eqn</span>:<span class="id">V</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpu</span>, <span class="id">Val.cmpu_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.weak_valid_pointer</span> <span class="kwd">in</span> <span class="id">V</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>, <span class="id">V</span>, <span class="id">Int.eq_true</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>, <span class="id">Val.cmplu_bool</span>, <span class="id">Int64.cmpu</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i</span> <span class="id">Int64.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.weak_valid_pointer</span> <span class="id">m</span> <span class="id">b</span> (<span class="id">Ptrofs.unsigned</span> <span class="id">i</span>)) <span class="id">eqn</span>:<span class="id">V</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmplu</span>, <span class="id">Val.cmplu_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.weak_valid_pointer</span> <span class="kwd">in</span> <span class="id">V</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>, <span class="id">V</span>, <span class="id">Int64.eq_true</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpf</span>, <span class="id">Val.cmpf_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float.cmp</span> <span class="id">Ceq</span> <span class="id">f</span> <span class="id">Float.zero</span>); <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Val.cmpfs</span>, <span class="id">Val.cmpfs_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Float32.cmp</span> <span class="id">Ceq</span> <span class="id">f</span> <span class="id">Float32.zero</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_notint_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem_notint</span> <span class="id">va</span> <span class="id">tya</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make_notint</span> <span class="id">a</span> <span class="id">tya</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4500')">Proof.</div>
<div class="proofscript" id="proof4500">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sem_notint</span>, <span class="id">make_notint</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_notint</span> <span class="id">tya</span>); <span class="id">inv</span> <span class="id">MAKE</span>; <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">binary_constructor_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">make</span>: <span class="id">expr</span> -&gt; <span class="id">type</span> -&gt; <span class="id">expr</span> -&gt; <span class="id">type</span> -&gt; <span class="id">res</span> <span class="id">expr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sem</span>: <span class="id">val</span> -&gt; <span class="id">type</span> -&gt; <span class="id">val</span> -&gt; <span class="id">type</span> -&gt; <span class="id">mem</span> -&gt; <span class="id">option</span> <span class="id">val</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> <span class="id">c</span> <span class="id">va</span> <span class="id">vb</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">vb</span> <span class="id">tyb</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">shift_constructor_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">make</span>: <span class="id">expr</span> -&gt; <span class="id">type</span> -&gt; <span class="id">expr</span> -&gt; <span class="id">type</span> -&gt; <span class="id">res</span> <span class="id">expr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sem</span>: <span class="id">val</span> -&gt; <span class="id">type</span> -&gt; <span class="id">val</span> -&gt; <span class="id">type</span> -&gt; <span class="id">option</span> <span class="id">val</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> <span class="id">c</span> <span class="id">va</span> <span class="id">vb</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">sem</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">vb</span> <span class="id">tyb</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">MAKE_BIN</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">sem_int</span>: <span class="id">signedness</span> -&gt; <span class="id">int</span> -&gt; <span class="id">int</span> -&gt; <span class="id">option</span> <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sem_long</span>: <span class="id">signedness</span> -&gt; <span class="id">int64</span> -&gt; <span class="id">int64</span> -&gt; <span class="id">option</span> <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sem_float</span>: <span class="id">float</span> -&gt; <span class="id">float</span> -&gt; <span class="id">option</span> <span class="id">val</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sem_single</span>: <span class="id">float32</span> -&gt; <span class="id">float32</span> -&gt; <span class="id">option</span> <span class="id">val</span>.<br/>
<span class="kwd">Variables</span> <span class="id">iop</span> <span class="id">iopu</span> <span class="id">fop</span> <span class="id">sop</span> <span class="id">lop</span> <span class="id">lopu</span>: <span class="id">binary_operation</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">iop_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">iop</span> (<span class="id">Vint</span> <span class="id">x</span>) (<span class="id">Vint</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_int</span> <span class="id">Signed</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">iopu_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">iopu</span> (<span class="id">Vint</span> <span class="id">x</span>) (<span class="id">Vint</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_int</span> <span class="id">Unsigned</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">lop_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">lop</span> (<span class="id">Vlong</span> <span class="id">x</span>) (<span class="id">Vlong</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_long</span> <span class="id">Signed</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">lopu_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">lopu</span> (<span class="id">Vlong</span> <span class="id">x</span>) (<span class="id">Vlong</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_long</span> <span class="id">Unsigned</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">fop_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">fop</span> (<span class="id">Vfloat</span> <span class="id">x</span>) (<span class="id">Vfloat</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_float</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">sop_ok</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">y</span> <span class="id">m</span>, <span class="id">eval_binop</span> <span class="id">sop</span> (<span class="id">Vsingle</span> <span class="id">x</span>) (<span class="id">Vsingle</span> <span class="id">y</span>) <span class="id">m</span> = <span class="id">sem_single</span> <span class="id">x</span> <span class="id">y</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_binarith_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">binary_constructor_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">make_binarith</span> <span class="id">iop</span> <span class="id">iopu</span> <span class="id">fop</span> <span class="id">sop</span> <span class="id">lop</span> <span class="id">lopu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sem_binarith</span> <span class="id">sem_int</span> <span class="id">sem_long</span> <span class="id">sem_float</span> <span class="id">sem_single</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4501')">Proof.</div>
<div class="proofscript" id="proof4501">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_binarith</span>, <span class="id">sem_binarith</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">cls</span> := <span class="id">classify_binarith</span> <span class="id">tya</span> <span class="id">tyb</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ty</span> := <span class="id">binarith_type</span> <span class="id">cls</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">MAKE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">sem_cast</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">ty</span> <span class="id">m</span>) <span class="kwd">as</span> [<span class="id">va</span>'|] <span class="id">eqn</span>:<span class="id">Ca</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">sem_cast</span> <span class="id">vb</span> <span class="id">tyb</span> <span class="id">ty</span> <span class="id">m</span>) <span class="kwd">as</span> [<span class="id">vb</span>'|] <span class="id">eqn</span>:<span class="id">Cb</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_cast_correct</span>. <span class="id">eexact</span> <span class="id">EQ</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EV1</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_cast_correct</span>. <span class="id">eexact</span> <span class="id">EQ1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EV2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cls</span>; <span class="id">inv</span> <span class="id">EQ2</span>; <span class="tactic">destruct</span> <span class="id">va</span>'; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> <span class="id">vb</span>'; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">iop_ok</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">iopu_ok</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">lop_ok</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">lopu_ok</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">erewrite</span> &lt;- <span class="id">fop_ok</span> <span class="kwd">in</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
- <span class="id">erewrite</span> &lt;- <span class="id">sop_ok</span> <span class="kwd">in</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_binarith_int_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">binary_constructor_correct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">make_binarith_int</span> <span class="id">iop</span> <span class="id">iopu</span> <span class="id">lop</span> <span class="id">lopu</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sem_binarith</span> <span class="id">sem_int</span> <span class="id">sem_long</span> (<span class="kwd">fun</span> <span class="id">x</span> <span class="id">y</span> =&gt; <span class="id">None</span>) (<span class="kwd">fun</span> <span class="id">x</span> <span class="id">y</span> =&gt; <span class="id">None</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4502')">Proof.</div>
<div class="proofscript" id="proof4502">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_binarith_int</span>, <span class="id">sem_binarith</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">cls</span> := <span class="id">classify_binarith</span> <span class="id">tya</span> <span class="id">tyb</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ty</span> := <span class="id">binarith_type</span> <span class="id">cls</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">MAKE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">sem_cast</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">ty</span> <span class="id">m</span>) <span class="kwd">as</span> [<span class="id">va</span>'|] <span class="id">eqn</span>:<span class="id">Ca</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">sem_cast</span> <span class="id">vb</span> <span class="id">tyb</span> <span class="id">ty</span> <span class="id">m</span>) <span class="kwd">as</span> [<span class="id">vb</span>'|] <span class="id">eqn</span>:<span class="id">Cb</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_cast_correct</span>. <span class="id">eexact</span> <span class="id">EQ</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EV1</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_cast_correct</span>. <span class="id">eexact</span> <span class="id">EQ1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EV2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cls</span>; <span class="id">inv</span> <span class="id">EQ2</span>; <span class="tactic">destruct</span> <span class="id">va</span>'; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> <span class="id">vb</span>'; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">iop_ok</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">iopu_ok</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">lop_ok</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">lopu_ok</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">MAKE_BIN</span>.<br/>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Extern</span> 2 (@<span class="id">eq</span> (<span class="id">option</span> <span class="id">val</span>) <span class="id">_</span> <span class="id">_</span>) =&gt; (<span class="tactic">simpl</span>; <span class="tactic">reflexivity</span>) : <span class="id">cshm</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_add_correct</span>: <span class="id">binary_constructor_correct</span> (<span class="id">make_add</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>)) (<span class="id">sem_add</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4503')">Proof.</div>
<div class="proofscript" id="proof4503">
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="kwd">forall</span> <span class="id">ty</span> <span class="id">si</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">va</span> <span class="id">vb</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">make_add_ptr_int</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">ty</span> <span class="id">si</span> <span class="id">a</span> <span class="id">b</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt; <span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem_add_ptr_int</span> (<span class="id">prog_comp_env</span> <span class="id">prog</span>) <span class="id">ty</span> <span class="id">si</span> <span class="id">va</span> <span class="id">vb</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">make_add_ptr_int</span>, <span class="id">sem_add_ptr_int</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">v</span>; <span class="tactic">intros</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span> <span class="id">SEM</span>; <span class="id">monadInv</span> <span class="id">MAKE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">EQ0</span>; <span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;+ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree64</span> (<span class="id">ptrofs_of_int</span> <span class="id">si</span> <span class="id">i0</span>) (<span class="id">cast_int_long</span> <span class="id">si</span> <span class="id">i0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">Ptrofs.agree64_repr</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;+ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree32</span> (<span class="id">ptrofs_of_int</span> <span class="id">si</span> <span class="id">i0</span>) <span class="id">i0</span>) <span class="tactic">by</span> (<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">B</span>: <span class="kwd">forall</span> <span class="id">ty</span> <span class="id">a</span> <span class="id">b</span> <span class="id">c</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">va</span> <span class="id">vb</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">make_add_ptr_long</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">ty</span> <span class="id">a</span> <span class="id">b</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt; <span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sem_add_ptr_long</span> (<span class="id">prog_comp_env</span> <span class="id">prog</span>) <span class="id">ty</span> <span class="id">va</span> <span class="id">vb</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">make_add_ptr_long</span>, <span class="id">sem_add_ptr_long</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">v</span>; <span class="tactic">intros</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span> <span class="id">SEM</span>; <span class="id">monadInv</span> <span class="id">MAKE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">EQ0</span>; <span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>).<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;+ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;+ <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree32</span> (<span class="id">Ptrofs.of_int64</span> <span class="id">i0</span>) (<span class="id">Int64.loword</span> <span class="id">i0</span>)) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Ptrofs.agree32_repr</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_add</span>, <span class="id">sem_add</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_add</span> <span class="id">tya</span> <span class="id">tyb</span>); <span class="tactic">eauto</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">make_binarith_correct</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_sub_correct</span>: <span class="id">binary_constructor_correct</span> (<span class="id">make_sub</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>)) (<span class="id">sem_sub</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4504')">Proof.</div>
<div class="proofscript" id="proof4504">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_sub</span>, <span class="id">sem_sub</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_sub</span> <span class="id">tya</span> <span class="id">tyb</span>); <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">MAKE</span>).<br/>
- <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">EQ0</span>; <span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>).<br/>
+ <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree64</span> (<span class="id">ptrofs_of_int</span> <span class="id">si</span> <span class="id">i0</span>) (<span class="id">cast_int_long</span> <span class="id">si</span> <span class="id">i0</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">Ptrofs.agree64_repr</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree32</span> (<span class="id">ptrofs_of_int</span> <span class="id">si</span> <span class="id">i0</span>) <span class="id">i0</span>) <span class="tactic">by</span> (<span class="tactic">destruct</span> <span class="id">si</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>) <span class="kwd">in</span> <span class="id">EQ0</span>. <span class="tactic">clear</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">sz</span> := <span class="id">Ctypes.sizeof</span> (<span class="id">prog_comp_env</span> <span class="id">prog</span>) <span class="id">ty</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">InvEval</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b0</span> <span class="id">b1</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> 0 <span class="id">sz</span>); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> <span class="id">sz</span> <span class="id">Ptrofs.max_signed</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">SEM</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">E1</span>: <span class="id">Ptrofs.signed</span> (<span class="id">Ptrofs.repr</span> <span class="id">sz</span>) = <span class="id">sz</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Ptrofs.signed_repr</span>. <span class="tactic">generalize</span> <span class="id">Ptrofs.min_signed_neg</span>; <span class="tactic">omega</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="tactic">inversion</span> <span class="id">EQ0</span>; <span class="tactic">clear</span> <span class="id">EQ0</span>; <span class="tactic">subst</span> <span class="id">c</span>.<br/>
+ <span class="tactic">assert</span> (<span class="id">E</span>: <span class="id">Int64.signed</span> (<span class="id">Int64.repr</span> <span class="id">sz</span>) = <span class="id">sz</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Int64.signed_repr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">Int64.max_signed</span> <span class="kwd">with</span> <span class="id">Ptrofs.max_signed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Int64.min_signed_neg</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Ptrofs.max_signed</span>, <span class="id">Ptrofs.half_modulus</span>; <span class="tactic">rewrite</span> <span class="id">Ptrofs.modulus_eq64</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">SF</span>, <span class="id">dec_eq_true</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">predSpec</span> <span class="id">Int64.eq</span> <span class="id">Int64.eq_spec</span> (<span class="id">Int64.repr</span> <span class="id">sz</span>) <span class="id">Int64.zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="tactic">rewrite</span> <span class="id">Int64.signed_zero</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">predSpec</span> <span class="id">Int64.eq</span> <span class="id">Int64.eq_spec</span> (<span class="id">Int64.repr</span> <span class="id">sz</span>) <span class="id">Int64.mone</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="tactic">rewrite</span> <span class="id">Int64.signed_mone</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">andb_false_r</span>; <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Vptrofs</span>; <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">symmetry</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
+ <span class="tactic">assert</span> (<span class="id">E</span>: <span class="id">Int.signed</span> (<span class="id">Int.repr</span> <span class="id">sz</span>) = <span class="id">sz</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">Int.signed_repr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">Int.max_signed</span> <span class="kwd">with</span> <span class="id">Ptrofs.max_signed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Int.min_signed_neg</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Ptrofs.max_signed</span>, <span class="id">Ptrofs.half_modulus</span>, <span class="id">Ptrofs.modulus</span>, <span class="id">Ptrofs.wordsize</span>, <span class="id">Wordsize_Ptrofs.wordsize</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>, <span class="id">dec_eq_true</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">predSpec</span> <span class="id">Int.eq</span> <span class="id">Int.eq_spec</span> (<span class="id">Int.repr</span> <span class="id">sz</span>) <span class="id">Int.zero</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="tactic">rewrite</span> <span class="id">Int.signed_zero</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">predSpec</span> <span class="id">Int.eq</span> <span class="id">Int.eq_spec</span> (<span class="id">Int.repr</span> <span class="id">sz</span>) <span class="id">Int.mone</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="tactic">rewrite</span> <span class="id">Int.signed_mone</span> <span class="kwd">in</span> <span class="id">E</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">andb_false_r</span>; <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Vptrofs</span>; <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>; <span class="id">inv</span> <span class="id">EQ0</span>; <span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>).<br/>
+ <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">inv</span> <span class="id">SEM</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ptrofs.agree32</span> (<span class="id">Ptrofs.of_int64</span> <span class="id">i0</span>) (<span class="id">Int64.loword</span> <span class="id">i0</span>)) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">Ptrofs.agree32_repr</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">make_binarith_correct</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_mul_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_mul</span> <span class="id">sem_mul</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4505')">Proof.</div>
<div class="proofscript" id="proof4505">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_div_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_div</span> <span class="id">sem_div</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4506')">Proof.</div>
<div class="proofscript" id="proof4506">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_mod_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_mod</span> <span class="id">sem_mod</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4507')">Proof.</div>
<div class="proofscript" id="proof4507">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_int_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_and_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_and</span> <span class="id">sem_and</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4508')">Proof.</div>
<div class="proofscript" id="proof4508">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_int_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_or_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_or</span> <span class="id">sem_or</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4509')">Proof.</div>
<div class="proofscript" id="proof4509">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_int_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_xor_correct</span>: <span class="id">binary_constructor_correct</span> <span class="id">make_xor</span> <span class="id">sem_xor</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4510')">Proof.</div>
<div class="proofscript" id="proof4510">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_binarith_int_correct</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Ltac</span> <span class="id">comput</span> <span class="id">val</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">x</span> := <span class="tactic">fresh</span> <span class="kwd">in</span> <span class="tactic">set</span> <span class="id">val</span> <span class="kwd">as</span> <span class="id">x</span> <span class="kwd">in</span> *; <span class="id">vm_compute</span> <span class="kwd">in</span> <span class="id">x</span>; <span class="tactic">subst</span> <span class="id">x</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">small_shift_amount_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">Int64.ltu</span> <span class="id">i</span> <span class="id">Int64.iwordsize</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Int.ltu</span> (<span class="id">Int64.loword</span> <span class="id">i</span>) <span class="id">Int64.iwordsize</span>' = <span class="id">true</span><br/>
&nbsp;&nbsp;/\ <span class="id">Int64.unsigned</span> <span class="id">i</span> = <span class="id">Int.unsigned</span> (<span class="id">Int64.loword</span> <span class="id">i</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4511')">Proof.</div>
<div class="proofscript" id="proof4511">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Int64.ltu_inv</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">comput</span> (<span class="id">Int64.unsigned</span> <span class="id">Int64.iwordsize</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Int64.unsigned</span> <span class="id">i</span> = <span class="id">Int.unsigned</span> (<span class="id">Int64.loword</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.loword</span>. <span class="tactic">rewrite</span> <span class="id">Int.unsigned_repr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">comput</span> <span class="id">Int.max_unsigned</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">unfold</span> <span class="id">Int.ltu</span>. <span class="tactic">apply</span> <span class="id">zlt_true</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">small_shift_amount_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">Int64.ltu</span> <span class="id">i</span> (<span class="id">Int64.repr</span> 32) = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Int.ltu</span> (<span class="id">Int64.loword</span> <span class="id">i</span>) <span class="id">Int.iwordsize</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4512')">Proof.</div>
<div class="proofscript" id="proof4512">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Int64.ltu_inv</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">comput</span> (<span class="id">Int64.unsigned</span> (<span class="id">Int64.repr</span> 32)).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Int64.unsigned</span> <span class="id">i</span> = <span class="id">Int.unsigned</span> (<span class="id">Int64.loword</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.loword</span>. <span class="tactic">rewrite</span> <span class="id">Int.unsigned_repr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">comput</span> <span class="id">Int.max_unsigned</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int.ltu</span>. <span class="tactic">apply</span> <span class="id">zlt_true</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">small_shift_amount_3</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">Int.ltu</span> <span class="id">i</span> <span class="id">Int64.iwordsize</span>' = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Int64.unsigned</span> (<span class="id">Int64.repr</span> (<span class="id">Int.unsigned</span> <span class="id">i</span>)) = <span class="id">Int.unsigned</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4513')">Proof.</div>
<div class="proofscript" id="proof4513">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Int.ltu_inv</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">comput</span> (<span class="id">Int.unsigned</span> <span class="id">Int64.iwordsize</span>').<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int64.unsigned_repr</span>. <span class="id">comput</span> <span class="id">Int64.max_unsigned</span>; <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_shl_correct</span>: <span class="id">shift_constructor_correct</span> <span class="id">make_shl</span> <span class="id">sem_shl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4514')">Proof.</div>
<div class="proofscript" id="proof4514">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_shl</span>, <span class="id">sem_shl</span>, <span class="id">sem_shift</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_shift</span> <span class="id">tya</span> <span class="id">tyb</span>); <span class="id">inv</span> <span class="id">MAKE</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int.iwordsize</span>) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">E</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int64.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">small_shift_amount_1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">f_equal</span>; <span class="tactic">f_equal</span>. <span class="tactic">unfold</span> <span class="id">Int64.shl</span>', <span class="id">Int64.shl</span>. <span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int64.ltu</span> <span class="id">i0</span> (<span class="id">Int64.repr</span> 32)) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">small_shift_amount_2</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>') <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.shl</span>', <span class="id">Int64.shl</span>. <span class="tactic">rewrite</span> <span class="id">small_shift_amount_3</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_shr_correct</span>: <span class="id">shift_constructor_correct</span> <span class="id">make_shr</span> <span class="id">sem_shr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4515')">Proof.</div>
<div class="proofscript" id="proof4515">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">make_shr</span>, <span class="id">sem_shr</span>, <span class="id">sem_shift</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_shift</span> <span class="id">tya</span> <span class="id">tyb</span>); <span class="id">inv</span> <span class="id">MAKE</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">va</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int.iwordsize</span>) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">E</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int64.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">small_shift_amount_1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">A</span>;<br/>
&nbsp;&nbsp;<span class="tactic">f_equal</span>; <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.shr</span>', <span class="id">Int64.shr</span>; <span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.shru</span>', <span class="id">Int64.shru</span>; <span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int64.ltu</span> <span class="id">i0</span> (<span class="id">Int64.repr</span> 32)) <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">small_shift_amount_2</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>') <span class="id">eqn</span>:<span class="id">E</span>; <span class="id">inv</span> <span class="id">SEM</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>; <span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.shr</span>', <span class="id">Int64.shr</span>; <span class="tactic">rewrite</span> <span class="id">small_shift_amount_3</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Int64.shru</span>', <span class="id">Int64.shru</span>; <span class="tactic">rewrite</span> <span class="id">small_shift_amount_3</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cmp_ptr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cmp</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> <span class="id">b</span> <span class="id">vb</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">cmp_ptr</span> <span class="id">m</span> <span class="id">cmp</span> <span class="id">va</span> <span class="id">vb</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="id">make_cmp_ptr</span> <span class="id">cmp</span> <span class="id">a</span> <span class="id">b</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4516')">Proof.</div>
<div class="proofscript" id="proof4516">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">cmp_ptr</span>, <span class="id">make_cmp_ptr</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
simpl.&nbsp;unfold&nbsp;Val.cmpu.<br/>
&nbsp;&nbsp;destruct&nbsp;(Val.cmpu_bool&nbsp;(Mem.valid_pointer&nbsp;m)&nbsp;cmp&nbsp;va&nbsp;vb)&nbsp;as&nbsp;[bo|];&nbsp;inv&nbsp;H.&nbsp;auto.*)</span>Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">make_ptrofs_of_int_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">i</span> <span class="id">si</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vint</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="kwd">if</span> <span class="id">Archi.ptr64</span> <span class="kwd">then</span> <span class="id">make_longofint</span> <span class="id">a</span> <span class="id">si</span> <span class="kwd">else</span> <span class="id">a</span>) (<span class="id">Vptrofs</span> (<span class="id">ptrofs_of_int</span> <span class="id">si</span> <span class="id">i</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4517')">Proof.</div>
<div class="proofscript" id="proof4517">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Vptrofs</span>, <span class="id">ptrofs_of_int</span>. <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">make_longofint</span>. <span class="tactic">destruct</span> <span class="id">si</span>.<br/>
+ <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int64</span> (<span class="id">Ptrofs.of_ints</span> <span class="id">i</span>)) <span class="kwd">with</span> (<span class="id">Int64.repr</span> (<span class="id">Int.signed</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int64.eqm_samerepr</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.eqm64</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Ptrofs.eqm_unsigned_repr</span>.<br/>
+ <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int64</span> (<span class="id">Ptrofs.of_intu</span> <span class="id">i</span>)) <span class="kwd">with</span> (<span class="id">Int64.repr</span> (<span class="id">Int.unsigned</span> <span class="id">i</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">cshm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int64.eqm_samerepr</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.eqm64</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Ptrofs.eqm_unsigned_repr</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">si</span>.<br/>
+ <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int</span> (<span class="id">Ptrofs.of_ints</span> <span class="id">i</span>)) <span class="kwd">with</span> <span class="id">i</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
+ <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int</span> (<span class="id">Ptrofs.of_intu</span> <span class="id">i</span>)) <span class="kwd">with</span> <span class="id">i</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">make_ptrofs_of_int64_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> (<span class="id">Vlong</span> <span class="id">i</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> (<span class="kwd">if</span> <span class="id">Archi.ptr64</span> <span class="kwd">then</span> <span class="id">a</span> <span class="kwd">else</span> <span class="id">Eunop</span> <span class="id">Ointoflong</span> <span class="id">a</span>) (<span class="id">Vptrofs</span> (<span class="id">Ptrofs.of_int64</span> <span class="id">i</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4518')">Proof.</div>
<div class="proofscript" id="proof4518">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Vptrofs</span>. <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>.<br/>
- <span class="tactic">replace</span> (<span class="id">Ptrofs.to_int64</span> (<span class="id">Ptrofs.of_int64</span> <span class="id">i</span>)) <span class="kwd">with</span> <span class="id">i</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Int.eqm_samerepr</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.eqm32</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Ptrofs.eqm_unsigned_repr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_cmp_correct</span>: <span class="kwd">forall</span> <span class="id">cmp</span>, <span class="id">binary_constructor_correct</span> (<span class="id">make_cmp</span> <span class="id">cmp</span>) (<span class="id">sem_cmp</span> <span class="id">cmp</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4519')">Proof.</div>
<div class="proofscript" id="proof4519">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">sem_cmp</span>, <span class="id">make_cmp</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">SEM</span> <span class="id">MAKE</span> <span class="id">EV1</span> <span class="id">EV2</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_cmp</span> <span class="id">tya</span> <span class="id">tyb</span>).<br/>
- <span class="id">inv</span> <span class="id">MAKE</span>. <span class="tactic">eapply</span> <span class="id">make_cmp_ptr_correct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">inv</span> <span class="id">MAKE</span>. <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">InvEval</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_cmp_ptr_correct</span>, <span class="id">make_ptrofs_of_int_correct</span>.<br/>
- <span class="id">inv</span> <span class="id">MAKE</span>. <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_cmp_ptr_correct</span>, <span class="id">make_ptrofs_of_int_correct</span>.<br/>
- <span class="id">inv</span> <span class="id">MAKE</span>. <span class="tactic">destruct</span> <span class="id">vb</span>; <span class="id">InvEval</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_cmp_ptr_correct</span>, <span class="id">make_ptrofs_of_int64_correct</span>.<br/>
- <span class="id">inv</span> <span class="id">MAKE</span>. <span class="tactic">destruct</span> <span class="id">va</span>; <span class="id">InvEval</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_cmp_ptr_correct</span>, <span class="id">make_ptrofs_of_int64_correct</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">make_binarith_correct</span>; <span class="tactic">eauto</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_unop_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">c</span> <span class="id">va</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_unop</span> <span class="id">op</span> <span class="id">a</span> <span class="id">tya</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_unary_operation</span> <span class="id">op</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4520')">Proof.</div>
<div class="proofscript" id="proof4520">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_notbool_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_notint_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_neg_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_absfloat_correct</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_binop_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> <span class="id">c</span> <span class="id">va</span> <span class="id">vb</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_binop</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">op</span> <span class="id">a</span> <span class="id">tya</span> <span class="id">b</span> <span class="id">tyb</span> = <span class="id">OK</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">sem_binary_operation</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">op</span> <span class="id">va</span> <span class="id">tya</span> <span class="id">vb</span> <span class="id">tyb</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">va</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">vb</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">c</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4521')">Proof.</div>
<div class="proofscript" id="proof4521">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_add_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_sub_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_mul_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_div_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_mod_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_and_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_or_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_xor_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_shl_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_shr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cmp_correct</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_load_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">addr</span> <span class="id">ty</span> <span class="id">code</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">make_load</span> <span class="id">addr</span> <span class="id">ty</span> = <span class="id">OK</span> <span class="id">code</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">addr</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">deref_loc</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">code</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4522')">Proof.</div>
<div class="proofscript" id="proof4522">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_load</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>; <span class="tactic">intros</span> <span class="id">MKLOAD</span> <span class="id">EVEXP</span> <span class="id">DEREF</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">DEREF</span>.<br/>
&nbsp;scalar&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">MKLOAD</span>. <span class="id">inv</span> <span class="id">MKLOAD</span>. <span class="tactic">apply</span> <span class="id">eval_Eload</span> <span class="kwd">with</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>); <span class="tactic">auto</span>.<br/>
&nbsp;by&nbsp;reference&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">MKLOAD</span>. <span class="id">inv</span> <span class="id">MKLOAD</span>. <span class="tactic">auto</span>.<br/>
&nbsp;by&nbsp;copy&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">MKLOAD</span>. <span class="id">inv</span> <span class="id">MKLOAD</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_memcpy_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">dst</span> <span class="id">src</span> <span class="id">ty</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">s</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">dst</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">src</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">access_mode</span> <span class="id">ty</span> = <span class="id">By_copy</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">make_memcpy</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">dst</span> <span class="id">src</span> <span class="id">ty</span> = <span class="id">OK</span> <span class="id">s</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">step</span> <span class="id">ge</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4523')">Proof.</div>
<div class="proofscript" id="proof4523">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_alignof_blockcopy</span>. <span class="id">eexact</span> <span class="id">LINK</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">rewrite</span> <span class="id">A</span>, <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> <span class="id">le</span> <span class="kwd">with</span> (<span class="id">set_optvar</span> <span class="id">None</span> <span class="id">Vundef</span> <span class="id">le</span>) <span class="tactic">at</span> 2.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">alignof_blockcopy_1248</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sizeof_pos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sizeof_alignof_blockcopy_compat</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">make_store_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">addr</span> <span class="id">ty</span> <span class="id">rhs</span> <span class="id">code</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' <span class="id">f</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">make_store</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">addr</span> <span class="id">ty</span> <span class="id">rhs</span> = <span class="id">OK</span> <span class="id">code</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">addr</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">rhs</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">assign_loc</span> <span class="id">prog</span>.(<span class="id">prog_comp_env</span>) <span class="id">ty</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">v</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">step</span> <span class="id">ge</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">code</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">Sskip</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4524')">Proof.</div>
<div class="proofscript" id="proof4524">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_store</span>. <span class="tactic">intros</span> <span class="id">until</span> <span class="id">k</span>; <span class="tactic">intros</span> <span class="id">MKSTORE</span> <span class="id">EV1</span> <span class="id">EV2</span> <span class="id">ASSIGN</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">ASSIGN</span>; <span class="tactic">subst</span>.<br/>
&nbsp;nonvolatile&nbsp;scalar&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">MKSTORE</span>; <span class="id">inv</span> <span class="id">MKSTORE</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;by&nbsp;copy&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">MKSTORE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_memcpy_correct</span> <span class="kwd">with</span> (<span class="id">b</span> := <span class="id">b</span>) (<span class="id">v</span> := <span class="id">Vptr</span> <span class="id">b</span>' <span class="id">ofs</span>'); <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">CONSTRUCTORS</span>.<br/>
<br/>
<h1> Basic preservation invariants </h1>
<br/>
<span class="kwd">Section</span> <span class="id">CORRECTNESS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Clight.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Csharpminor.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span>, <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_match</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_match</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">cu</span> <span class="id">tf</span>, <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">match_fundef</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> /\ <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_match</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">cu</span> <span class="id">tf</span>, <span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">match_fundef</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> /\ <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_match</span> <span class="id">TRANSL</span>).<br/>
<br/>
<h1> Matching between environments </h1>
<br/>
<div class="doc">In this section, we define a matching relation between
  a Clight local environment and a Csharpminor local environment. </div>
<br/>
<span class="kwd">Record</span> <span class="id">match_env</span> (<span class="id">e</span>: <span class="id">Clight.env</span>) (<span class="id">te</span>: <span class="id">Csharpminor.env</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_match_env</span> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_local</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span> (<span class="id">b</span>, <span class="id">ty</span>) -&gt; <span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">Ctypes.sizeof</span> <span class="id">ge</span> <span class="id">ty</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_local_inv</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">te</span>!<span class="id">id</span> = <span class="id">Some</span> (<span class="id">b</span>, <span class="id">sz</span>) -&gt; <span class="id">exists</span> <span class="id">ty</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">ty</span>)<br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_globals</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">te</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">te</span>!<span class="id">id</span> = <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4525')">Proof.</div>
<div class="proofscript" id="proof4525">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">te</span>!<span class="id">id</span>) <span class="kwd">as</span> [[<span class="id">b</span> <span class="id">sz</span>] | ] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_local_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">ty</span> <span class="id">EQ</span>]. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_same_blocks</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">te</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">blocks_of_env</span> <span class="id">te</span> = <span class="id">Clight.blocks_of_env</span> <span class="id">ge</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4526')">Proof.</div>
<div class="proofscript" id="proof4526">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">R</span> := <span class="kwd">fun</span> (<span class="id">x</span>: (<span class="id">block</span> * <span class="id">type</span>)) (<span class="id">y</span>: (<span class="id">block</span> * <span class="id">Z</span>)) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">x</span>, <span class="id">y</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">b1</span>, <span class="id">ty</span>), (<span class="id">b2</span>, <span class="id">sz</span>) =&gt; <span class="id">b2</span> = <span class="id">b1</span> /\ <span class="id">sz</span> = <span class="id">Ctypes.sizeof</span> <span class="id">ge</span> <span class="id">ty</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">list_forall2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">fun</span> <span class="id">i_x</span> <span class="id">i_y</span> =&gt; <span class="id">fst</span> <span class="id">i_x</span> = <span class="id">fst</span> <span class="id">i_y</span> /\ <span class="id">R</span> (<span class="id">snd</span> <span class="id">i_x</span>) (<span class="id">snd</span> <span class="id">i_y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PTree.elements</span> <span class="id">e</span>) (<span class="id">PTree.elements</span> <span class="id">te</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.elements_canonical_order</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span> [<span class="id">b</span> <span class="id">ty</span>] <span class="id">GET</span>. <span class="id">exists</span> (<span class="id">b</span>, <span class="id">Ctypes.sizeof</span> <span class="id">ge</span> <span class="id">ty</span>); <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">me_local</span>; <span class="tactic">eauto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">id</span> [<span class="id">b</span> <span class="id">sz</span>] <span class="id">GET</span>. <span class="id">exploit</span> <span class="id">me_local_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">ty</span> <span class="id">EQ</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_local</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">b</span>, <span class="id">ty</span>); <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">split</span>; <span class="tactic">congruence</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>, <span class="id">Clight.blocks_of_env</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">H0</span>. <span class="tactic">induction</span> 1. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">f_equal</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block_of_binding</span>, <span class="id">Clight.block_of_binding</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a1</span> <span class="kwd">as</span> [<span class="id">id1</span> [<span class="id">blk1</span> <span class="id">ty1</span>]]. <span class="tactic">destruct</span> <span class="id">b1</span> <span class="kwd">as</span> [<span class="id">id2</span> [<span class="id">blk2</span> <span class="id">sz2</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_free_blocks</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">te</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">Clight.blocks_of_env</span> <span class="id">ge</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">te</span>) = <span class="id">Some</span> <span class="id">m</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4527')">Proof.</div>
<div class="proofscript" id="proof4527">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> (<span class="id">match_env_same_blocks</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>). <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_empty</span>:<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">Clight.empty_env</span> <span class="id">Csharpminor.empty_env</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4528')">Proof.</div>
<div class="proofscript" id="proof4528">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Clight.empty_env</span>, <span class="id">Csharpminor.empty_env</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ty</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">sz</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The following lemmas establish the <span class="bracket"><span class="id">match_env</span></span> invariant at
  the beginning of a function invocation, after allocation of
  local variables and initialization of the parameters. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_alloc_variables</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cunit</span>, <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e2</span> <span class="id">m2</span>, <span class="id">Clight.alloc_variables</span> <span class="id">ge</span> <span class="id">e1</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e2</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tvars</span> <span class="id">te1</span>,<br/>
&nbsp;&nbsp;<span class="id">mmap</span> (<span class="id">transl_var</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>)) <span class="id">vars</span> = <span class="id">OK</span> <span class="id">tvars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e1</span> <span class="id">te1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">te2</span>,<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.alloc_variables</span> <span class="id">te1</span> <span class="id">m1</span> <span class="id">tvars</span> <span class="id">te2</span> <span class="id">m2</span><br/>
&nbsp;&nbsp;/\ <span class="id">match_env</span> <span class="id">e2</span> <span class="id">te2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4529')">Proof.</div>
<div class="proofscript" id="proof4529">
&nbsp;&nbsp;<span class="tactic">induction</span> 2; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="id">exists</span> <span class="id">te1</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H2</span>. <span class="id">monadInv</span> <span class="id">EQ</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_sizeof</span>. <span class="id">eexact</span> <span class="id">H</span>. <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">SZ</span>; <span class="tactic">rewrite</span> <span class="id">SZ</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHalloc_variables</span> <span class="id">x0</span> (<span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">b1</span>, <span class="id">Ctypes.sizeof</span> <span class="id">ge</span> <span class="id">ty</span>) <span class="id">te1</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;me_local&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">ty0</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>); <span class="tactic">intros</span>. <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">me_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;me_local_inv&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">sz</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>); <span class="tactic">intros</span>. <span class="id">exists</span> <span class="id">ty</span>; <span class="tactic">congruence</span>. <span class="tactic">eapply</span> <span class="id">me_local_inv</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">te2</span> [<span class="id">ALLOC</span> <span class="id">MENV</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">te2</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">temps</span>,<br/>
&nbsp;&nbsp;<span class="id">create_undef_temps</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">temps</span>) = <span class="id">Clight.create_undef_temps</span> <span class="id">temps</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4530')">Proof.</div>
<div class="proofscript" id="proof4530">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">temps</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]. <span class="tactic">simpl</span>. <span class="id">decEq</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bind_parameter_temps_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars</span> <span class="id">vals</span> <span class="id">le1</span> <span class="id">le2</span>,<br/>
&nbsp;&nbsp;<span class="id">Clight.bind_parameter_temps</span> <span class="id">vars</span> <span class="id">vals</span> <span class="id">le1</span> = <span class="id">Some</span> <span class="id">le2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) <span class="id">vals</span> <span class="id">le1</span> = <span class="id">Some</span> <span class="id">le2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4531')">Proof.</div>
<div class="proofscript" id="proof4531">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vals</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">ty</span>]. <span class="tactic">destruct</span> <span class="id">vals</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_vars_names</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">vars</span> <span class="id">tvars</span>,<br/>
&nbsp;&nbsp;<span class="id">mmap</span> (<span class="id">transl_var</span> <span class="id">ce</span>) <span class="id">vars</span> = <span class="id">OK</span> <span class="id">tvars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">map</span> <span class="id">fst</span> <span class="id">tvars</span> = <span class="id">var_names</span> <span class="id">vars</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4532')">Proof.</div>
<div class="proofscript" id="proof4532">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">mmap_inversion</span>; <span class="tactic">eauto</span>. <span class="tactic">generalize</span> <span class="id">vars</span> <span class="id">tvars</span>. <span class="tactic">induction</span> 1; <span class="tactic">simpl</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H0</span>. <span class="tactic">simpl</span>; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<h1> Proof of semantic preservation </h1>
<br/>
<h2> Semantic preservation for expressions </h2>
<br/>
<div class="doc">The proof of semantic preservation for the translation of expressions
  relies on simulation diagrams of the following form:
<pre>
         e, le, m, a ------------------- te, le, m, ta
            |                                |
            |                                |
            |                                |
            v                                v
         e, le, m, v ------------------- te, le, m, v</pre>
  Left: evaluation of r-value expression <span class="bracket"><span class="id">a</span></span> in Clight.
  Right: evaluation of its translation <span class="bracket"><span class="id">ta</span></span> in Csharpminor.
  Top (precondition): matching between environments <span class="bracket"><span class="id">e</span></span>, <span class="bracket"><span class="id">te</span></span>,
    plus well-typedness of expression <span class="bracket"><span class="id">a</span></span>.
  Bottom (postcondition): the result values <span class="bracket"><span class="id">v</span></span>
    are identical in both evaluations.
  We state these diagrams as the following properties, parameterized
  by the Clight evaluation. </div>
<br/>
<span class="kwd">Section</span> <span class="id">EXPR</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">cunit</span>: <span class="id">Clight.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cunit</span> <span class="id">prog</span>.<br/>
<span class="kwd">Variable</span> <span class="id">e</span>: <span class="id">Clight.env</span>.<br/>
<span class="kwd">Variable</span> <span class="id">le</span>: <span class="id">temp_env</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<span class="kwd">Variable</span> <span class="id">te</span>: <span class="id">Csharpminor.env</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">MENV</span>: <span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_lvalue_correct</span>:<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Clight.eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span> (<span class="id">TR</span>: <span class="id">transl_expr</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span>) ,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Csharpminor.eval_expr</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span> <span class="id">ta</span> <span class="id">v</span>)<br/>
/\(<span class="kwd">forall</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Clight.eval_lvalue</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span> (<span class="id">TR</span>: <span class="id">transl_lvalue</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Csharpminor.eval_expr</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span> <span class="id">ta</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4533')">Proof.</div>
<div class="proofscript" id="proof4533">
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_expr_lvalue_ind</span>; <span class="tactic">intros</span>; <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">TR</span>).<br/>
- <span class="comment">(*&nbsp;const&nbsp;int&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_intconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;const&nbsp;float&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_floatconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;const&nbsp;single&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_singleconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;const&nbsp;long&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">make_longconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;temp&nbsp;var&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;addrof&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;unop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_unop_correct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;binop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_binop_correct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;cast&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cast_correct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;sizeof&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">transl_sizeof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>). <span class="tactic">apply</span> <span class="id">make_ptrofsconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;alignof&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">transl_alignof</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">LINK</span> <span class="id">EQ</span>). <span class="tactic">apply</span> <span class="id">make_ptrofsconst_correct</span>.<br/>
- <span class="comment">(*&nbsp;rvalue&nbsp;out&nbsp;of&nbsp;lvalue&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_lvalue</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tb</span> [<span class="id">TRLVAL</span> <span class="id">MKLOAD</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_load_correct</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;var&nbsp;local&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">me_local</span> <span class="id">_</span> <span class="id">_</span> <span class="id">MENV</span>); <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eapply</span> <span class="id">eval_var_addr_local</span>. <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;var&nbsp;global&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eapply</span> <span class="id">eval_var_addr_global</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;deref&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>. <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;field&nbsp;struct&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_field_access</span> <span class="kwd">in</span> <span class="id">EQ0</span>. <span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">prog_comp_env</span> <span class="id">cunit</span>)!<span class="id">id</span> <span class="kwd">as</span> [<span class="id">co</span>'|] <span class="id">eqn</span>:<span class="id">CO</span>; <span class="id">monadInv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">field_offset_stable</span>. <span class="id">eexact</span> <span class="id">LINK</span>. <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">i</span>). <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">B</span> <span class="kwd">in</span> <span class="id">EQ1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x0</span> = <span class="id">delta</span>) <span class="tactic">by</span> (<span class="tactic">unfold</span> <span class="id">ge</span> <span class="kwd">in</span> *; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">congruence</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">x0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Archi.ptr64</span> <span class="id">eqn</span>:<span class="id">SF</span>.<br/>
+ <span class="tactic">eapply</span> <span class="id">eval_Ebinop</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_longconst_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
+ <span class="tactic">eapply</span> <span class="id">eval_Ebinop</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">make_intconst_correct</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">SF</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">apply</span> <span class="tactic">f_equal</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">ptrofs</span>.<br/>
- <span class="comment">(*&nbsp;field&nbsp;union&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_field_access</span> <span class="kwd">in</span> <span class="id">EQ0</span>; <span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">EQ0</span>; <span class="id">monadInv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_correct</span>:<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Clight.eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span>, <span class="id">transl_expr</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Csharpminor.eval_expr</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span> <span class="id">ta</span> <span class="id">v</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">proj1</span> <span class="id">transl_expr_lvalue_correct</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_lvalue_correct</span>:<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Clight.eval_lvalue</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">b</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span>, <span class="id">transl_lvalue</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id">Csharpminor.eval_expr</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span> <span class="id">ta</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">ofs</span>).<br/>
<span class="kwd">Proof</span> (<span class="id">proj2</span> <span class="id">transl_expr_lvalue_correct</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_arglist_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">Clight.eval_exprlist</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tal</span>, <span class="id">transl_arglist</span> <span class="id">cunit</span>.(<span class="id">prog_comp_env</span>) <span class="id">al</span> <span class="id">tyl</span> = <span class="id">OK</span> <span class="id">tal</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.eval_exprlist</span> <span class="id">tge</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tal</span> <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4534')">Proof.</div>
<div class="proofscript" id="proof4534">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H2</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cast_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">typlist_of_arglist_eq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">Clight.eval_exprlist</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">al</span> <span class="id">tyl</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">typlist_of_arglist</span> <span class="id">al</span> <span class="id">tyl</span> = <span class="id">typlist_of_typelist</span> <span class="id">tyl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4535')">Proof.</div>
<div class="proofscript" id="proof4535">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">f_equal</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">EXPR</span>.<br/>
<br/>
<h2> Semantic preservation for statements </h2>
<br/>
<div class="doc">The simulation diagram for the translation of statements and functions
  is a "plus" diagram of the form
<pre>
           I
     S1 ------- R1
     |          |
   t |        + | t
     v          v
     S2 ------- R2
           I                         I</pre>
The invariant <span class="bracket"><span class="id">I</span></span> is the <span class="bracket"><span class="id">match_states</span></span> predicate that we now define.
</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_transl</span>: <span class="id">stmt</span> -&gt; <span class="id">cont</span> -&gt; <span class="id">stmt</span> -&gt; <span class="id">cont</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_transl_0</span>: <span class="kwd">forall</span> <span class="id">ts</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_transl</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">ts</span> <span class="id">tk</span><br/>
&nbsp;&nbsp;| <span class="id">match_transl_1</span>: <span class="kwd">forall</span> <span class="id">ts</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_transl</span> (<span class="id">Sblock</span> <span class="id">ts</span>) <span class="id">tk</span> <span class="id">ts</span> (<span class="id">Kblock</span> <span class="id">tk</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_transl_step</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">ts</span>' <span class="id">tk</span>' <span class="id">f</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">match_transl</span> (<span class="id">Sblock</span> <span class="id">ts</span>) <span class="id">tk</span> <span class="id">ts</span>' <span class="id">tk</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">ts</span>' <span class="id">tk</span>' <span class="id">te</span> <span class="id">le</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">ts</span> (<span class="id">Kblock</span> <span class="id">tk</span>) <span class="id">te</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4536')">Proof.</div>
<div class="proofscript" id="proof4536">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_cont</span>: <span class="id">composite_env</span> -&gt; <span class="id">type</span> -&gt; <span class="id">nat</span> -&gt; <span class="id">nat</span> -&gt; <span class="id">Clight.cont</span> -&gt; <span class="id">Csharpminor.cont</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_Kstop</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">tyret</span> <span class="id">ce</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">Clight.Kstop</span> <span class="id">Kstop</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kseq</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">s</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Clight.Kseq</span> <span class="id">s</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kseq</span> <span class="id">ts</span> <span class="id">tk</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_Kloop1</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> 1%<span class="id">nat</span> 0%<span class="id">nat</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> 0%<span class="id">nat</span> (<span class="id">S</span> <span class="id">ncnt</span>) <span class="id">s2</span> = <span class="id">OK</span> <span class="id">ts2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> 1%<span class="id">nat</span> 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Clight.Kloop1</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kblock</span> (<span class="id">Kseq</span> <span class="id">ts2</span> (<span class="id">Kseq</span> (<span class="id">Sloop</span> (<span class="id">Sseq</span> (<span class="id">Sblock</span> <span class="id">ts1</span>) <span class="id">ts2</span>)) (<span class="id">Kblock</span> <span class="id">tk</span>))))<br/>
&nbsp;&nbsp;| <span class="id">match_Kloop2</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">ts1</span> <span class="id">ts2</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> 1%<span class="id">nat</span> 0%<span class="id">nat</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> 0%<span class="id">nat</span> (<span class="id">S</span> <span class="id">ncnt</span>) <span class="id">s2</span> = <span class="id">OK</span> <span class="id">ts2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> 0%<span class="id">nat</span> (<span class="id">S</span> <span class="id">ncnt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Clight.Kloop2</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kseq</span> (<span class="id">Sloop</span> (<span class="id">Sseq</span> (<span class="id">Sblock</span> <span class="id">ts1</span>) <span class="id">ts2</span>)) (<span class="id">Kblock</span> <span class="id">tk</span>))<br/>
&nbsp;&nbsp;| <span class="id">match_Kswitch</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> 0%<span class="id">nat</span> (<span class="id">S</span> <span class="id">ncnt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Clight.Kswitch</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kblock</span> <span class="id">tk</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_Kcall</span>: <span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">f</span> <span class="id">e</span> <span class="id">k</span> <span class="id">id</span> <span class="id">tf</span> <span class="id">te</span> <span class="id">le</span> <span class="id">tk</span> <span class="id">cu</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_function</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) (<span class="id">Clight.fn_return</span> <span class="id">f</span>) <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Clight.Kcall</span> <span class="id">id</span> <span class="id">f</span> <span class="id">e</span> <span class="id">le</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kcall</span> <span class="id">id</span> <span class="id">tf</span> <span class="id">te</span> <span class="id">le</span> <span class="id">tk</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">Clight.state</span> -&gt; <span class="id">Csharpminor.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">te</span> <span class="id">ts</span>' <span class="id">tk</span>' <span class="id">cu</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transl_function</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_statement</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) (<span class="id">Clight.fn_return</span> <span class="id">f</span>) <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MTR</span>: <span class="id">match_transl</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">ts</span>' <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MENV</span>: <span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) (<span class="id">Clight.fn_return</span> <span class="id">f</span>) <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Clight.State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">tf</span> <span class="id">ts</span>' <span class="id">tk</span>' <span class="id">te</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_callstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tfd</span> <span class="id">tk</span> <span class="id">targs</span> <span class="id">tres</span> <span class="id">cconv</span> <span class="id">cu</span> <span class="id">ce</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LINK</span>: <span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">match_fundef</span> <span class="id">cu</span> <span class="id">fd</span> <span class="id">tfd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">Tvoid</span> 0%<span class="id">nat</span> 0%<span class="id">nat</span> <span class="id">k</span> <span class="id">tk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ISCC</span>: <span class="id">Clight.is_call_cont</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TY</span>: <span class="id">type_of_fundef</span> <span class="id">fd</span> = <span class="id">Tfunction</span> <span class="id">targs</span> <span class="id">tres</span> <span class="id">cconv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Clight.Callstate</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">tfd</span> <span class="id">args</span> <span class="id">tk</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_returnstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">res</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tk</span> <span class="id">ce</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">Tvoid</span> 0%<span class="id">nat</span> 0%<span class="id">nat</span> <span class="id">k</span> <span class="id">tk</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Clight.Returnstate</span> <span class="id">res</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">res</span> <span class="id">tk</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">match_states_skip</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tf</span> <span class="id">tk</span> <span class="id">m</span> <span class="id">cu</span>,<br/>
&nbsp;&nbsp;<span class="id">linkorder</span> <span class="id">cu</span> <span class="id">prog</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_function</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">e</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">cu</span>.(<span class="id">prog_comp_env</span>) (<span class="id">Clight.fn_return</span> <span class="id">f</span>) <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Clight.State</span> <span class="id">f</span> <span class="id">Clight.Sskip</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>) (<span class="id">State</span> <span class="id">tf</span> <span class="id">Sskip</span> <span class="id">tk</span> <span class="id">te</span> <span class="id">le</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4537')">Proof.</div>
<div class="proofscript" id="proof4537">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Commutation between label resolution and compilation </div>
<br/>
<span class="kwd">Section</span> <span class="id">FIND_LABEL</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ce</span>: <span class="id">composite_env</span>.<br/>
<span class="kwd">Variable</span> <span class="id">lbl</span>: <span class="id">label</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tyret</span>: <span class="id">type</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span><br/>
&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;(<span class="id">MC</span>: <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span>),<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Clight.find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>', <span class="id">exists</span> <span class="id">nbrk</span>', <span class="id">exists</span> <span class="id">ncnt</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">Some</span> (<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">k</span>' <span class="id">tk</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<br/>
<span class="kwd">with</span> <span class="id">transl_find_label_ls</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tls</span> <span class="id">tk</span><br/>
&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_lbl_stmt</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">ls</span> = <span class="id">OK</span> <span class="id">tls</span>)<br/>
&nbsp;&nbsp;(<span class="id">MC</span>: <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span>),<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Clight.find_label_ls</span> <span class="id">lbl</span> <span class="id">ls</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label_ls</span> <span class="id">lbl</span> <span class="id">tls</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>', <span class="id">exists</span> <span class="id">nbrk</span>', <span class="id">exists</span> <span class="id">ncnt</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label_ls</span> <span class="id">lbl</span> <span class="id">tls</span> <span class="id">tk</span> = <span class="id">Some</span> (<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transl_statement</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">k</span>' <span class="id">tk</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4538')">Proof.</div>
<div class="proofscript" id="proof4538">
* <span class="tactic">intro</span> <span class="id">s</span>; <span class="tactic">case</span> <span class="id">s</span>; <span class="tactic">intros</span>; <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">TR</span>); <span class="tactic">simpl</span>.<br/>
- <span class="comment">(*&nbsp;skip&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;assign&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">make_store</span>, <span class="id">make_memcpy</span> <span class="kwd">in</span> <span class="id">EQ3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">access_mode</span> (<span class="id">typeof</span> <span class="id">e</span>)); <span class="id">monadInv</span> <span class="id">EQ3</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;set&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>. <span class="tactic">destruct</span> (<span class="id">classify_fun</span> (<span class="id">typeof</span> <span class="id">e</span>)); <span class="id">monadInv</span> <span class="id">TR</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;builtin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s0</span> <span class="id">nbrk</span> <span class="id">ncnt</span> (<span class="id">Clight.Kseq</span> <span class="id">s1</span> <span class="id">k</span>)); <span class="tactic">eauto</span>. <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Clight.find_label</span> <span class="id">lbl</span> <span class="id">s0</span> (<span class="id">Clight.Kseq</span> <span class="id">s1</span> <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">nbrk</span>' [<span class="id">ncnt</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">nbrk</span>'; <span class="id">exists</span> <span class="id">ncnt</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;ifthenelse&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s0</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Clight.find_label</span> <span class="id">lbl</span> <span class="id">s0</span> <span class="id">k</span>) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">nbrk</span>' [<span class="id">ncnt</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">nbrk</span>'; <span class="id">exists</span> <span class="id">ncnt</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;loop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s0</span> 1%<span class="id">nat</span> 0%<span class="id">nat</span> (<span class="id">Kloop1</span> <span class="id">s0</span> <span class="id">s1</span> <span class="id">k</span>)); <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Clight.find_label</span> <span class="id">lbl</span> <span class="id">s0</span> (<span class="id">Kloop1</span> <span class="id">s0</span> <span class="id">s1</span> <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">nbrk</span>' [<span class="id">ncnt</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">nbrk</span>'; <span class="id">exists</span> <span class="id">ncnt</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;break&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;continue&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>. <span class="tactic">destruct</span> <span class="id">o</span>; <span class="id">monadInv</span> <span class="id">TR</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;switch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">b</span>, <span class="id">ts</span> = <span class="id">Sblock</span> (<span class="id">Sswitch</span> <span class="id">b</span> <span class="id">x</span> <span class="id">x0</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> (<span class="id">classify_switch</span> (<span class="id">typeof</span> <span class="id">e</span>)); <span class="id">inv</span> <span class="id">EQ2</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">b</span> <span class="id">EQ3</span>]; <span class="tactic">rewrite</span> <span class="id">EQ3</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_find_label_ls</span> <span class="kwd">with</span> (<span class="id">k</span> := <span class="id">Clight.Kswitch</span> <span class="id">k</span>); <span class="tactic">eauto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;label&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">lbl</span> <span class="id">l</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>; <span class="id">exists</span> <span class="id">tk</span>; <span class="id">exists</span> <span class="id">nbrk</span>; <span class="id">exists</span> <span class="id">ncnt</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
- <span class="comment">(*&nbsp;goto&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
* <span class="tactic">intro</span> <span class="id">ls</span>; <span class="tactic">case</span> <span class="id">ls</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">TR</span>; <span class="tactic">simpl</span>.<br/>
- <span class="comment">(*&nbsp;nil&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;cons&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s</span> <span class="id">nbrk</span> <span class="id">ncnt</span> (<span class="id">Clight.Kseq</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">l</span>) <span class="id">k</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">transl_lbl_stmt_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Clight.find_label</span> <span class="id">lbl</span> <span class="id">s</span> (<span class="id">Clight.Kseq</span> (<span class="id">seq_of_labeled_statement</span> <span class="id">l</span>) <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">nbrk</span>' [<span class="id">ncnt</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">nbrk</span>'; <span class="id">exists</span> <span class="id">ncnt</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_find_label_ls</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">FIND_LABEL</span>.<br/>
<br/>
<div class="doc">Properties of call continuations </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span>' <span class="id">tyret</span>' <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span>' <span class="id">tyret</span>' <span class="id">nbrk</span>' <span class="id">ncnt</span>' (<span class="id">Clight.call_cont</span> <span class="id">k</span>) (<span class="id">call_cont</span> <span class="id">tk</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4539')">Proof.</div>
<div class="proofscript" id="proof4539">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_cont_is_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">ce</span>' <span class="id">tyret</span>' <span class="id">nbrk</span>' <span class="id">ncnt</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span> <span class="id">tyret</span> <span class="id">nbrk</span> <span class="id">ncnt</span> <span class="id">k</span> <span class="id">tk</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Clight.is_call_cont</span> <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">ce</span>' <span class="id">tyret</span>' <span class="id">nbrk</span>' <span class="id">ncnt</span>' <span class="id">k</span> <span class="id">tk</span> /\ <span class="id">is_call_cont</span> <span class="id">tk</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4540')">Proof.</div>
<div class="proofscript" id="proof4540">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>; <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The simulation proof </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_step</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">Clight.step2</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">T1</span>, <span class="id">match_states</span> <span class="id">S1</span> <span class="id">T1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>, <span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> <span class="id">T1</span> <span class="id">t</span> <span class="id">T2</span> /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">T2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4541')">Proof.</div>
<div class="proofscript" id="proof4541">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">T1</span> <span class="id">MST</span>; <span class="id">inv</span> <span class="id">MST</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;assign&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SAME</span>: <span class="id">ts</span>' = <span class="id">ts</span> /\ <span class="id">tk</span>' = <span class="id">tk</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">inversion</span> <span class="id">MTR</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">ts</span>. <span class="tactic">unfold</span> <span class="id">make_store</span>, <span class="id">make_memcpy</span> <span class="kwd">in</span> <span class="id">EQ3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">access_mode</span> (<span class="id">typeof</span> <span class="id">a1</span>)); <span class="id">monadInv</span> <span class="id">EQ3</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">SAME</span>; <span class="tactic">subst</span> <span class="id">ts</span>' <span class="id">tk</span>'.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">make_store_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_lvalue_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">make_cast_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;set&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="tactic">eapply</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">TR</span>. <span class="tactic">simpl</span>. <span class="id">case_eq</span> (<span class="id">classify_fun</span> (<span class="id">typeof</span> <span class="id">a</span>)); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">targs</span> <span class="id">tres</span> <span class="id">cc</span> <span class="id">CF</span> <span class="id">TR</span>. <span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">cu</span>' &amp; <span class="id">tfd</span> &amp; <span class="id">FIND</span> &amp; <span class="id">TFD</span> &amp; <span class="id">LINK</span>').<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">CF</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">CF</span>. <span class="id">inv</span> <span class="id">CF</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_expr_correct</span> <span class="kwd">with</span> (<span class="id">cunit</span> := <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_arglist_correct</span> <span class="kwd">with</span> (<span class="id">cunit</span> := <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">typlist_of_arglist_eq</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_fundef_sig1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_Kcall</span> <span class="kwd">with</span> (<span class="id">ce</span> := <span class="id">prog_comp_env</span> <span class="id">cu</span>') (<span class="id">cu</span> := <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;builtin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_arglist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>). <span class="tactic">apply</span> <span class="id">senv_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;skip&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">step_skip_seq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;continue&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;break&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;ifthenelse&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">make_boolean_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">step_ifthenelse</span> <span class="kwd">with</span> (<span class="id">v</span> := <span class="id">v</span>) (<span class="id">b</span> := <span class="id">b</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>; <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;loop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_plus_trans</span>. <span class="tactic">eapply</span> <span class="id">match_transl_step</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;skip-or-continue&nbsp;loop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">ts</span>' = <span class="id">Sskip</span> \/ <span class="id">ts</span>' = <span class="id">Sexit</span> <span class="id">ncnt</span>) /\ <span class="id">tk</span>' = <span class="id">tk</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">x</span>; <span class="id">monadInv</span> <span class="id">TR</span>; <span class="id">inv</span> <span class="id">MTR</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">ts</span>'. 2:<span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;break&nbsp;loop1&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;skip&nbsp;loop2&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H6</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H8</span>; <span class="tactic">simpl</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;break&nbsp;loop2&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;none&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_free_blocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_returnstate</span> <span class="kwd">with</span> (<span class="id">ce</span> := <span class="id">prog_comp_env</span> <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;some&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">make_cast_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_free_blocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_returnstate</span> <span class="kwd">with</span> (<span class="id">ce</span> := <span class="id">prog_comp_env</span> <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;skip&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_cont_is_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">step_skip_call</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_free_blocks</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_returnstate</span> <span class="kwd">with</span> (<span class="id">ce</span> := <span class="id">prog_comp_env</span> <span class="id">cu</span>); <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;switch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">E</span>: <span class="id">exists</span> <span class="id">b</span>, <span class="id">ts</span> = <span class="id">Sblock</span> (<span class="id">Sswitch</span> <span class="id">b</span> <span class="id">x</span> <span class="id">x0</span>) /\ <span class="id">Switch.switch_argument</span> <span class="id">b</span> <span class="id">v</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">sem_switch_arg</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">classify_switch</span> (<span class="id">typeof</span> <span class="id">a</span>)); <span class="id">inv</span> <span class="id">EQ2</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">v</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">constructor</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">E</span> <span class="kwd">as</span> (<span class="id">b</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">subst</span> <span class="id">ts</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">EV</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_plus_trans</span>. <span class="tactic">eapply</span> <span class="id">match_transl_step</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_lbl_stmt_2</span>. <span class="tactic">apply</span> <span class="id">transl_lbl_stmt_1</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;skip&nbsp;or&nbsp;break&nbsp;switch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">ts</span>' = <span class="id">Sskip</span> \/ <span class="id">ts</span>' = <span class="id">Sexit</span> <span class="id">nbrk</span>) /\ <span class="id">tk</span>' = <span class="id">tk</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>; <span class="tactic">subst</span> <span class="id">x</span>; <span class="id">monadInv</span> <span class="id">TR</span>; <span class="id">inv</span> <span class="id">MTR</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">destruct</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">ts</span>'. 2:<span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_skip</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;continue&nbsp;switch&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>. <span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;label&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;goto&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">inv</span> <span class="id">MTR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRF</span>. <span class="tactic">unfold</span> <span class="id">transl_function</span>. <span class="tactic">intro</span> <span class="id">TRF</span>'. <span class="id">monadInv</span> <span class="id">TRF</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> (<span class="id">prog_comp_env</span> <span class="id">cu</span>) <span class="id">lbl</span>). <span class="id">eexact</span> <span class="id">EQ</span>. <span class="tactic">eapply</span> <span class="id">match_cont_call_cont</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>'' [<span class="id">nbrk</span>' [<span class="id">ncnt</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>. <span class="tactic">simpl</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">TR</span>. <span class="id">monadInv</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_cont_is_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_env_alloc_variables</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_env_empty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">te1</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_internal_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">erewrite</span> <span class="id">transl_vars_names</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">create_undef_temps_match</span>. <span class="tactic">eapply</span> <span class="id">bind_parameter_temps_match</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_function</span>. <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">EQ1</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_cont_is_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_returnstate</span> <span class="kwd">with</span> (<span class="id">ce</span> := <span class="id">ce</span>); <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;returnstate&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">reflexivity</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span>, <span class="id">Clight.initial_state</span> <span class="id">prog</span> <span class="id">S</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">R</span>, <span class="id">initial_state</span> <span class="id">tprog</span> <span class="id">R</span> /\ <span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4542')">Proof.</div>
<div class="proofscript" id="proof4542">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">cu</span> &amp; <span class="id">tf</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">D</span>: <span class="id">Genv.find_symbol</span> <span class="id">tge</span> (<span class="id">AST.prog_main</span> <span class="id">tprog</span>) = <span class="id">Some</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">TRANSL</span> <span class="kwd">as</span> (<span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span>). <span class="tactic">rewrite</span> <span class="id">Q</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">E</span>: <span class="id">funsig</span> <span class="id">tf</span> = <span class="id">signature_of_type</span> <span class="id">Tnil</span> <span class="id">type_int32s</span> <span class="id">cc_default</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">transl_fundef_sig2</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> (<span class="id">Genv.init_mem_match</span> <span class="id">TRANSL</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">instantiate</span> (1 := <span class="id">prog_comp_env</span> <span class="id">cu</span>). <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">exact</span> <span class="id">I</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span> <span class="id">R</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span> -&gt; <span class="id">Clight.final_state</span> <span class="id">S</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">R</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4543')">Proof.</div>
<div class="proofscript" id="proof4543">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">MK</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">Clight.semantics2</span> <span class="id">prog</span>) (<span class="id">Csharpminor.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4544')">Proof.</div>
<div class="proofscript" id="proof4544">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_plus</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_final_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_step</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">CORRECTNESS</span>.<br/>
<br/>
<h2> Commutation with linking </h2>
<br/>
<span class="kwd">Instance</span> <span class="id">TransfCshmgenLink</span> : <span class="id">TransfLink</span> <span class="id">match_prog</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4545')">Proof.</div>
<div class="proofscript" id="proof4545">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">link_linkorder</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> (<span class="id">LO1</span> &amp; <span class="id">LO2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">H</span>.<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Ctypes.Linker_program</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">link_program</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link</span> (<span class="id">program_of_program</span> <span class="id">p1</span>) (<span class="id">program_of_program</span> <span class="id">p2</span>)) <span class="kwd">as</span> [<span class="id">pp</span>|] <span class="id">eqn</span>:<span class="id">LP</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">lift_option</span> (<span class="id">link</span> (<span class="id">prog_types</span> <span class="id">p1</span>) (<span class="id">prog_types</span> <span class="id">p2</span>))) <span class="kwd">as</span> [[<span class="id">typs</span> <span class="id">EQ</span>]|<span class="id">P</span>]; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">link_build_composite_env</span> (<span class="id">prog_types</span> <span class="id">p1</span>) (<span class="id">prog_types</span> <span class="id">p2</span>) <span class="id">typs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">prog_comp_env</span> <span class="id">p1</span>) (<span class="id">prog_comp_env</span> <span class="id">p2</span>) (<span class="id">prog_comp_env_eq</span> <span class="id">p1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">prog_comp_env_eq</span> <span class="id">p2</span>) <span class="id">EQ</span>) <span class="kwd">as</span> (<span class="id">env</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Linking.link_match_program</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>.<br/>
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">Linker_fundef</span> <span class="id">Linking.Linker_fundef</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>; <span class="id">inv</span> <span class="id">H4</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
+ <span class="tactic">discriminate</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">ef</span>; <span class="id">inv</span> <span class="id">H2</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="id">left</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">destruct</span> <span class="id">ef</span>; <span class="id">inv</span> <span class="id">H2</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="id">right</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">destruct</span> (<span class="id">external_function_eq</span> <span class="id">ef</span> <span class="id">ef0</span> &amp;&amp; <span class="id">typelist_eq</span> <span class="id">args</span> <span class="id">args0</span> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">type_eq</span> <span class="id">res</span> <span class="id">res0</span> &amp;&amp; <span class="id">calling_convention_eq</span> <span class="id">cc</span> <span class="id">cc0</span>) <span class="id">eqn</span>:<span class="id">E</span>'; <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">InvBooleans</span>. <span class="tactic">subst</span> <span class="id">ef0</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">dec_eq_true</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">constructor</span>. <span class="tactic">congruence</span>.<br/>
- <span class="tactic">intros</span>. <span class="id">exists</span> <span class="id">tt</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">replace</span> (<span class="id">program_of_program</span> <span class="id">p</span>) <span class="kwd">with</span> <span class="id">pp</span>. <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">E</span>; <span class="tactic">destruct</span> <span class="id">pp</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
