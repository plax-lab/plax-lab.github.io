<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Linearizeproof</title>
<meta name="description" content="Documentation of Coq module Linearizeproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Linearizeproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for code linearization </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSets</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Ordered</span> <span class="id">Errors</span> <span class="id">Lattice</span> <span class="id">Kildall</span> <span class="id">Integers</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Locations</span> <span class="id">LTL</span> <span class="id">Linear</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Linearize</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="id">NodesetFacts</span> := <span class="id">FSetFacts.Facts</span>(<span class="id">Nodeset</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">LTL.program</span>) (<span class="id">tp</span>: <span class="id">Linear.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">ctx</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transf_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3585')">Proof.</div>
<div class="proofscript" id="proof3585">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_transform_partial_program</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">LINEARIZATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">LTL.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Linear.program</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">id</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Linear.funsig</span> <span class="id">tf</span> = <span class="id">LTL.funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3586')">Proof.</div>
<div class="proofscript" id="proof3586">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_fundef</span>, <span class="id">transf_partial_fundef</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="id">monadInv</span> <span class="id">EQ</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stacksize_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Linear.fn_stacksize</span> <span class="id">tf</span> = <span class="id">LTL.fn_stacksize</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3587')">Proof.</div>
<div class="proofscript" id="proof3587">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ros</span> <span class="id">ls</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">LTL.find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">ls</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">ls</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3588')">Proof.</div>
<div class="proofscript" id="proof3588">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">LTL.find_function</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">ros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functions_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">function_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of reachability analysis </h1>
<br/>
<div class="doc">The entry point of the function is reachable. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">reachable_entrypoint</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, (<span class="id">reachable</span> <span class="id">f</span>)!!(<span class="id">f</span>.(<span class="id">fn_entrypoint</span>)) = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3589')">Proof.</div>
<div class="proofscript" id="proof3589">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">reachable</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">reachable_aux</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">reachable_aux</span>; <span class="tactic">intros</span> <span class="id">reach</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LBoolean.ge</span> <span class="id">reach</span>!!(<span class="id">f</span>.(<span class="id">fn_entrypoint</span>)) <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">DS.fixpoint_entry</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">LBoolean.ge</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PMap.gi</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The successors of a reachable instruction are reachable. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">reachable_successors</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">pc</span>' <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">In</span> <span class="id">pc</span>' (<span class="id">successors_block</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span>' = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3590')">Proof.</div>
<div class="proofscript" id="proof3590">
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">f</span>. <span class="tactic">unfold</span> <span class="id">reachable</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">reachable_aux</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">reachable_aux</span>. <span class="tactic">intro</span> <span class="id">reach</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LBoolean.ge</span> <span class="id">reach</span>!!<span class="id">pc</span>' <span class="id">reach</span>!!<span class="id">pc</span>).<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">reach</span>!!<span class="id">pc</span>) <span class="kwd">with</span> ((<span class="kwd">fun</span> <span class="id">pc</span> <span class="id">r</span> =&gt; <span class="id">r</span>) <span class="id">pc</span> (<span class="id">reach</span>!!<span class="id">pc</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">DS.fixpoint_solution</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">DS.L.eq_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H3</span>; <span class="tactic">intro</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PMap.gi</span>.<br/>
Qed.</div>
<br/>
<h1> Properties of node enumeration </h1>
<br/>
<div class="doc">An enumeration of CFG nodes is correct if the following conditions hold:
<ul>
<li>
 All nodes for reachable basic blocks must be in the list.
</li>
<li>
 The list is without repetition (so that no code duplication occurs).
</li>
</ul>
We prove that the result of the <span class="bracket"><span class="id">enumerate</span></span> function satisfies both
conditions. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nodeset_of_list_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">s</span> <span class="id">s</span>',<br/>
&nbsp;&nbsp;<span class="id">nodeset_of_list</span> <span class="id">l</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">s</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">l</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">pc</span>, <span class="id">Nodeset.In</span> <span class="id">pc</span> <span class="id">s</span>' &lt;-&gt; <span class="id">Nodeset.In</span> <span class="id">pc</span> <span class="id">s</span> \/ <span class="id">In</span> <span class="id">pc</span> <span class="id">l</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">pc</span>, <span class="id">In</span> <span class="id">pc</span> <span class="id">l</span> -&gt; ~<span class="id">Nodeset.In</span> <span class="id">pc</span> <span class="id">s</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3591')">Proof.</div>
<div class="proofscript" id="proof3591">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">split</span>. <span class="tactic">intro</span>; <span class="tactic">tauto</span>. <span class="tactic">intros</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">H</span>; <span class="tactic">clear</span> <span class="id">H</span>; <span class="id">caseEq</span> (<span class="id">Nodeset.mem</span> <span class="id">a</span> <span class="id">s</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">intro</span>. <span class="tactic">elim</span> (<span class="id">C</span> <span class="id">a</span> <span class="id">H1</span>). <span class="tactic">apply</span> <span class="id">Nodeset.add_1</span>. <span class="id">hnf</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">rewrite</span> <span class="id">NodesetFacts.add_iff</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Nodeset.E.eq</span>. <span class="tactic">unfold</span> <span class="id">OrderedPositive.eq</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">subst</span> <span class="id">pc</span>. <span class="tactic">rewrite</span> <span class="id">NodesetFacts.not_mem_iff</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">C</span> <span class="id">pc</span> <span class="id">H1</span>). <span class="tactic">rewrite</span> <span class="id">NodesetFacts.add_iff</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">check_reachable_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">reach</span> <span class="id">s</span> <span class="id">pc</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">check_reachable</span> <span class="id">f</span> <span class="id">reach</span> <span class="id">s</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">reach</span>!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Nodeset.In</span> <span class="id">pc</span> <span class="id">s</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3592')">Proof.</div>
<div class="proofscript" id="proof3592">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">f</span> <span class="id">reach</span> <span class="id">s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ok</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.fold_left</span> (<span class="kwd">fun</span> <span class="id">a</span> <span class="id">p</span> =&gt; <span class="id">check_reachable_aux</span> <span class="id">reach</span> <span class="id">s</span> <span class="id">a</span> (<span class="id">fst</span> <span class="id">p</span>) (<span class="id">snd</span> <span class="id">p</span>)) <span class="id">l</span> <span class="id">ok</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ok</span> = <span class="id">true</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">pc</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">pc</span>, <span class="id">i</span>) <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">reach</span>!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Nodeset.In</span> <span class="id">pc</span> <span class="id">s</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">pc1</span> <span class="id">i1</span>]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">check_reachable_aux</span> <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">destruct</span> (<span class="id">reach</span>!!<span class="id">pc1</span>). <span class="tactic">elim</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>). <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">destruct</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Nodeset.mem_2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">pc</span> <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">check_reachable</span>. <span class="tactic">rewrite</span> <span class="id">PTree.fold_spec</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">eapply</span> <span class="id">B</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">enumerate_complete</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">enum</span> <span class="id">pc</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">enumerate</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">enum</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">pc</span> <span class="id">enum</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3593')">Proof.</div>
<div class="proofscript" id="proof3593">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">i</span>. <span class="tactic">unfold</span> <span class="id">enumerate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">reach</span> := <span class="id">reachable</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">EQ0</span>; <span class="tactic">clear</span> <span class="id">EQ0</span>. <span class="id">caseEq</span> (<span class="id">check_reachable</span> <span class="id">f</span> <span class="id">reach</span> <span class="id">x</span>); <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">check_reachable_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">nodeset_of_list_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">B</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">destruct</span> <span class="id">H2</span>. <span class="tactic">elim</span> (<span class="id">Nodeset.empty_1</span> <span class="id">H2</span>). <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">enumerate_norepet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">enum</span>,<br/>
&nbsp;&nbsp;<span class="id">enumerate</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">enum</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">enum</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3594')">Proof.</div>
<div class="proofscript" id="proof3594">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">enum</span>. <span class="tactic">unfold</span> <span class="id">enumerate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">reach</span> := <span class="id">reachable</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">EQ0</span>; <span class="tactic">clear</span> <span class="id">EQ0</span>. <span class="id">caseEq</span> (<span class="id">check_reachable</span> <span class="id">f</span> <span class="id">reach</span> <span class="id">x</span>); <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">EQ0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">nodeset_of_list_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Properties related to labels </h1>
<br/>
<div class="doc">If labels are globally unique and the Linear code <span class="bracket"><span class="id">c</span></span> contains
  a subsequence <span class="bracket"><span class="id">Llabel</span> <span class="id">lbl</span> :: <span class="id">c1</span></span>, then <span class="bracket"><span class="id">find_label</span> <span class="id">lbl</span> <span class="id">c</span></span> returns <span class="bracket"><span class="id">c1</span></span>.
</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">unique_labels</span> (<span class="id">c</span>: <span class="id">code</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| <span class="id">Llabel</span> <span class="id">lbl</span> :: <span class="id">c</span> =&gt; ~(<span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) <span class="id">c</span>) /\ <span class="id">unique_labels</span> <span class="id">c</span><br/>
&nbsp;&nbsp;| <span class="id">i</span> :: <span class="id">c</span> =&gt; <span class="id">unique_labels</span> <span class="id">c</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_unique</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c1</span> <span class="id">c2</span> <span class="id">c3</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">Llabel</span> <span class="id">lbl</span> :: <span class="id">c1</span>) <span class="id">c2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> <span class="id">c2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">c2</span> = <span class="id">Some</span> <span class="id">c3</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">c1</span> = <span class="id">c3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3595')">Proof.</div>
<div class="proofscript" id="proof3595">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c3</span> <span class="id">TAIL</span> <span class="id">UNIQ</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_label_correct</span> <span class="id">lbl</span> <span class="id">a</span>). <span class="tactic">case</span> (<span class="id">is_label</span> <span class="id">lbl</span> <span class="id">a</span>); <span class="tactic">intro</span> <span class="id">ISLBL</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">intro</span>. <span class="tactic">inversion</span> <span class="id">TAIL</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">UNIQ</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">H4</span>. <span class="tactic">apply</span> <span class="id">is_tail_in</span> <span class="kwd">with</span> <span class="id">c1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">TAIL</span>. <span class="tactic">congruence</span>. <span class="tactic">apply</span> <span class="id">IHc2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">UNIQ</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Correctness of the <span class="bracket"><span class="id">starts_with</span></span> test. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">starts_with_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c1</span> <span class="id">c2</span> <span class="id">c3</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">c1</span> <span class="id">c2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> <span class="id">c2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">starts_with</span> <span class="id">lbl</span> <span class="id">c1</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">c2</span> = <span class="id">Some</span> <span class="id">c3</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">c1</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">c3</span> <span class="id">ls</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3596')">Proof.</div>
<div class="proofscript" id="proof3596">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">starts_with</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">try</span> (<span class="tactic">intros</span>; <span class="tactic">discriminate</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_left</span> <span class="kwd">with</span> <span class="id">E0</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">c1</span> <span class="id">ls</span> <span class="id">m</span>) <span class="id">E0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">lbl</span> <span class="id">l</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">l</span>. <span class="tactic">replace</span> <span class="id">c3</span> <span class="kwd">with</span> <span class="id">c1</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">find_label_unique</span> <span class="kwd">with</span> <span class="id">lbl</span> <span class="id">c2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_star</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHc1</span> <span class="kwd">with</span> <span class="id">c2</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">is_tail_cons_left</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">traceEq</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Connection between <span class="bracket"><span class="id">find_label</span></span> and linearization. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_add_branch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">k</span> <span class="id">s</span>,<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> (<span class="id">add_branch</span> <span class="id">s</span> <span class="id">k</span>) = <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3597')">Proof.</div>
<div class="proofscript" id="proof3597">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">add_branch</span>. <span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">s</span> <span class="id">k</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_lin_block</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">k</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>) = <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3598')">Proof.</div>
<div class="proofscript" id="proof3598">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">lbl</span> <span class="id">k</span>. <span class="tactic">generalize</span> (<span class="id">find_label_add_branch</span> <span class="id">lbl</span> <span class="id">k</span>); <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">b</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">starts_with</span> <span class="id">s1</span> <span class="id">k</span>); <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">linearize_body_cons</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">enum</span>,<br/>
&nbsp;&nbsp;<span class="id">linearize_body</span> <span class="id">f</span> (<span class="id">pc</span> :: <span class="id">enum</span>) =<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">b</span> =&gt; <span class="id">Llabel</span> <span class="id">pc</span> :: <span class="id">linearize_block</span> <span class="id">b</span> (<span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3599')">Proof.</div>
<div class="proofscript" id="proof3599">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">linearize_body</span>. <span class="tactic">rewrite</span> <span class="id">list_fold_right_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">linearize_node</span>. <span class="tactic">destruct</span> (<span class="id">LTL.fn_code</span> <span class="id">f</span>)!<span class="id">pc</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_lin_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">enum</span> <span class="id">pc</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">pc</span> <span class="id">enum</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>, <span class="id">find_label</span> <span class="id">pc</span> (<span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span>) = <span class="id">Some</span> (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3600')">Proof.</div>
<div class="proofscript" id="proof3600">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">enum</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">linearize_body_cons</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">a</span> <span class="id">pc</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="id">exists</span> (<span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">peq_true</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">In</span> <span class="id">pc</span> <span class="id">enum</span>). <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IHenum</span> <span class="id">pc</span> <span class="id">b</span> <span class="id">H1</span> <span class="id">H0</span>) <span class="kwd">as</span> [<span class="id">k</span> <span class="id">FIND</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>. <span class="tactic">destruct</span> (<span class="id">LTL.fn_code</span> <span class="id">f</span>)!<span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">peq_false</span>. <span class="tactic">rewrite</span> <span class="id">find_label_lin_block</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_lin</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">pc</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">pc</span> (<span class="id">fn_code</span> <span class="id">tf</span>) = <span class="id">Some</span> (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3601')">Proof.</div>
<div class="proofscript" id="proof3601">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">find_label_add_branch</span>. <span class="tactic">apply</span> <span class="id">find_label_lin_rec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">enumerate_complete</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_lin_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">pc</span> <span class="id">b</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">LTL.fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">pc</span> (<span class="id">fn_code</span> <span class="id">tf</span>) = <span class="id">Some</span> <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>', <span class="id">k</span> = <span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3602')">Proof.</div>
<div class="proofscript" id="proof3602">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">find_label_lin</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span>' <span class="id">FIND</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>'. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Unique label property for linearized code. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">label_in_add_branch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) (<span class="id">add_branch</span> <span class="id">s</span> <span class="id">k</span>) -&gt; <span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3603')">Proof.</div>
<div class="proofscript" id="proof3603">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">k</span>; <span class="tactic">unfold</span> <span class="id">add_branch</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">s</span> <span class="id">k</span>); <span class="tactic">simpl</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">label_in_lin_block</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">k</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>) -&gt; <span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3604')">Proof.</div>
<div class="proofscript" id="proof3604">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">b</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">try</span> (<span class="tactic">intuition</span> <span class="tactic">congruence</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">label_in_add_branch</span> <span class="kwd">with</span> <span class="id">s</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">s1</span> <span class="id">k</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">label_in_add_branch</span> <span class="kwd">with</span> <span class="id">s1</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">label_in_add_branch</span> <span class="kwd">with</span> <span class="id">s2</span>; <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">label_in_lin_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">lbl</span> <span class="id">enum</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">Llabel</span> <span class="id">lbl</span>) (<span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span>) -&gt; <span class="id">In</span> <span class="id">lbl</span> <span class="id">enum</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3605')">Proof.</div>
<div class="proofscript" id="proof3605">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">enum</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">linearize_body_cons</span>. <span class="tactic">destruct</span> (<span class="id">LTL.fn_code</span> <span class="id">f</span>)!<span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">B</span>]. <span class="id">left</span>; <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">IHenum</span>. <span class="tactic">eapply</span> <span class="id">label_in_lin_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>; <span class="id">right</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">unique_labels_add_branch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> <span class="id">k</span> -&gt; <span class="id">unique_labels</span> (<span class="id">add_branch</span> <span class="id">lbl</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3606')">Proof.</div>
<div class="proofscript" id="proof3606">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">unfold</span> <span class="id">add_branch</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">lbl</span> <span class="id">k</span>); <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">unique_labels_lin_block</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">k</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> <span class="id">k</span> -&gt; <span class="id">unique_labels</span> (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3607')">Proof.</div>
<div class="proofscript" id="proof3607">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">b</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">auto</span>; <span class="tactic">try</span> (<span class="tactic">apply</span> <span class="id">unique_labels_add_branch</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">starts_with</span> <span class="id">s1</span> <span class="id">k</span>); <span class="tactic">simpl</span>; <span class="tactic">apply</span> <span class="id">unique_labels_add_branch</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">unique_labels_lin_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">enum</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">enum</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> (<span class="id">linearize_body</span> <span class="id">f</span> <span class="id">enum</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3608')">Proof.</div>
<div class="proofscript" id="proof3608">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">enum</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">linearize_body_cons</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">destruct</span> (<span class="id">LTL.fn_code</span> <span class="id">f</span>)!<span class="id">a</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">split</span>. <span class="tactic">red</span>. <span class="tactic">intro</span>. <span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">elim</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">label_in_lin_rec</span> <span class="kwd">with</span> <span class="id">f</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">label_in_lin_block</span> <span class="kwd">with</span> <span class="id">b</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">unique_labels_lin_block</span>. <span class="tactic">apply</span> <span class="id">IHenum</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHenum</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">unique_labels_transf_function</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">unique_labels</span> (<span class="id">fn_code</span> <span class="id">tf</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3609')">Proof.</div>
<div class="proofscript" id="proof3609">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">unique_labels_add_branch</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">unique_labels_lin_rec</span>. <span class="tactic">eapply</span> <span class="id">enumerate_norepet</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Correctness of <span class="bracket"><span class="id">add_branch</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c2</span> <span class="id">c1</span>,<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">c1</span> = <span class="id">Some</span> <span class="id">c2</span> -&gt; <span class="id">is_tail</span> <span class="id">c2</span> <span class="id">c1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3610')">Proof.</div>
<div class="proofscript" id="proof3610">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c1</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">is_label</span> <span class="id">lbl</span> <span class="id">a</span>). <span class="tactic">intro</span>. <span class="tactic">injection</span> <span class="id">H</span>; <span class="tactic">intro</span>. <span class="tactic">subst</span> <span class="id">c2</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_add_branch</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c1</span> <span class="id">c2</span>, <span class="id">is_tail</span> (<span class="id">add_branch</span> <span class="id">lbl</span> <span class="id">c1</span>) <span class="id">c2</span> -&gt; <span class="id">is_tail</span> <span class="id">c1</span> <span class="id">c2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3611')">Proof.</div>
<div class="proofscript" id="proof3611">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">c2</span>. <span class="tactic">unfold</span> <span class="id">add_branch</span>. <span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">lbl</span> <span class="id">c1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_lin_block</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">c1</span> <span class="id">c2</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">linearize_block</span> <span class="id">b</span> <span class="id">c1</span>) <span class="id">c2</span> -&gt; <span class="id">is_tail</span> <span class="id">c1</span> <span class="id">c2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3612')">Proof.</div>
<div class="proofscript" id="proof3612">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">b</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_add_branch</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">s1</span> <span class="id">c1</span>); <span class="tactic">eapply</span> <span class="id">is_tail_add_branch</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">add_branch_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c</span> <span class="id">k</span> <span class="id">s</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">k</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) = <span class="id">Some</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">tf</span> <span class="id">sp</span> (<span class="id">add_branch</span> <span class="id">lbl</span> <span class="id">k</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">tf</span> <span class="id">sp</span> <span class="id">c</span> <span class="id">ls</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3613')">Proof.</div>
<div class="proofscript" id="proof3613">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">add_branch</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">starts_with</span> <span class="id">lbl</span> <span class="id">k</span>); <span class="tactic">intro</span> <span class="id">SW</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">starts_with_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">unique_labels_transf_function</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">exec_Lgoto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of linearization </h1>
<br/>
<div class="doc">The proof of semantic preservation is a simulation argument of the "star" kind:
<pre>
           st1 --------------- st2
            |                   |
           t|                  t| + or ( 0 \/ |st1'| &lt; |st1| )
            |                   |
            v                   v
           st1'--------------- st2'</pre>
  The invariant (horizontal lines above) is the <span class="bracket"><span class="id">match_states</span></span>
  predicate defined below.  It captures the fact that the flow
  of data is the same in the source and linearized codes.
  Moreover, whenever the source state is at node <span class="bracket"><span class="id">pc</span></span> in its
  control-flow graph, the transformed state is at a code
  sequence <span class="bracket"><span class="id">c</span></span> that starts with the label <span class="bracket"><span class="id">pc</span></span>. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stackframes</span>: <span class="id">LTL.stackframe</span> -&gt; <span class="id">Linear.stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stackframe_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">tf</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">pc</span>, <span class="id">In</span> <span class="id">pc</span> (<span class="id">successors_block</span> <span class="id">bb</span>) -&gt; (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">c</span> <span class="id">tf</span>.(<span class="id">fn_code</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LTL.Stackframe</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">bb</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.Stackframe</span> <span class="id">tf</span> <span class="id">sp</span> <span class="id">ls</span> (<span class="id">linearize_block</span> <span class="id">bb</span> <span class="id">c</span>)).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">LTL.state</span> -&gt; <span class="id">Linear.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_add_branch</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REACH</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TAIL</span>: <span class="id">is_tail</span> <span class="id">c</span> <span class="id">tf</span>.(<span class="id">fn_code</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.State</span> <span class="id">ts</span> <span class="id">tf</span> <span class="id">sp</span> (<span class="id">add_branch</span> <span class="id">pc</span> <span class="id">c</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_cond_taken</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REACH</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">JUMP</span>: <span class="id">eval_condition</span> <span class="id">cond</span> (<span class="id">reglist</span> <span class="id">ls</span> <span class="id">args</span>) <span class="id">m</span> = <span class="id">Some</span> <span class="id">true</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> (<span class="id">undef_regs</span> (<span class="id">destroyed_by_cond</span> <span class="id">cond</span>) <span class="id">ls</span>) <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.State</span> <span class="id">ts</span> <span class="id">tf</span> <span class="id">sp</span> (<span class="id">Lcond</span> <span class="id">cond</span> <span class="id">args</span> <span class="id">pc</span> :: <span class="id">c</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_jumptable</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">arg</span> <span class="id">tbl</span> <span class="id">c</span> <span class="id">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REACH</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARG</span>: <span class="id">ls</span> (<span class="id">R</span> <span class="id">arg</span>) = <span class="id">Vint</span> <span class="id">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">JUMP</span>: <span class="id">list_nth_z</span> <span class="id">tbl</span> (<span class="id">Int.unsigned</span> <span class="id">n</span>) = <span class="id">Some</span> <span class="id">pc</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> (<span class="id">undef_regs</span> <span class="id">destroyed_by_jumptable</span> <span class="id">ls</span>) <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.State</span> <span class="id">ts</span> <span class="id">tf</span> <span class="id">sp</span> (<span class="id">Ljumptable</span> <span class="id">arg</span> <span class="id">tbl</span> :: <span class="id">c</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_block</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span> <span class="id">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">REACH</span>: <span class="kwd">forall</span> <span class="id">pc</span>, <span class="id">In</span> <span class="id">pc</span> (<span class="id">successors_block</span> <span class="id">bb</span>) -&gt; (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TAIL</span>: <span class="id">is_tail</span> <span class="id">c</span> <span class="id">tf</span>.(<span class="id">fn_code</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.State</span> <span class="id">ts</span> <span class="id">tf</span> <span class="id">sp</span> (<span class="id">linearize_block</span> <span class="id">bb</span> <span class="id">c</span>) <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">tf</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.Callstate</span> <span class="id">ts</span> <span class="id">tf</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">ts</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">LTL.Returnstate</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.Returnstate</span> <span class="id">ts</span> <span class="id">ls</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">S</span>: <span class="id">LTL.state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">S</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">LTL.State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">ls</span> <span class="id">m</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">LTL.Block</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">bb</span> <span class="id">ls</span> <span class="id">m</span> =&gt; 1%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">match_parent_locset</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">ts</span>, <span class="id">list_forall2</span> <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">ts</span> -&gt; <span class="id">parent_locset</span> <span class="id">ts</span> = <span class="id">LTL.parent_locset</span> <span class="id">s</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3614')">Proof.</div>
<div class="proofscript" id="proof3614">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>. <span class="tactic">auto</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span>, <span class="id">LTL.step</span> <span class="id">ge</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">s1</span> <span class="id">s1</span>'),<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">s2</span>', <span class="id">plus</span> <span class="id">Linear.step</span> <span class="id">tge</span> <span class="id">s1</span>' <span class="id">t</span> <span class="id">s2</span>' /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s2</span>')<br/>
&nbsp;&nbsp;\/ (<span class="kwd">measure</span> <span class="id">s2</span> &lt; <span class="kwd">measure</span> <span class="id">s1</span> /\ <span class="id">t</span> = <span class="id">E0</span> /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s1</span>')%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3615')">Proof.</div>
<div class="proofscript" id="proof3615">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="tactic">try</span> (<span class="id">inv</span> <span class="id">MS</span>).<br/>
<br/>
&nbsp;start&nbsp;of&nbsp;block,&nbsp;at&nbsp;an&nbsp;[add_branch]&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_label_lin</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span> <span class="id">F</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">add_branch_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">reachable_successors</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_lin_block</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">is_tail_find_label</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;start&nbsp;of&nbsp;block,&nbsp;target&nbsp;of&nbsp;an&nbsp;[Lcond]&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_label_lin</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span> <span class="id">F</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Lcond_true</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">reachable_successors</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_lin_block</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">is_tail_find_label</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;start&nbsp;of&nbsp;block,&nbsp;target&nbsp;of&nbsp;an&nbsp;[Ljumptable]&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_label_lin</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span> <span class="id">F</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Ljumptable</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">reachable_successors</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_lin_block</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">is_tail_find_label</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">v</span>); <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lload&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">a</span>). <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lgetstack&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lsetstack&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lstore&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">a</span>). <span class="tactic">rewrite</span> &lt;- <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lcall&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tfd</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Ltailcall&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tfd</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_parent_locset</span> <span class="id">_</span> <span class="id">_</span> <span class="id">STACKS</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">stacksize_preserved</span> <span class="id">_</span> <span class="id">_</span> <span class="id">TRF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_parent_locset</span> <span class="id">_</span> <span class="id">_</span> <span class="id">STACKS</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lbuiltin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Lbuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lbranch&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>). <span class="tactic">apply</span> <span class="id">REACH</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lcond&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">REACH1</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc1</span> = <span class="id">true</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">REACH</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">REACH2</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc2</span> = <span class="id">true</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">REACH</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">linearize_block</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">starts_with</span> <span class="id">pc1</span> <span class="id">c</span>).<br/>
&nbsp;branch&nbsp;if&nbsp;cond&nbsp;is&nbsp;false&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">DC</span>: <span class="id">destroyed_by_cond</span> (<span class="id">negate_condition</span> <span class="id">cond</span>) = <span class="id">destroyed_by_cond</span> <span class="id">cond</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cond</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>.<br/>
&nbsp;cond&nbsp;is&nbsp;true:&nbsp;no&nbsp;branch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Lcond_false</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">eval_negate_condition</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">DC</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;cond&nbsp;is&nbsp;false:&nbsp;branch&nbsp;is&nbsp;taken&nbsp;*)</span>&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.  <span class="tactic">rewrite</span> &lt;- <span class="id">DC</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">eval_negate_condition</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;branch&nbsp;if&nbsp;cond&nbsp;is&nbsp;true&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">b</span>.<br/>
&nbsp;cond&nbsp;is&nbsp;true:&nbsp;branch&nbsp;is&nbsp;taken&nbsp;*)</span>&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;cond&nbsp;is&nbsp;false:&nbsp;no&nbsp;branch&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Lcond_false</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Ljumptable&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">REACH</span>': (<span class="id">reachable</span> <span class="id">f</span>)!!<span class="id">pc</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">REACH</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">list_nth_z_in</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Lreturn&nbsp;*)</span>&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">stacksize_preserved</span> <span class="id">_</span> <span class="id">_</span> <span class="id">TRF</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_parent_locset</span> <span class="id">_</span> <span class="id">_</span> <span class="id">STACKS</span>). <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;internal&nbsp;functions&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">REACH</span>: (<span class="id">reachable</span> <span class="id">f</span>)!!(<span class="id">LTL.fn_entrypoint</span> <span class="id">f</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">reachable_entrypoint</span>.<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">stacksize_preserved</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">EQ</span>; <span class="tactic">intro</span> <span class="id">EQ</span>'; <span class="id">monadInv</span> <span class="id">EQ</span>'. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">is_tail_add_branch</span>. <span class="id">constructor</span>.<br/>
<br/>
&nbsp;external&nbsp;function&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">H8</span>. <span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>. <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">LTL.initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">Linear.initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3616')">Proof.</div>
<div class="proofscript" id="proof3616">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">nil</span> <span class="id">tf</span> (<span class="id">Locmap.init</span> <span class="id">Vundef</span>) <span class="id">m0</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> (<span class="id">Genv.init_mem_transf_partial</span> <span class="id">TRANSF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_program_main</span> <span class="id">TRANSF</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">LTL.final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">Linear.final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3617')">Proof.</div>
<div class="proofscript" id="proof3617">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H5</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">LTL.semantics</span> <span class="id">prog</span>) (<span class="id">Linear.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3618')">Proof.</div>
<div class="proofscript" id="proof3618">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_star</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_final_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_step_correct</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">LINEARIZATION</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
