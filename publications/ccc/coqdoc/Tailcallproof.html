<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Tailcallproof</title>
<meta name="description" content="Documentation of Coq module Tailcallproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Tailcallproof</h1>
<div class="coq">
<br/>
<div class="doc">Recognition of tail calls: correctness proof </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Integers</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Op</span> <span class="id">Registers</span> <span class="id">RTL</span> <span class="id">Conventions</span> <span class="id">Tailcall</span>.<br/>
<br/>
<h1> Syntactic properties of the code transformation </h1>
<br/>
<h2> Measuring the number of instructions eliminated </h2>
<br/>
<div class="doc">The <span class="bracket"><span class="id">return_measure</span> <span class="id">c</span> <span class="id">pc</span></span> function counts the number of instructions
  eliminated by the code transformation, where <span class="bracket"><span class="id">pc</span></span> is the successor
  of a call turned into a tailcall.  This is the length of the
  move/nop/return sequence recognized by the <span class="bracket"><span class="id">is_return</span></span> boolean function.
</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">return_measure_rec</span> (<span class="id">n</span>: <span class="id">nat</span>) (<span class="id">c</span>: <span class="id">code</span>) (<span class="id">pc</span>: <span class="id">node</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="kwd">struct</span> <span class="id">n</span>}: <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">n</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">O</span> =&gt; <span class="id">O</span><br/>
&nbsp;&nbsp;| <span class="id">S</span> <span class="id">n</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span>!<span class="id">pc</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Inop</span> <span class="id">s</span>) =&gt; <span class="id">S</span>(<span class="id">return_measure_rec</span> <span class="id">n</span>' <span class="id">c</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">Iop</span> <span class="id">op</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">s</span>) =&gt; <span class="id">S</span>(<span class="id">return_measure_rec</span> <span class="id">n</span>' <span class="id">c</span> <span class="id">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">return_measure</span> (<span class="id">c</span>: <span class="id">code</span>) (<span class="id">pc</span>: <span class="id">node</span>) :=<br/>
&nbsp;&nbsp;<span class="id">return_measure_rec</span> <span class="id">niter</span> <span class="id">c</span> <span class="id">pc</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">return_measure_bounds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span>, (<span class="id">return_measure</span> <span class="id">f</span> <span class="id">pc</span> &lt;= <span class="id">niter</span>)%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2561')">Proof.</div>
<div class="proofscript" id="proof2561">
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">f</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">n</span> <span class="id">pc</span>, (<span class="id">return_measure_rec</span> <span class="id">n</span> <span class="id">f</span> <span class="id">pc</span> &lt;= <span class="id">n</span>)%<span class="id">nat</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f</span>!<span class="id">pc</span>); <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">IHn</span> <span class="id">n0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">IHn</span> <span class="id">n0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">return_measure</span>. <span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">return_measure_rec_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">n1</span> <span class="id">n2</span> <span class="id">pc</span>,<br/>
&nbsp;&nbsp;(<span class="id">n1</span> &lt;= <span class="id">n2</span>)%<span class="id">nat</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">return_measure_rec</span> <span class="id">n1</span> <span class="id">f</span> <span class="id">pc</span> &lt;= <span class="id">return_measure_rec</span> <span class="id">n2</span> <span class="id">f</span> <span class="id">pc</span>)%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2562')">Proof.</div>
<div class="proofscript" id="proof2562">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n1</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n2</span>. <span class="id">omegaContradiction</span>. <span class="tactic">assert</span> (<span class="id">n1</span> &lt;= <span class="id">n2</span>)%<span class="id">nat</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">f</span>!<span class="id">pc</span>; <span class="tactic">try</span> <span class="tactic">omega</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">IHn1</span> <span class="id">n2</span> <span class="id">n</span> <span class="id">H0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">IHn1</span> <span class="id">n2</span> <span class="id">n</span> <span class="id">H0</span>). <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_return_measure_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">n</span> <span class="id">n</span>' <span class="id">pc</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">is_return</span> <span class="id">n</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span> = <span class="id">true</span> -&gt; (<span class="id">n</span> &lt;= <span class="id">n</span>')%<span class="id">nat</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">return_measure_rec</span> <span class="id">n</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span> = <span class="id">return_measure_rec</span> <span class="id">n</span>' <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2563')">Proof.</div>
<div class="proofscript" id="proof2563">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">n</span>'. <span class="id">omegaContradiction</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">fn_code</span> <span class="id">f</span>)!<span class="id">pc</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">decEq</span>. <span class="tactic">apply</span> <span class="id">IHn</span> <span class="kwd">with</span> <span class="id">r</span>. <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">is_move_operation</span> <span class="id">o</span> <span class="id">l</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Reg.eq</span> <span class="id">r</span> <span class="id">r1</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">decEq</span>. <span class="tactic">apply</span> <span class="id">IHn</span> <span class="kwd">with</span> <span class="id">r0</span>. <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<h2> Relational characterization of the code transformation </h2>
<br/>
<div class="doc">The <span class="bracket"><span class="id">is_return_spec</span></span> characterizes the instruction sequences
  recognized by the <span class="bracket"><span class="id">is_return</span></span> boolean function.  </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">is_return_spec</span> (<span class="id">f</span>:<span class="id">function</span>): <span class="id">node</span> -&gt; <span class="id">reg</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">is_return_none</span>: <span class="kwd">forall</span> <span class="id">pc</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> <span class="id">None</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">is_return_some</span>: <span class="kwd">forall</span> <span class="id">pc</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span>(<span class="id">Ireturn</span> (<span class="id">Some</span> <span class="id">r</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">is_return_nop</span>: <span class="kwd">forall</span> <span class="id">pc</span> <span class="id">r</span> <span class="id">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span>(<span class="id">Inop</span> <span class="id">s</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">s</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">return_measure</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">s</span> &lt; <span class="id">return_measure</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span>)%<span class="id">nat</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">is_return_move</span>: <span class="kwd">forall</span> <span class="id">pc</span> <span class="id">r</span> <span class="id">r</span>' <span class="id">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span>(<span class="id">Iop</span> <span class="id">Omove</span> (<span class="id">r</span>::<span class="id">nil</span>) <span class="id">r</span>' <span class="id">s</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">s</span> <span class="id">r</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">return_measure</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">s</span> &lt; <span class="id">return_measure</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span>)%<span class="id">nat</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_return_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">n</span> <span class="id">pc</span> <span class="id">rret</span>,<br/>
&nbsp;&nbsp;<span class="id">is_return</span> <span class="id">n</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">rret</span> = <span class="id">true</span> -&gt; (<span class="id">n</span> &lt;= <span class="id">niter</span>)%<span class="id">nat</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">rret</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2564')">Proof.</div>
<div class="proofscript" id="proof2564">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">n</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> ((<span class="id">fn_code</span> <span class="id">f</span>)!<span class="id">pc</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">i</span>. <span class="id">caseEq</span> <span class="id">i</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">s</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">is_return_nop</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">IHn</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">return_measure</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">is_return_measure_rec</span> <span class="id">f</span> (<span class="id">S</span> <span class="id">n</span>) <span class="id">niter</span> <span class="id">pc</span> <span class="id">rret</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">is_return_measure_rec</span> <span class="id">f</span> <span class="id">n</span> <span class="id">niter</span> <span class="id">s</span> <span class="id">rret</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">op</span> <span class="id">args</span> <span class="id">dst</span> <span class="id">s</span> <span class="id">EQ1</span> <span class="id">EQ2</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">is_move_operation</span> <span class="id">op</span> <span class="id">args</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">src</span> <span class="id">IMO</span>. <span class="tactic">destruct</span> (<span class="id">Reg.eq</span> <span class="id">rret</span> <span class="id">src</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">rret</span>. <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">is_move_operation_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_return_move</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">IHn</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">return_measure</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">is_return_measure_rec</span> <span class="id">f</span> (<span class="id">S</span> <span class="id">n</span>) <span class="id">niter</span> <span class="id">pc</span> <span class="id">src</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">is_return_measure_rec</span> <span class="id">f</span> <span class="id">n</span> <span class="id">niter</span> <span class="id">s</span> <span class="id">dst</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">EQ2</span>. <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">or</span> <span class="id">EQ1</span> <span class="id">EQ2</span>. <span class="tactic">destruct</span> <span class="id">or</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">r</span> = <span class="id">rret</span>). <span class="tactic">eapply</span> <span class="id">proj_sumbool_true</span>; <span class="tactic">eauto</span>. <span class="tactic">subst</span> <span class="id">r</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_return_some</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_return_none</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The <span class="bracket"><span class="id">transf_instr_spec</span></span> predicate relates one instruction in the
  initial code with its possible transformations in the optimized code. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">transf_instr_spec</span> (<span class="id">f</span>: <span class="id">function</span>): <span class="id">instruction</span> -&gt; <span class="id">instruction</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">transf_instr_tailcall</span>: <span class="kwd">forall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>) = 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">s</span> <span class="id">res</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transf_instr_spec</span> <span class="id">f</span> (<span class="id">Icall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span> <span class="id">res</span> <span class="id">s</span>) (<span class="id">Itailcall</span> <span class="id">sig</span> <span class="id">ros</span> <span class="id">args</span>)<br/>
&nbsp;&nbsp;| <span class="id">transf_instr_default</span>: <span class="kwd">forall</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transf_instr_spec</span> <span class="id">f</span> <span class="id">i</span> <span class="id">i</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_instr_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">instr</span>,<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>) = 0 -&gt;<br/>
&nbsp;&nbsp;<span class="id">transf_instr_spec</span> <span class="id">f</span> <span class="id">instr</span> (<span class="id">transf_instr</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">instr</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2565')">Proof.</div>
<div class="proofscript" id="proof2565">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">transf_instr</span>. <span class="tactic">destruct</span> <span class="id">instr</span>; <span class="tactic">try</span> <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">is_return</span> <span class="id">niter</span> <span class="id">f</span> <span class="id">n</span> <span class="id">r</span> &amp;&amp; <span class="id">tailcall_is_possible</span> <span class="id">s</span> &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">opt_typ_eq</span> (<span class="id">sig_res</span> <span class="id">s</span>) (<span class="id">sig_res</span> (<span class="id">fn_sig</span> <span class="id">f</span>))); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>). <span class="tactic">destruct</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transf_instr_tailcall</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_return_charact</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_instr_lookup</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">i</span>,<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">i</span>',  (<span class="id">transf_function</span> <span class="id">f</span>).(<span class="id">fn_code</span>)!<span class="id">pc</span> = <span class="id">Some</span> <span class="id">i</span>' /\ <span class="id">transf_instr_spec</span> <span class="id">f</span> <span class="id">i</span> <span class="id">i</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2566')">Proof.</div>
<div class="proofscript" id="proof2566">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">fn_stacksize</span> <span class="id">f</span>) 0).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gmap</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">transf_instr</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">i</span>); <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">transf_instr_charact</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">i</span>; <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<h1> Semantic properties of the code transformation </h1>
<br/>
<h2> The ``less defined than'' relation between register states </h2>
<br/>
<div class="doc">A call followed by a return without an argument can be turned
  into a tail call.  In this case, the original function returns
  <span class="bracket"><span class="id">Vundef</span></span>, while the transformed function can return any value.
  We account for this situation by using the ``less defined than''
  relation between values and between memory states.  We need to
  extend it pointwise to register states. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">regs_lessdef_init_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">params</span> <span class="id">vl</span> <span class="id">vl</span>',<br/>
&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">vl</span> <span class="id">vl</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">regs_lessdef</span> (<span class="id">init_regs</span> <span class="id">vl</span> <span class="id">params</span>) (<span class="id">init_regs</span> <span class="id">vl</span>' <span class="id">params</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2567')">Proof.</div>
<div class="proofscript" id="proof2567">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">params</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">inv</span> <span class="id">H</span>.   <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gi</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Proof of semantic preservation </h1>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span> <span class="id">tp</span>: <span class="id">RTL.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">tf</span> = <span class="id">transf_fundef</span> <span class="id">f</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span>, <span class="id">match_prog</span> <span class="id">p</span> (<span class="id">transf_program</span> <span class="id">p</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2568')">Proof.</div>
<div class="proofscript" id="proof2568">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_transform_program</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span> <span class="id">tprog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">f</span>: <span class="id">RTL.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> (<span class="id">transf_fundef</span> <span class="id">f</span>).<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">funct_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">f</span>: <span class="id">RTL.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> (<span class="id">transf_fundef</span> <span class="id">f</span>).<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_transf</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">funsig</span> (<span class="id">transf_fundef</span> <span class="id">f</span>) = <span class="id">funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2569')">Proof.</div>
<div class="proofscript" id="proof2569">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">fn_stacksize</span> <span class="id">f</span>) 0); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stacksize_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span>, <span class="id">fn_stacksize</span> (<span class="id">transf_function</span> <span class="id">f</span>) = <span class="id">fn_stacksize</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2570')">Proof.</div>
<div class="proofscript" id="proof2570">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_function</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">fn_stacksize</span> <span class="id">f</span>) 0); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ros</span> <span class="id">rs</span> <span class="id">rs</span>' <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">rs</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_function</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">rs</span>' = <span class="id">Some</span> (<span class="id">transf_fundef</span> <span class="id">f</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2571')">Proof.</div>
<div class="proofscript" id="proof2571">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">f</span>; <span class="tactic">destruct</span> <span class="id">ros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs</span>'#<span class="id">r</span> = <span class="id">rs</span>#<span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Genv.find_funct_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> <span class="id">EQ</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">H0</span> <span class="id">r</span>). <span class="tactic">rewrite</span> <span class="id">EQ</span>. <span class="tactic">intro</span> <span class="id">LD</span>. <span class="id">inv</span> <span class="id">LD</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">functions_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">funct_ptr_translated</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Consider an execution of a call/move/nop/return sequence in the
  original code and the corresponding tailcall in the transformed code.
  The transition sequences are of the following form
  (left: original code, right: transformed code).
  <span class="bracket"><span class="id">f</span></span> is the calling function and <span class="bracket"><span class="id">fd</span></span> the called function.
<pre>
     State stk f (Icall instruction)       State stk' f' (Itailcall)

     Callstate (frame::stk) fd args        Callstate stk' fd' args'
            .                                       .
            .                                       .
            .                                       .
     Returnstate (frame::stk) res          Returnstate stk' res'

     State stk f (move/nop/return seq)
            .
            .
            .
     State stk f (return instr)

     Returnstate stk res</pre>
The simulation invariant must therefore account for two kinds of
mismatches between the transition sequences:
<ul>
<li>
 The call stack of the original program can contain more frames
  than that of the transformed program (e.g. <span class="bracket"><span class="id">frame</span></span> in the example above).
</li>
<li>
 The regular states corresponding to executing the move/nop/return
  sequence must all correspond to the single <span class="bracket"><span class="id">Returnstate</span> <span class="id">stk</span>' <span class="id">res</span>'</span>
  state of the transformed program.
</li>
</ul>
We first define the simulation invariant between call stacks.
The first two cases are standard, but the third case corresponds
to a frame that was eliminated by the transformation. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stackframes</span>: <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">nil</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_normal</span>: <span class="kwd">forall</span> <span class="id">stk</span> <span class="id">stk</span>' <span class="id">res</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">rs</span>' <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">stk</span> <span class="id">stk</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> :: <span class="id">stk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span>' :: <span class="id">stk</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_stackframes_tail</span>: <span class="kwd">forall</span> <span class="id">stk</span> <span class="id">stk</span>' <span class="id">res</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">stk</span> <span class="id">stk</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">res</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>) = 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">res</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> :: <span class="id">stk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">stk</span>'.<br/>
<br/>
<div class="doc">Here is the invariant relating two states.  The first three
  cases are standard.  Note the ``less defined than'' conditions
  over values and register states, and the corresponding ``extends''
  relation over memory states. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_normal</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">rs</span>' <span class="id">m</span>' <span class="id">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RLD</span>: <span class="id">regs_lessdef</span> <span class="id">rs</span> <span class="id">rs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MLD</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">f</span> <span class="id">args</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">args</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.lessdef_list</span> <span class="id">args</span> <span class="id">args</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">args</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">s</span>' (<span class="id">transf_fundef</span> <span class="id">f</span>) <span class="id">args</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">v</span>' <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.lessdef</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Returnstate</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">s</span>' <span class="id">v</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_interm</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">s</span>' <span class="id">m</span>' <span class="id">f</span> <span class="id">r</span> <span class="id">v</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stackframes</span> <span class="id">s</span> <span class="id">s</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MLD</span>: <span class="id">Mem.extends</span> <span class="id">m</span> <span class="id">m</span>'),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_return_spec</span> <span class="id">f</span> <span class="id">pc</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">fn_stacksize</span>) = 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.lessdef</span> (<span class="id">rs</span>#<span class="id">r</span>) <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">State</span> <span class="id">s</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">s</span>' <span class="id">v</span>' <span class="id">m</span>').<br/>
<br/>
<div class="doc">The last case of <span class="bracket"><span class="id">match_states</span></span> corresponds to the execution
  of a move/nop/return sequence in the original code that was
  eliminated by the transformation:
<pre>
     State stk f (move/nop/return seq)  ~~  Returnstate stk' res'
            .
            .
            .
     State stk f (return instr)         ~~  Returnstate stk' res'</pre>
  To preserve non-terminating behaviors, we need to make sure
  that the execution of this sequence in the original code cannot
  diverge.  For this, we introduce the following complicated
  measure over states, which will decrease strictly whenever
  the original code makes a transition but the transformed code
  does not. </div>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">st</span>: <span class="id">state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">s</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">pc</span> <span class="id">rs</span> <span class="id">m</span> =&gt; (<span class="id">List.length</span> <span class="id">s</span> * (<span class="id">niter</span> + 2) + <span class="id">return_measure</span> <span class="id">f</span>.(<span class="id">fn_code</span>) <span class="id">pc</span> + 1)%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Callstate</span> <span class="id">s</span> <span class="id">f</span> <span class="id">args</span> <span class="id">m</span> =&gt; 0%<span class="id">nat</span><br/>
&nbsp;&nbsp;| <span class="id">Returnstate</span> <span class="id">s</span> <span class="id">v</span> <span class="id">m</span> =&gt; (<span class="id">List.length</span> <span class="id">s</span> * (<span class="id">niter</span> + 2))%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">TransfInstr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H</span>: (<span class="id">PTree.get</span> <span class="id">_</span> (<span class="id">fn_code</span> <span class="id">_</span>) = <span class="id">_</span>) |- <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">transf_instr_lookup</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> [<span class="id">i</span>' [<span class="id">TINSTR</span> <span class="id">TSPEC</span>]]; <span class="id">inv</span> <span class="id">TSPEC</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">EliminatedInstr</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">H</span>: (<span class="id">is_return_spec</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span>) |- <span class="id">_</span> =&gt; <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">try</span> <span class="tactic">congruence</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The proof of semantic preservation, then, is a simulation diagram
  of the ``option'' kind. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span>, <span class="id">step</span> <span class="id">ge</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">s1</span> <span class="id">s1</span>'),<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">s2</span>', <span class="id">step</span> <span class="id">tge</span> <span class="id">s1</span>' <span class="id">t</span> <span class="id">s2</span>' /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s2</span>')<br/>
&nbsp;&nbsp;\/ (<span class="kwd">measure</span> <span class="id">s2</span> &lt; <span class="kwd">measure</span> <span class="id">s1</span> /\ <span class="id">t</span> = <span class="id">E0</span> /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s1</span>')%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2572')">Proof.</div>
<div class="proofscript" id="proof2572">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">MS</span>; <span class="id">EliminatedInstr</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;nop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>. <span class="id">left</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Inop</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;eliminated&nbsp;nop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">s0</span> = <span class="id">pc</span>') <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">s0</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;op&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef_list</span> (<span class="id">rs</span>##<span class="id">args</span>) (<span class="id">rs</span>'##<span class="id">args</span>)). <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_operation_lessdef</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">EVAL</span>' <span class="id">VLD</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' (<span class="id">rs</span>'#<span class="id">res</span> &lt;- <span class="id">v</span>') <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iop</span>; <span class="tactic">eauto</span>.  <span class="tactic">rewrite</span> &lt;- <span class="id">EVAL</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
- <span class="comment">(*&nbsp;eliminated&nbsp;move&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">clear</span> <span class="id">H1</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">PMap.gss</span>. <span class="tactic">congruence</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;load&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef_list</span> (<span class="id">rs</span>##<span class="id">args</span>) (<span class="id">rs</span>'##<span class="id">args</span>)). <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">ADDR</span>' <span class="id">ALD</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">LOAD</span>' <span class="id">VLD</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' (<span class="id">rs</span>'#<span class="id">dst</span> &lt;- <span class="id">v</span>') <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Iload</span> <span class="kwd">with</span> (<span class="id">a</span> := <span class="id">a</span>'). <span class="tactic">eauto</span>.  <span class="tactic">rewrite</span> &lt;- <span class="id">ADDR</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;store&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Val.lessdef_list</span> (<span class="id">rs</span>##<span class="id">args</span>) (<span class="id">rs</span>'##<span class="id">args</span>)). <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_addressing_lessdef</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">a</span>' [<span class="id">ADDR</span>' <span class="id">ALD</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_extends</span>. 2: <span class="id">eexact</span> <span class="id">H1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">RLD</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">m</span>'1 [<span class="id">STORE</span>' <span class="id">MLD</span>']].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' <span class="id">rs</span>' <span class="id">m</span>'1); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Istore</span> <span class="kwd">with</span> (<span class="id">a</span> := <span class="id">a</span>'). <span class="tactic">eauto</span>.  <span class="tactic">rewrite</span> &lt;- <span class="id">ADDR</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">FIND</span>'.<br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
+ <span class="comment">(*&nbsp;call&nbsp;turned&nbsp;tailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ({ <span class="id">m</span>'' | <span class="id">Mem.free</span> <span class="id">m</span>' <span class="id">sp0</span> 0 (<span class="id">fn_stacksize</span> (<span class="id">transf_function</span> <span class="id">f</span>)) = <span class="id">Some</span> <span class="id">m</span>''}).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.range_perm_free</span>. <span class="tactic">rewrite</span> <span class="id">stacksize_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">X</span> <span class="kwd">as</span> [<span class="id">m</span>'' <span class="id">FREE</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">s</span>' (<span class="id">transf_fundef</span> <span class="id">fd</span>) (<span class="id">rs</span>'##<span class="id">args</span>) <span class="id">m</span>''); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">eapply</span> <span class="id">match_stackframes_tail</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_right_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">stacksize_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H7</span>. <span class="tactic">intros</span>. <span class="id">omegaContradiction</span>.<br/>
+ <span class="comment">(*&nbsp;call&nbsp;that&nbsp;remains&nbsp;a&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">Callstate</span> (<span class="id">Stackframe</span> <span class="id">res</span> (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' <span class="id">rs</span>' :: <span class="id">s</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">transf_fundef</span> <span class="id">fd</span>) (<span class="id">rs</span>'##<span class="id">args</span>) <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icall</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;tailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">FIND</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m</span>'1 [<span class="id">FREE</span> <span class="id">EXT</span>]].<br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">s</span>' (<span class="id">transf_fundef</span> <span class="id">fd</span>) (<span class="id">rs</span>'##<span class="id">args</span>) <span class="id">m</span>'1); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Itailcall</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">stacksize_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>.  <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;builtin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (@<span class="id">eval_builtin_args_lessdef</span> <span class="id">_</span> <span class="id">ge</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>#<span class="id">r</span>) (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rs</span>'#<span class="id">r</span>)); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">vargs</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">m</span>'1 [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' (<span class="id">regmap_setres</span> <span class="id">res</span> <span class="id">v</span>' <span class="id">rs</span>') <span class="id">m</span>'1); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ibuiltin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">set_res_lessdef</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;cond&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) (<span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">ifso</span> <span class="kwd">else</span> <span class="id">ifnot</span>) <span class="id">rs</span>' <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Icond</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">eval_condition_lessdef</span> <span class="kwd">with</span> (<span class="id">rs</span>##<span class="id">args</span>) <span class="id">m</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">regs_lessdef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;jumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">State</span> <span class="id">s</span>' (<span class="id">transf_function</span> <span class="id">f</span>) (<span class="id">Vptr</span> <span class="id">sp0</span> <span class="id">Ptrofs.zero</span>) <span class="id">pc</span>' <span class="id">rs</span>' <span class="id">m</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">exec_Ijumptable</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">RLD</span> <span class="id">arg</span>). <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">intro</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.free_parallel_extends</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">m</span>'1 [<span class="id">FREE</span> <span class="id">EXT</span>]].<br/>
&nbsp;&nbsp;<span class="id">TransfInstr</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">Returnstate</span> <span class="id">s</span>' (<span class="id">regmap_optget</span> <span class="id">or</span> <span class="id">Vundef</span> <span class="id">rs</span>') <span class="id">m</span>'1); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_Ireturn</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">stacksize_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">or</span>; <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">RLD</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;eliminated&nbsp;return&nbsp;None&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">or</span> = <span class="id">None</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">or</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_left_extends</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;eliminated&nbsp;return&nbsp;Some&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">or</span> = <span class="id">Some</span> <span class="id">r</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">or</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_left_extends</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := 0). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">fn_stacksize</span> <span class="id">f</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">m</span>'1 [<span class="id">ALLOC</span> <span class="id">EXT</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">fn_stacksize</span> (<span class="id">transf_function</span> <span class="id">f</span>) = <span class="id">fn_stacksize</span> <span class="id">f</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fn_entrypoint</span> (<span class="id">transf_function</span> <span class="id">f</span>) = <span class="id">fn_entrypoint</span> <span class="id">f</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fn_params</span> (<span class="id">transf_function</span> <span class="id">f</span>) = <span class="id">fn_params</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transf_function</span>. <span class="tactic">destruct</span> (<span class="id">zeq</span> (<span class="id">fn_stacksize</span> <span class="id">f</span>) 0); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">EQ1</span> [<span class="id">EQ2</span> <span class="id">EQ3</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">exec_function_internal</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">EQ1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">EQ2</span>. <span class="tactic">rewrite</span> <span class="id">EQ3</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">regs_lessdef_init_regs</span>. <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;call&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_extends</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">res</span>' [<span class="id">m2</span>' [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">exists</span> (<span class="id">Returnstate</span> <span class="id">s</span>' <span class="id">res</span>' <span class="id">m2</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;returnstate&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H2</span>.<br/>
+ <span class="comment">(*&nbsp;synchronous&nbsp;return&nbsp;in&nbsp;both&nbsp;programs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_return</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">set_reg_lessdef</span>; <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;return&nbsp;instr&nbsp;in&nbsp;source&nbsp;program,&nbsp;eliminated&nbsp;because&nbsp;of&nbsp;tailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">unfold</span> <span class="kwd">measure</span>. <span class="tactic">simpl</span> <span class="id">length</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">S</span> (<span class="id">length</span> <span class="id">s</span>) * (<span class="id">niter</span> + 2))%<span class="id">nat</span><br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> ((<span class="id">niter</span> + 2) + (<span class="id">length</span> <span class="id">s</span>) * (<span class="id">niter</span> + 2))%<span class="id">nat</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">return_measure_bounds</span> (<span class="id">fn_code</span> <span class="id">f</span>) <span class="id">pc</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2573')">Proof.</div>
<div class="proofscript" id="proof2573">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">funct_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">FIND</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Callstate</span> <span class="id">nil</span> (<span class="id">transf_fundef</span> <span class="id">f</span>) <span class="id">nil</span> <span class="id">m0</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> (<span class="id">Genv.init_mem_transf</span> <span class="id">TRANSL</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="kwd">with</span> (<span class="id">prog_main</span> <span class="id">prog</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">eapply</span> <span class="id">match_program_main</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H3</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">Mem.extends_refl</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2574')">Proof.</div>
<div class="proofscript" id="proof2574">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H5</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<br/>
<div class="doc">The preservation of the observable behavior of the program then
  follows. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">RTL.semantics</span> <span class="id">prog</span>) (<span class="id">RTL.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2575')">Proof.</div>
<div class="proofscript" id="proof2575">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_opt</span> <span class="kwd">with</span> (<span class="kwd">measure</span> := <span class="kwd">measure</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>. <br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transf_final_states</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">transf_step_correct</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
