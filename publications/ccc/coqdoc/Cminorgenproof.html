<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Cminorgenproof</title>
<meta name="description" content="Documentation of Coq module Cminorgenproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Cminorgenproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for Cminor generation. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Program.Equality</span> <span class="id">FSets</span> <span class="id">Permutation</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSets</span> <span class="id">FSetAVL</span> <span class="id">Orders</span> <span class="id">Mergesort</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Maps</span> <span class="id">Ordered</span> <span class="id">Errors</span> <span class="id">Integers</span> <span class="id">Floats</span>.<br/>
<span class="kwd">Require</span> <span class="id">Intv</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Csharpminor</span> <span class="id">Switch</span> <span class="id">Cminor</span> <span class="id">Cminorgen</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">error_monad_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">Csharpminor.program</span>) (<span class="id">tp</span>: <span class="id">Cminor.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">cu</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transl_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4547')">Proof.</div>
<div class="proofscript" id="proof4547">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_transform_partial_program</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">TRANSLATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Csharpminor.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSL</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> : <span class="id">Csharpminor.genv</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span>: <span class="id">genv</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">b</span>: <span class="id">block</span>) (<span class="id">f</span>: <span class="id">Csharpminor.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">f</span>: <span class="id">Csharpminor.fundef</span>),<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf_partial</span> <span class="id">TRANSL</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved_body</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">cenv</span> <span class="id">size</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">size</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tf</span>.(<span class="id">fn_sig</span>) = <span class="id">Csharpminor.fn_sig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4548')">Proof.</div>
<div class="proofscript" id="proof4548">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">transl_funbody</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Cminor.funsig</span> <span class="id">tf</span> = <span class="id">Csharpminor.funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4549')">Proof.</div>
<div class="proofscript" id="proof4549">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">tf</span>; <span class="tactic">destruct</span> <span class="id">f</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_function</span>. <span class="tactic">destruct</span> (<span class="id">build_compilenv</span> <span class="id">f</span>).<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">zle</span> <span class="id">z</span> <span class="id">Ptrofs.max_unsigned</span>); <span class="tactic">simpl</span> <span class="id">bind</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">sig_preserved_body</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<h1> Derived properties of memory operations </h1>
<br/>
<span class="kwd">Lemma</span> <span class="id">load_freelist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fbl</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>' <span class="id">lo</span> <span class="id">hi</span>, <span class="id">In</span> (<span class="id">b</span>', <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">fbl</span> -&gt; <span class="id">b</span>' &lt;&gt; <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">fbl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> = <span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4550')">Proof.</div>
<div class="proofscript" id="proof4550">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">fbl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">lo</span>] <span class="id">hi</span>].<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">H0</span>. <span class="tactic">simpl</span>. <span class="id">case_eq</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">lo</span> <span class="id">hi</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">m1</span> <span class="id">FR1</span> <span class="id">FRL</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Mem.load</span> <span class="id">chunk</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHfbl</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_free</span>; <span class="tactic">eauto</span>. <span class="id">left</span>. <span class="tactic">apply</span> <span class="id">sym_not_equal</span>. <span class="tactic">eapply</span> <span class="id">H</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">perm_freelist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fbl</span> <span class="id">m</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">fbl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4551')">Proof.</div>
<div class="proofscript" id="proof4551">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">fbl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">p</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">lo</span>] <span class="id">hi</span>]. <span class="id">case_eq</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">lo</span> <span class="id">hi</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nextblock_freelist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fbl</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">fbl</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.nextblock</span> <span class="id">m</span>' = <span class="id">Mem.nextblock</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4552')">Proof.</div>
<div class="proofscript" id="proof4552">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">fbl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">m</span>'; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span> <span class="id">lo</span>] <span class="id">hi</span>].<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>); <span class="tactic">intros</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>). <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.nextblock_free</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">free_list_freeable</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">m</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> <span class="id">l</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) <span class="id">l</span> -&gt; <span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">Cur</span> <span class="id">Freeable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4553')">Proof.</div>
<div class="proofscript" id="proof4553">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">lo</span>'] <span class="id">hi</span>'].<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">b</span>' <span class="id">lo</span>' <span class="id">hi</span>'); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">m1</span> <span class="id">FREE1</span> <span class="id">FREE2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_free_3</span>; <span class="tactic">eauto</span>. <span class="id">exploit</span> <span class="id">IHl</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">nextblock_storev</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">addr</span> <span class="id">v</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.storev</span> <span class="id">chunk</span> <span class="id">m</span> <span class="id">addr</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">m</span>' -&gt; <span class="id">Mem.nextblock</span> <span class="id">m</span>' = <span class="id">Mem.nextblock</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4554')">Proof.</div>
<div class="proofscript" id="proof4554">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Mem.storev</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">addr</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.nextblock_store</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Correspondence between C#minor's and Cminor's environments and memory states </h1>
<br/>
<div class="doc">In C#minor, every variable is stored in a separate memory block.
  In the corresponding Cminor code, these variables become sub-blocks
  of the stack data block.  We capture these changes in memory via a
  memory injection <span class="bracket"><span class="id">f</span></span>:
  <span class="bracket"><span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">ofs</span>)</span> means that C#minor block <span class="bracket"><span class="id">b</span></span> corresponds
  to a sub-block of Cminor block <span class="bracket"><span class="id">b</span></span> at offset <span class="bracket"><span class="id">ofs</span></span>.
  A memory injection <span class="bracket"><span class="id">f</span></span> defines a relation <span class="bracket"><span class="id">Val.inject</span> <span class="id">f</span></span> between
  values and a relation <span class="bracket"><span class="id">Mem.inject</span> <span class="id">f</span></span> between memory states.  These
  relations will be used intensively in our proof of simulation
  between C#minor and Cminor executions. </div>
<br/>
<h2> Matching between Cshaprminor's temporaries and Cminor's variables </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">match_temps</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">le</span>: <span class="id">Csharpminor.temp_env</span>) (<span class="id">te</span>: <span class="id">env</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">v</span>, <span class="id">le</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">exists</span> <span class="id">v</span>', <span class="id">te</span>!(<span class="id">id</span>) = <span class="id">Some</span> <span class="id">v</span>' /\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">v</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_temps_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">f</span>' <span class="id">le</span> <span class="id">te</span>,<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f</span> <span class="id">f</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span>' <span class="id">le</span> <span class="id">te</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4555')">Proof.</div>
<div class="proofscript" id="proof4555">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">H</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>) <span class="kwd">as</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_temps_assign</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">le</span> <span class="id">te</span> <span class="id">id</span> <span class="id">v</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span> <span class="id">le</span>) (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">tv</span> <span class="id">te</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4556')">Proof.</div>
<div class="proofscript" id="proof4556">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h2> Matching between C#minor's variable environment and Cminor's stack pointer </h2>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_var</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>): <span class="id">option</span> (<span class="id">block</span> * <span class="id">Z</span>) -&gt; <span class="id">option</span> <span class="id">Z</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_var_local</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">Ptrofs.zero</span>) (<span class="id">Vptr</span> <span class="id">sp</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_var</span> <span class="id">f</span> <span class="id">sp</span> (<span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>)) (<span class="id">Some</span> <span class="id">ofs</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_var_global</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_var</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">None</span> <span class="id">None</span>.<br/>
<br/>
<div class="doc">Matching between a C#minor environment <span class="bracket"><span class="id">e</span></span> and a Cminor
  stack pointer <span class="bracket"><span class="id">sp</span></span>. The <span class="bracket"><span class="id">lo</span></span> and <span class="bracket"><span class="id">hi</span></span> parameters delimit the range
  of addresses for the blocks referenced from <span class="bracket"><span class="id">te</span></span>. </div>
<br/>
<span class="kwd">Record</span> <span class="id">match_env</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">cenv</span>: <span class="id">compilenv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">e</span>: <span class="id">Csharpminor.env</span>) (<span class="id">sp</span>: <span class="id">block</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lo</span> <span class="id">hi</span>: <span class="id">block</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_match_env</span> {<br/>
<br/>
<div class="doc">C#minor local variables match sub-blocks of the Cminor stack data block. </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_vars</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">match_var</span> <span class="id">f</span> <span class="id">sp</span> (<span class="id">e</span>!<span class="id">id</span>) (<span class="id">cenv</span>!<span class="id">id</span>);<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">lo</span>, <span class="id">hi</span></span> is a proper interval. </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_low_high</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">lo</span> <span class="id">hi</span>;<br/>
<br/>
<div class="doc">Every block appearing in the C#minor environment <span class="bracket"><span class="id">e</span></span> must be
  in the range <span class="bracket"><span class="id">lo</span>, <span class="id">hi</span></span>. </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_bounded</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span>, <span class="id">PTree.get</span> <span class="id">id</span> <span class="id">e</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>) -&gt; <span class="id">Ple</span> <span class="id">lo</span> <span class="id">b</span> /\ <span class="id">Plt</span> <span class="id">b</span> <span class="id">hi</span>;<br/>
<br/>
<div class="doc">All blocks mapped to sub-blocks of the Cminor stack data must be
    images of variables from the C#minor environment <span class="bracket"><span class="id">e</span></span> </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_inv</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">id</span>, <span class="id">exists</span> <span class="id">sz</span>, <span class="id">PTree.get</span> <span class="id">id</span> <span class="id">e</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>);<br/>
<br/>
<div class="doc">All C#minor blocks below <span class="bracket"><span class="id">lo</span></span> (i.e. allocated before the blocks
  referenced from <span class="bracket"><span class="id">e</span></span>) must map to blocks that are below <span class="bracket"><span class="id">sp</span></span>
  (i.e. allocated before the stack data for the current Cminor function). </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">me_incr</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">tb</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">tb</span>, <span class="id">delta</span>) -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">lo</span> -&gt; <span class="id">Plt</span> <span class="id">tb</span> <span class="id">sp</span><br/>
&nbsp;&nbsp;}.<br/>
<br/>
<span class="kwd">Ltac</span> <span class="id">geninv</span> <span class="id">x</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">H</span> := <span class="tactic">fresh</span> <span class="kwd">in</span> (<span class="tactic">generalize</span> <span class="id">x</span>; <span class="tactic">intro</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">f2</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f1</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">delta</span>, <span class="id">f2</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">delta</span>) -&gt; <span class="id">f1</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">delta</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">lo</span> -&gt; <span class="id">f2</span> <span class="id">b</span> = <span class="id">f1</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f2</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4557')">Proof.</div>
<div class="proofscript" id="proof4557">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">geninv</span> (<span class="id">me_vars0</span> <span class="id">id</span>); <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;bounded&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;below&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_env</span></span> and external calls </div>
<br/>
<span class="kwd">Remark</span> <span class="id">inject_incr_separated_same</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>',<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt; <span class="id">inject_separated</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Mem.valid_block</span> <span class="id">m1</span> <span class="id">b</span> -&gt; <span class="id">f2</span> <span class="id">b</span> = <span class="id">f1</span> <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4558')">Proof.</div>
<div class="proofscript" id="proof4558">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">case_eq</span> (<span class="id">f1</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b</span>' <span class="id">delta</span>] <span class="id">EQ</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">EQ</span>. <span class="id">case_eq</span> (<span class="id">f2</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b</span>'1 <span class="id">delta1</span>] <span class="id">EQ1</span>. <span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">C</span> <span class="id">D</span>]. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">inject_incr_separated_same</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>',<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt; <span class="id">inject_separated</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>,<br/>
&nbsp;&nbsp;<span class="id">f2</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Mem.valid_block</span> <span class="id">m1</span>' <span class="id">b</span>' -&gt; <span class="id">f1</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4559')">Proof.</div>
<div class="proofscript" id="proof4559">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">case_eq</span> (<span class="id">f1</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b</span>'1 <span class="id">delta1</span>] <span class="id">EQ</span>. <span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">H0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">C</span> <span class="id">D</span>]. <span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_external_call</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>',<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f1</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_separated</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">hi</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) -&gt; <span class="id">Plt</span> <span class="id">sp</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f2</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4560')">Proof.</div>
<div class="proofscript" id="proof4560">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">match_env_invariant</span> <span class="kwd">with</span> <span class="id">f1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_separated_same</span>'; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">inject_incr_separated_same</span>; <span class="tactic">eauto</span>. <span class="tactic">red</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_env</span></span> and allocations </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_env_alloc</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">id</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">m1</span> <span class="id">sz</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">f2</span>,<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f1</span> (<span class="id">PTree.remove</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m1</span> 0 <span class="id">sz</span> = (<span class="id">m2</span>, <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f2</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>', <span class="id">b</span>' &lt;&gt; <span class="id">b</span> -&gt; <span class="id">f2</span> <span class="id">b</span>' = <span class="id">f1</span> <span class="id">b</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f2</span> <span class="id">cenv</span> (<span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">b</span>, <span class="id">sz</span>) <span class="id">e</span>) <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4561')">Proof.</div>
<div class="proofscript" id="proof4561">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">f2</span>; <span class="tactic">intros</span> <span class="id">ME</span> <span class="id">ALLOC</span> <span class="id">CENV</span> <span class="id">INCR</span> <span class="id">SAME</span> <span class="id">OTHER</span> <span class="id">ENV</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">NEXTBLOCK</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">RES</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">ME</span>; <span class="id">constructor</span>.<br/>
&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;the&nbsp;new&nbsp;var&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">id0</span>. <span class="tactic">rewrite</span> <span class="id">CENV</span>. <span class="id">constructor</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Ptrofs.add_commut</span>; <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>.<br/>
&nbsp;old&nbsp;vars&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">me_vars0</span> <span class="id">id0</span>). <span class="tactic">rewrite</span> <span class="id">PTree.gro</span>; <span class="tactic">auto</span>. <span class="tactic">intros</span> <span class="id">M</span>; <span class="id">inv</span> <span class="id">M</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;low-high&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">NEXTBLOCK</span>; <span class="id">xomega</span>.<br/>
&nbsp;bounded&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">NEXTBLOCK</span>; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_bounded0</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">NEXTBLOCK</span>; <span class="id">xomega</span>.<br/>
&nbsp;inv&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">rewrite</span> <span class="id">SAME</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">id</span>; <span class="id">exists</span> <span class="id">sz</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">OTHER</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="id">exploit</span> <span class="id">me_inv0</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">id1</span> [<span class="id">sz1</span> <span class="id">EQ</span>]]. <span class="id">exists</span> <span class="id">id1</span>; <span class="id">exists</span> <span class="id">sz1</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;incr&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">OTHER</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The sizes of blocks appearing in <span class="bracket"><span class="id">e</span></span> are respected. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">match_bounds</span> (<span class="id">e</span>: <span class="id">Csharpminor.env</span>) (<span class="id">m</span>: <span class="id">mem</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">ofs</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id</span> <span class="id">e</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>) -&gt; <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span> -&gt; 0 &lt;= <span class="id">ofs</span> &lt; <span class="id">sz</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_bounds_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">match_bounds</span> <span class="id">e</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">ofs</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id</span> <span class="id">e</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>) -&gt; <span class="id">Mem.perm</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_bounds</span> <span class="id">e</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4562')">Proof.</div>
<div class="proofscript" id="proof4562">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h2> Permissions on the Cminor stack block </h2>
<br/>
<div class="doc">The parts of the Cminor stack data block that are not images of
    C#minor local variable blocks remain freeable at all times. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">is_reachable_from_env</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">e</span>: <span class="id">Csharpminor.env</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">ofs</span>: <span class="id">Z</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">is_reachable_intro</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">delta</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">delta</span> &lt;= <span class="id">ofs</span> &lt; <span class="id">delta</span> + <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_reachable_from_env</span> <span class="id">f</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">padding_freeable</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">e</span>: <span class="id">Csharpminor.env</span>) (<span class="id">tm</span>: <span class="id">mem</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">sz</span>: <span class="id">Z</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">ofs</span> &lt; <span class="id">sz</span> -&gt; <span class="id">Mem.perm</span> <span class="id">tm</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">Cur</span> <span class="id">Freeable</span> \/ <span class="id">is_reachable_from_env</span> <span class="id">f</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">padding_freeable_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">e</span> <span class="id">tm1</span> <span class="id">sp</span> <span class="id">sz</span> <span class="id">cenv</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">f2</span> <span class="id">tm2</span>,<br/>
&nbsp;&nbsp;<span class="id">padding_freeable</span> <span class="id">f1</span> <span class="id">e</span> <span class="id">tm1</span> <span class="id">sp</span> <span class="id">sz</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_env</span> <span class="id">f1</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ofs</span>, <span class="id">Mem.perm</span> <span class="id">tm1</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">Cur</span> <span class="id">Freeable</span> -&gt; <span class="id">Mem.perm</span> <span class="id">tm2</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">Cur</span> <span class="id">Freeable</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">hi</span> -&gt; <span class="id">f2</span> <span class="id">b</span> = <span class="id">f1</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">padding_freeable</span> <span class="id">f2</span> <span class="id">e</span> <span class="id">tm2</span> <span class="id">sp</span> <span class="id">sz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4563')">Proof.</div>
<div class="proofscript" id="proof4563">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> | <span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="id">inv</span> <span class="id">A</span>. <span class="id">exploit</span> <span class="id">me_bounded</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">D</span> <span class="id">E</span>].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Decidability of the <span class="bracket"><span class="id">is_reachable_from_env</span></span> predicate. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_reachable_from_env_dec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span>, <span class="id">is_reachable_from_env</span> <span class="id">f</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span> \/ ~<span class="id">is_reachable_from_env</span> <span class="id">f</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4564')">Proof.</div>
<div class="proofscript" id="proof4564">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">pred</span> := <span class="kwd">fun</span> <span class="id">id_b_sz</span> : <span class="id">ident</span> * (<span class="id">block</span> * <span class="id">Z</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">id_b_sz</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id">id</span>, (<span class="id">b</span>, <span class="id">sz</span>)) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">f</span> <span class="id">b</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">sp</span>', <span class="id">delta</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">eq_block</span> <span class="id">sp</span> <span class="id">sp</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">zle</span> <span class="id">delta</span> <span class="id">ofs</span> &amp;&amp; <span class="id">zlt</span> <span class="id">ofs</span> (<span class="id">delta</span> + <span class="id">sz</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">List.existsb</span> <span class="id">pred</span> (<span class="id">PTree.elements</span> <span class="id">e</span>)) <span class="id">eqn</span>:?.<br/>
&nbsp;yes&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.existsb_exists</span> <span class="kwd">in</span> <span class="id">Heqb</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">Heqb</span> <span class="kwd">as</span> [[<span class="id">id</span> [<span class="id">b</span> <span class="id">sz</span>]] [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">B</span>. <span class="tactic">destruct</span> (<span class="id">f</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">sp</span>' <span class="id">delta</span>] |] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">sp</span> <span class="id">sp</span>'); <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">andb_prop</span> <span class="id">_</span> <span class="id">_</span> <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">apply</span> <span class="id">is_reachable_intro</span> <span class="kwd">with</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">delta</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.elements_complete</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">eapply</span> <span class="id">proj_sumbool_true</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;no&nbsp;*)</span>&nbsp;&nbsp;<span class="id">right</span>; <span class="tactic">red</span>; <span class="tactic">intro</span> <span class="id">NE</span>; <span class="id">inv</span> <span class="id">NE</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">existsb</span> <span class="id">pred</span> (<span class="id">PTree.elements</span> <span class="id">e</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.existsb_exists</span>. <span class="id">exists</span> (<span class="id">id</span>, (<span class="id">b</span>, <span class="id">sz</span>)); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">dec_eq_true</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">proj_sumbool</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">zle_true</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">zlt_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<h1> Correspondence between global environments </h1>
<br/>
<div class="doc">Global environments match if the memory injection <span class="bracket"><span class="id">f</span></span> leaves unchanged
  the references to global symbols and functions. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_globalenvs</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">bound</span>: <span class="id">block</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">mk_match_globalenvs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">DOMAIN</span>: <span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>, 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">IMAGE</span>: <span class="kwd">forall</span> <span class="id">b1</span> <span class="id">b2</span> <span class="id">delta</span>, <span class="id">f</span> <span class="id">b1</span> = <span class="id">Some</span>(<span class="id">b2</span>, <span class="id">delta</span>) -&gt; <span class="id">Plt</span> <span class="id">b2</span> <span class="id">bound</span> -&gt; <span class="id">b1</span> = <span class="id">b2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SYMBOLS</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">b</span>, <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span> = <span class="id">Some</span> <span class="id">b</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FUNCTIONS</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">fd</span>, <span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">VARINFOS</span>: <span class="kwd">forall</span> <span class="id">b</span> <span class="id">gv</span>, <span class="id">Genv.find_var_info</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">gv</span> -&gt; <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span>).<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">inj_preserves_globals</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">hi</span>,<br/>
&nbsp;&nbsp;<span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">hi</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">meminj_preserves_globals</span> <span class="id">ge</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4565')">Proof.</div>
<div class="proofscript" id="proof4565">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">DOMAIN</span>. <span class="tactic">eapply</span> <span class="id">SYMBOLS</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">DOMAIN</span>. <span class="tactic">eapply</span> <span class="id">VARINFOS</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">IMAGE</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Invariant on abstract call stacks  </h1>
<br/>
<div class="doc">Call stacks represent abstractly the execution state of the current
  C#minor and Cminor functions, as well as the states of the
  calling functions.  A call stack is a list of frames, each frame
  collecting information on the current execution state of a C#minor
  function and its Cminor translation. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">frame</span> : <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id">Frame</span>(<span class="id">cenv</span>: <span class="id">compilenv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tf</span>: <span class="id">Cminor.function</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">e</span>: <span class="id">Csharpminor.env</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">le</span>: <span class="id">Csharpminor.temp_env</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">te</span>: <span class="id">Cminor.env</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">sp</span>: <span class="id">block</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">lo</span> <span class="id">hi</span>: <span class="id">block</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">callstack</span> : <span class="kwd">Type</span> := <span class="id">list</span> <span class="id">frame</span>.<br/>
<br/>
<div class="doc">Matching of call stacks imply:
<ul>
<li>
 matching of environments for each of the frames
</li>
<li>
 matching of the global environments
</li>
<li>
 separation conditions over the memory blocks allocated for C#minor local variables;
</li>
<li>
 separation conditions over the memory blocks allocated for Cminor stack data;
</li>
<li>
 freeable permissions on the parts of the Cminor stack data blocks
  that are not images of C#minor local variable blocks.
</li>
</ul>
</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_callstack</span> (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">m</span>: <span class="id">mem</span>) (<span class="id">tm</span>: <span class="id">mem</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">callstack</span> -&gt; <span class="id">block</span> -&gt; <span class="id">block</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">mcs_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">hi</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">hi</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">hi</span> <span class="id">bound</span> -&gt; <span class="id">Ple</span> <span class="id">hi</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">nil</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;| <span class="id">mcs_cons</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BOUND</span>: <span class="id">Ple</span> <span class="id">hi</span> <span class="id">bound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TBOUND</span>: <span class="id">Plt</span> <span class="id">sp</span> <span class="id">tbound</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MTMP</span>: <span class="id">match_temps</span> <span class="id">f</span> <span class="id">le</span> <span class="id">te</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MENV</span>: <span class="id">match_env</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">BOUND</span>: <span class="id">match_bounds</span> <span class="id">e</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">PERM</span>: <span class="id">padding_freeable</span> <span class="id">f</span> <span class="id">e</span> <span class="id">tm</span> <span class="id">sp</span> <span class="id">tf</span>.(<span class="id">fn_stackspace</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">lo</span> <span class="id">sp</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>) <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_callstack</span></span> implies <span class="bracket"><span class="id">match_globalenvs</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_match_globalenvs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">hi</span>, <span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">hi</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4566')">Proof.</div>
<div class="proofscript" id="proof4566">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance properties for <span class="bracket"><span class="id">match_callstack</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_invariant</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm1</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm2</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm1</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">sp</span> <span class="id">ofs</span>, <span class="id">Plt</span> <span class="id">sp</span> <span class="id">tbound</span> -&gt; <span class="id">Mem.perm</span> <span class="id">tm1</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">Cur</span> <span class="id">Freeable</span> -&gt; <span class="id">Mem.perm</span> <span class="id">tm2</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">Cur</span> <span class="id">Freeable</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>, <span class="id">Plt</span> <span class="id">b</span> <span class="id">bound</span> -&gt; <span class="id">f2</span> <span class="id">b</span> = <span class="id">f1</span> <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">b</span>' <span class="id">delta</span>, <span class="id">f2</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>) -&gt; <span class="id">Plt</span> <span class="id">b</span>' <span class="id">tbound</span> -&gt; <span class="id">f1</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>', <span class="id">delta</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm2</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4567')">Proof.</div>
<div class="proofscript" id="proof4567">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IMAGE</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">H6</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Ple</span> <span class="id">lo</span> <span class="id">hi</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">me_low_high</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_temps_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H3</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_bounds_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_bounded</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">padding_freeable_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H3</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHmatch_callstack</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H1</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H2</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H3</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">H4</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_incr_bound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">bound</span>' <span class="id">tbound</span>',<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> <span class="id">bound</span>' -&gt; <span class="id">Ple</span> <span class="id">tbound</span> <span class="id">tbound</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">bound</span>' <span class="id">tbound</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4568')">Proof.</div>
<div class="proofscript" id="proof4568">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Assigning a temporary variable. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_set_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">tf</span> <span class="id">id</span> <span class="id">v</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>) <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">v</span> <span class="id">le</span>) (<span class="id">PTree.set</span> <span class="id">id</span> <span class="id">tv</span> <span class="id">te</span>) <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>) <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4569')">Proof.</div>
<div class="proofscript" id="proof4569">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_temps_assign</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation of <span class="bracket"><span class="id">match_callstack</span></span> by freeing all blocks allocated
  for local variables at function entry (on the C#minor side)
  and simultaneously freeing the Cminor stack data block. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">in_blocks_of_env</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">sz</span>) -&gt; <span class="id">In</span> (<span class="id">b</span>, 0, <span class="id">sz</span>) (<span class="id">blocks_of_env</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4570')">Proof.</div>
<div class="proofscript" id="proof4570">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> (<span class="id">b</span>, 0, <span class="id">sz</span>) <span class="kwd">with</span> (<span class="id">block_of_binding</span> (<span class="id">id</span>, (<span class="id">b</span>, <span class="id">sz</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">List.in_map</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_correct</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">in_blocks_of_env_inv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">b</span>, <span class="id">lo</span>, <span class="id">hi</span>) (<span class="id">blocks_of_env</span> <span class="id">e</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">id</span>, <span class="id">e</span>!<span class="id">id</span> = <span class="id">Some</span>(<span class="id">b</span>, <span class="id">hi</span>) /\ <span class="id">lo</span> = 0.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4571')">Proof.</div>
<div class="proofscript" id="proof4571">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">blocks_of_env</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">list_in_map_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [[<span class="id">id</span> [<span class="id">b</span>' <span class="id">sz</span>]] [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block_of_binding</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">inv</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">id</span>; <span class="tactic">intuition</span>. <span class="tactic">apply</span> <span class="id">PTree.elements_complete</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_freelist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">m</span> <span class="id">m</span>' <span class="id">tm</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free_list</span> <span class="id">m</span> (<span class="id">blocks_of_env</span> <span class="id">e</span>) = <span class="id">Some</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.free</span> <span class="id">tm</span> <span class="id">sp</span> 0 <span class="id">tf</span>.(<span class="id">fn_stackspace</span>) = <span class="id">Some</span> <span class="id">tm</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span>' <span class="id">tm</span>' <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>') (<span class="id">Mem.nextblock</span> <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span>' <span class="id">tm</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4572')">Proof.</div>
<div class="proofscript" id="proof4572">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">tm</span>; <span class="tactic">intros</span> <span class="id">INJ</span> <span class="id">FREELIST</span> <span class="id">MCS</span>. <span class="id">inv</span> <span class="id">MCS</span>. <span class="id">inv</span> <span class="id">MENV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ({<span class="id">tm</span>' | <span class="id">Mem.free</span> <span class="id">tm</span> <span class="id">sp</span> 0 (<span class="id">fn_stackspace</span> <span class="id">tf</span>) = <span class="id">Some</span> <span class="id">tm</span>'}).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.range_perm_free</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> | <span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">A</span>. <span class="tactic">assert</span> (<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">b</span> 0 <span class="id">sz</span> <span class="id">Cur</span> <span class="id">Freeable</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">free_list_freeable</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">in_blocks_of_env</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">ofs</span> <span class="kwd">with</span> ((<span class="id">ofs</span> - <span class="id">delta</span>) + <span class="id">delta</span>) <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.perm_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">H3</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">X</span> <span class="kwd">as</span>  [<span class="id">tm</span>' <span class="id">FREE</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">nextblock_freelist</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">NEXT</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_free</span>; <span class="tactic">eauto</span>. <span class="tactic">intro</span> <span class="id">NEXT</span>'.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tm</span>'. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">NEXT</span>; <span class="tactic">rewrite</span> <span class="id">NEXT</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_callstack_incr_bound</span> <span class="kwd">with</span> <span class="id">lo</span> <span class="id">sp</span>; <span class="tactic">try</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_callstack_invariant</span> <span class="kwd">with</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">perm_freelist</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_free_1</span>; <span class="tactic">eauto</span>. <span class="id">left</span>; <span class="tactic">unfold</span> <span class="id">block</span>; <span class="id">xomega</span>. <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.free_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">me_inv0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">id</span> [<span class="id">sz</span> <span class="id">A</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> 0; <span class="id">exists</span> <span class="id">sz</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">in_blocks_of_env</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">BOUND0</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_max</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation of <span class="bracket"><span class="id">match_callstack</span></span> by external calls. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_external_call</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">m1</span>' <span class="id">m2</span>',<br/>
&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> (<span class="id">loc_unmapped</span> <span class="id">f1</span>) <span class="id">m1</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.unchanged_on</span> (<span class="id">loc_out_of_reach</span> <span class="id">f1</span> <span class="id">m1</span>) <span class="id">m1</span>' <span class="id">m2</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_separated</span> <span class="id">f1</span> <span class="id">f2</span> <span class="id">m1</span> <span class="id">m1</span>' -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">p</span>, <span class="id">Mem.valid_block</span> <span class="id">m1</span> <span class="id">b</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m1</span> <span class="id">b</span> <span class="id">ofs</span> <span class="id">Max</span> <span class="id">p</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">m1</span>' <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Ple</span> <span class="id">bound</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) -&gt; <span class="id">Ple</span> <span class="id">tbound</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">m2</span>' <span class="id">cs</span> <span class="id">bound</span> <span class="id">tbound</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4573')">Proof.</div>
<div class="proofscript" id="proof4573">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">m2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">UNMAPPED</span> <span class="id">OUTOFREACH</span> <span class="id">INCR</span> <span class="id">SEPARATED</span> <span class="id">MAXPERMS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mcs_nil</span> <span class="kwd">with</span> <span class="id">hi</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">case_eq</span> (<span class="id">f1</span> <span class="id">b1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">b2</span>' <span class="id">delta</span>'] <span class="id">EQ</span>. <span class="tactic">rewrite</span> (<span class="id">INCR</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ</span>) <span class="kwd">in</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">EQ</span>. <span class="id">exploit</span> <span class="id">SEPARATED</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> <span class="id">B</span>. <span class="tactic">red</span>. <span class="id">xomega</span>.<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_temps_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span> <span class="kwd">in</span> <span class="id">SEPARATED</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">f1</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>']|] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">INCR</span>; <span class="tactic">eauto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">SEPARATED</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> <span class="id">B</span>. <span class="tactic">red</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">assert</span> (<span class="id">Ple</span> <span class="id">lo</span> <span class="id">hi</span>) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">me_low_high</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f1</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>']|] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">INCR</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">f2</span> <span class="id">b</span>) <span class="kwd">as</span> [[<span class="id">b</span>' <span class="id">delta</span>']|] <span class="id">eqn</span>:?; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">SEPARATED</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">elim</span> <span class="id">A</span>. <span class="tactic">red</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_bounds_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">MAXPERMS</span>; <span class="tactic">eauto</span>. <span class="tactic">red</span>. <span class="id">exploit</span> <span class="id">me_bounded</span>; <span class="tactic">eauto</span>. <span class="id">xomega</span>.<br/>
&nbsp;padding-freeable&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">is_reachable_from_env_dec</span> <span class="id">f1</span> <span class="id">e</span> <span class="id">sp</span> <span class="id">ofs</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H3</span>. <span class="id">right</span>. <span class="tactic">apply</span> <span class="id">is_reachable_intro</span> <span class="kwd">with</span> <span class="id">id</span> <span class="id">b</span> <span class="id">sz</span> <span class="id">delta</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>]; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">id</span> [<span class="id">lv</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">BOUND0</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_reachable_intro</span> <span class="kwd">with</span> <span class="id">id</span> <span class="id">b0</span> <span class="id">lv</span> <span class="id">delta</span>; <span class="tactic">auto</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;induction&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHmatch_callstack</span>; <span class="tactic">eauto</span>. <span class="id">inv</span> <span class="id">MENV</span>; <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_callstack</span></span> and allocations </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_alloc_right</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> <span class="id">tf</span> <span class="id">tm</span>' <span class="id">sp</span> <span class="id">le</span> <span class="id">te</span> <span class="id">cenv</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">tm</span> 0 <span class="id">tf</span>.(<span class="id">fn_stackspace</span>) = (<span class="id">tm</span>', <span class="id">sp</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span>, <span class="id">cenv</span>!<span class="id">id</span> = <span class="id">None</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">empty_env</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4574')">Proof.</div>
<div class="proofscript" id="proof4574">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">NEXTBLOCK</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">RES</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H4</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eelim</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">RES</span>. <span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">tb</span>). <span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">left</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_invariant</span> <span class="kwd">with</span> (<span class="id">tm1</span> := <span class="id">tm</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">RES</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_1</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_alloc_left</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm</span> <span class="id">id</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">cs</span> <span class="id">sz</span> <span class="id">m2</span> <span class="id">b</span> <span class="id">f2</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> (<span class="id">PTree.remove</span> <span class="id">id</span> <span class="id">cenv</span>) <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m1</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m1</span> 0 <span class="id">sz</span> = (<span class="id">m2</span>, <span class="id">b</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">f1</span> <span class="id">f2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f2</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">sp</span>, <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">b</span>', <span class="id">b</span>' &lt;&gt; <span class="id">b</span> -&gt; <span class="id">f2</span> <span class="id">b</span>' = <span class="id">f1</span> <span class="id">b</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">e</span>!<span class="id">id</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> (<span class="id">PTree.set</span> <span class="id">id</span> (<span class="id">b</span>, <span class="id">sz</span>) <span class="id">e</span>) <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m2</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m2</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4575')">Proof.</div>
<div class="proofscript" id="proof4575">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.nextblock_alloc</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">NEXTBLOCK</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_result</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">RES</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LO</span>: <span class="id">Ple</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>)) <span class="tactic">by</span> (<span class="tactic">eapply</span> <span class="id">me_low_high</span>; <span class="tactic">eauto</span>).<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_temps_invariant</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_env_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id0</span> <span class="id">id</span>).<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>. <span class="tactic">subst</span> <span class="id">b0</span> <span class="id">sz0</span> <span class="id">id0</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">BOUND0</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">me_bounded</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">PERM</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span>|<span class="id">A</span>]. <span class="tactic">auto</span>. <span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">is_reachable_intro</span> <span class="kwd">with</span> <span class="id">id0</span> <span class="id">b0</span> <span class="id">sz0</span> <span class="id">delta</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span>. <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_invariant</span> <span class="kwd">with</span> (<span class="id">m1</span> := <span class="id">m1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_4</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H4</span>. <span class="tactic">unfold</span> <span class="id">block</span> <span class="kwd">in</span> *; <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b0</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b0</span>. <span class="tactic">rewrite</span> <span class="id">H3</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">xomegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of stack allocation of local variables </h1>
<br/>
<div class="doc">This section shows the correctness of the translation of Csharpminor
  local variables as sub-blocks of the Cminor stack data.  This is the most difficult part of the proof. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">cenv_remove</span> (<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">vars</span>: <span class="id">list</span> (<span class="id">ident</span> * <span class="id">Z</span>)) : <span class="id">compilenv</span> :=<br/>
&nbsp;&nbsp;<span class="id">fold_right</span> (<span class="kwd">fun</span> <span class="id">id_lv</span> <span class="id">ce</span> =&gt; <span class="id">PTree.remove</span> (<span class="id">fst</span> <span class="id">id_lv</span>) <span class="id">ce</span>) <span class="id">cenv</span> <span class="id">vars</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">cenv_remove_gso</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">vars</span> <span class="id">cenv</span>,<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id</span> (<span class="id">cenv_remove</span> <span class="id">cenv</span> <span class="id">vars</span>) = <span class="id">PTree.get</span> <span class="id">id</span> <span class="id">cenv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4576')">Proof.</div>
<div class="proofscript" id="proof4576">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gro</span>. <span class="tactic">apply</span> <span class="id">IHvars</span>. <span class="tactic">intuition</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">cenv_remove_gss</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">vars</span> <span class="id">cenv</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id</span> (<span class="id">cenv_remove</span> <span class="id">cenv</span> <span class="id">vars</span>) = <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4577')">Proof.</div>
<div class="proofscript" id="proof4577">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.grspec</span>. <span class="tactic">destruct</span> (<span class="id">PTree.elt_eq</span> <span class="id">id</span> (<span class="id">fst</span> <span class="id">a</span>)). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">intuition</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">cenv_compat</span> (<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">vars</span>: <span class="id">list</span> (<span class="id">ident</span> * <span class="id">Z</span>)) (<span class="id">tsz</span>: <span class="id">Z</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id</span>, <span class="id">sz</span>) <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">Some</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">Mem.inj_offset_aligned</span> <span class="id">ofs</span> <span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;/\ 0 &lt;= <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">ofs</span> + <span class="id">Zmax</span> 0 <span class="id">sz</span> &lt;= <span class="id">tsz</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cenv_separated</span> (<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">vars</span>: <span class="id">list</span> (<span class="id">ident</span> * <span class="id">Z</span>)) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id1</span> <span class="id">sz1</span> <span class="id">ofs1</span> <span class="id">id2</span> <span class="id">sz2</span> <span class="id">ofs2</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id1</span>, <span class="id">sz1</span>) <span class="id">vars</span> -&gt; <span class="id">In</span> (<span class="id">id2</span>, <span class="id">sz2</span>) <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">PTree.get</span> <span class="id">id1</span> <span class="id">cenv</span> = <span class="id">Some</span> <span class="id">ofs1</span> -&gt; <span class="id">PTree.get</span> <span class="id">id2</span> <span class="id">cenv</span> = <span class="id">Some</span> <span class="id">ofs2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">id1</span> &lt;&gt; <span class="id">id2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ofs1</span> + <span class="id">sz1</span> &lt;= <span class="id">ofs2</span> \/ <span class="id">ofs2</span> + <span class="id">sz2</span> &lt;= <span class="id">ofs1</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">cenv_mem_separated</span> (<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">vars</span>: <span class="id">list</span> (<span class="id">ident</span> * <span class="id">Z</span>)) (<span class="id">f</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">m</span>: <span class="id">mem</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">sz</span> <span class="id">ofs</span> <span class="id">b</span> <span class="id">delta</span> <span class="id">ofs</span>' <span class="id">k</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id</span>, <span class="id">sz</span>) <span class="id">vars</span> -&gt; <span class="id">PTree.get</span> <span class="id">id</span> <span class="id">cenv</span> = <span class="id">Some</span> <span class="id">ofs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span> (<span class="id">sp</span>, <span class="id">delta</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">b</span> <span class="id">ofs</span>' <span class="id">k</span> <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ofs</span> &lt;= <span class="id">ofs</span>' + <span class="id">delta</span> &lt; <span class="id">sz</span> + <span class="id">ofs</span> -&gt; <span class="id">False</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_alloc_variables_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm</span> <span class="id">sp</span> <span class="id">tf</span> <span class="id">cenv</span> <span class="id">le</span> <span class="id">te</span> <span class="id">lo</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_block</span> <span class="id">tm</span> <span class="id">sp</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">fn_stackspace</span> <span class="id">tf</span> &lt;= <span class="id">Ptrofs.max_unsigned</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">tm</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; 0 &lt;= <span class="id">ofs</span> &lt; <span class="id">fn_stackspace</span> <span class="id">tf</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, 0 &lt;= <span class="id">ofs</span> &lt; <span class="id">fn_stackspace</span> <span class="id">tf</span> -&gt; <span class="id">Mem.perm</span> <span class="id">tm</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e2</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">e1</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e2</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f1</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv</span> <span class="id">vars</span> (<span class="id">fn_stackspace</span> <span class="id">tf</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_separated</span> <span class="id">cenv</span> <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_mem_separated</span> <span class="id">cenv</span> <span class="id">vars</span> <span class="id">f1</span> <span class="id">sp</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">sz</span>, <span class="id">In</span> (<span class="id">id</span>, <span class="id">sz</span>) <span class="id">vars</span> -&gt; <span class="id">e1</span>!<span class="id">id</span> = <span class="id">None</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> (<span class="id">cenv_remove</span> <span class="id">cenv</span> <span class="id">vars</span>) <span class="id">tf</span> <span class="id">e1</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m1</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">f2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e2</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> (<span class="id">Mem.nextblock</span> <span class="id">m2</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m2</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4578')">Proof.</div>
<div class="proofscript" id="proof4578">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">cs</span>; <span class="tactic">intros</span> <span class="id">VALID</span> <span class="id">REPRES</span> <span class="id">STKSIZE</span> <span class="id">STKPERMS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">f1</span> <span class="id">NOREPET</span> <span class="id">COMPAT</span> <span class="id">SEP1</span> <span class="id">SEP2</span> <span class="id">UNBOUND</span> <span class="id">MCS</span> <span class="id">MINJ</span>.<br/>
&nbsp;base&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">MCS</span>. <span class="id">exists</span> <span class="id">f1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;inductive&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">NOREPET</span>. <span class="id">inv</span> <span class="id">NOREPET</span>.<br/>
&nbsp;exploit&nbsp;Mem.alloc_result;&nbsp;eauto.&nbsp;intros&nbsp;RES.<br/>
&nbsp;&nbsp;exploit&nbsp;Mem.nextblock_alloc;&nbsp;eauto.&nbsp;intros&nbsp;NB.*)</span>&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">COMPAT</span> <span class="id">id</span> <span class="id">sz</span>). <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">intros</span> [<span class="id">ofs</span> [<span class="id">CENV</span> [<span class="id">ALIGNED</span> [<span class="id">LOB</span> <span class="id">HIB</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.alloc_left_mapped_inject</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">MINJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">VALID</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">ofs</span>). <span class="id">zify</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">STKSIZE</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">STKPERMS</span>. <span class="id">zify</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">sz</span> - 0) <span class="kwd">with</span> <span class="id">sz</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">SEP2</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="id">eexact</span> <span class="id">CENV</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">f2</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHalloc_variables</span> <span class="id">f2</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">COMPAT</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">SEP1</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">Mem.perm_alloc_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">destruct</span> (<span class="id">eq_block</span> <span class="id">b</span> <span class="id">b1</span>); <span class="tactic">intros</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">b</span>. <span class="tactic">rewrite</span> <span class="id">C</span> <span class="kwd">in</span> <span class="id">H5</span>; <span class="id">inv</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">SEP1</span>. <span class="tactic">eapply</span> <span class="id">in_eq</span>. <span class="tactic">eapply</span> <span class="id">in_cons</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">id0</span>. <span class="tactic">elim</span> <span class="id">H3</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">sz0</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">SEP2</span>. <span class="tactic">apply</span> <span class="id">in_cons</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">D</span> <span class="kwd">in</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>. <span class="tactic">eapply</span> <span class="id">UNBOUND</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">id0</span>. <span class="tactic">elim</span> <span class="id">H3</span>. <span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">sz0</span>)). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_alloc_left</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">cenv_remove_gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">UNBOUND</span> <span class="kwd">with</span> <span class="id">sz</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_callstack_alloc_variables</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tm1</span> <span class="id">sp</span> <span class="id">tm2</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e</span> <span class="id">m2</span> <span class="id">cenv</span> <span class="id">f1</span> <span class="id">cs</span> <span class="id">fn</span> <span class="id">le</span> <span class="id">te</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">tm1</span> 0 (<span class="id">fn_stackspace</span> <span class="id">fn</span>) = (<span class="id">tm2</span>, <span class="id">sp</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">fn_stackspace</span> <span class="id">fn</span> &lt;= <span class="id">Ptrofs.max_unsigned</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">empty_env</span> <span class="id">m1</span> <span class="id">vars</span> <span class="id">e</span> <span class="id">m2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv</span> <span class="id">vars</span> (<span class="id">fn_stackspace</span> <span class="id">fn</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_separated</span> <span class="id">cenv</span> <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">id</span> <span class="id">ofs</span>, <span class="id">cenv</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">ofs</span> -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f1</span> <span class="id">m1</span> <span class="id">tm1</span> <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f1</span> <span class="id">le</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">f2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm2</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">fn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> (<span class="id">Mem.nextblock</span> <span class="id">m1</span>) (<span class="id">Mem.nextblock</span> <span class="id">m2</span>) :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m2</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm2</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f2</span> <span class="id">m2</span> <span class="id">tm2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4579')">Proof.</div>
<div class="proofscript" id="proof4579">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_alloc_variables_rec</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_new_block</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_3</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Mem.perm_implies</span> <span class="kwd">with</span> <span class="id">Freeable</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_alloc_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">f1</span>). <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">eelim</span> <span class="id">Mem.fresh_block_alloc</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.valid_block_inject_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PTree.gempty</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_alloc_right</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">peq</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">cenv_remove_gss</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">cenv_remove_gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">cenv</span>!<span class="id">id</span>) <span class="kwd">as</span> [<span class="id">ofs</span>|] <span class="id">eqn</span>:?; <span class="tactic">auto</span>. <span class="tactic">elim</span> <span class="id">n</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.alloc_right_inject</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Properties of the compilation environment produced by <span class="bracket"><span class="id">build_compilenv</span></span> </div>
<br/>
<span class="kwd">Remark</span> <span class="id">block_alignment_pos</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sz</span>, <span class="id">block_alignment</span> <span class="id">sz</span> &gt; 0.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4580')">Proof.</div>
<div class="proofscript" id="proof4580">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">block_alignment</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 2). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 4). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 8); <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">assign_variable_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">sz</span> <span class="id">cenv</span> <span class="id">stksz</span> <span class="id">cenv</span>' <span class="id">stksz</span>',<br/>
&nbsp;&nbsp;<span class="id">assign_variable</span> (<span class="id">cenv</span>, <span class="id">stksz</span>) (<span class="id">id</span>, <span class="id">sz</span>) = (<span class="id">cenv</span>', <span class="id">stksz</span>') -&gt; <span class="id">stksz</span> &lt;= <span class="id">stksz</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4581')">Proof.</div>
<div class="proofscript" id="proof4581">
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">align_le</span> <span class="id">stksz</span> (<span class="id">block_alignment</span> <span class="id">sz</span>) (<span class="id">block_alignment_pos</span> <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (0 &lt;= <span class="id">Zmax</span> 0 <span class="id">sz</span>). <span class="tactic">apply</span> <span class="id">Zmax_bound_l</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">assign_variables_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">cenv</span>' <span class="id">sz</span>',<br/>
&nbsp;&nbsp;<span class="id">assign_variables</span> (<span class="id">cenv</span>, <span class="id">sz</span>) <span class="id">vars</span> = (<span class="id">cenv</span>', <span class="id">sz</span>') -&gt; <span class="id">sz</span> &lt;= <span class="id">sz</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4582')">Proof.</div>
<div class="proofscript" id="proof4582">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">sz</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
<span class="id">Opaque</span> <span class="id">assign_variable</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">s</span>]. <span class="tactic">simpl</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">assign_variable</span> (<span class="id">cenv</span>, <span class="id">sz</span>) (<span class="id">id</span>, <span class="id">s</span>)) <span class="kwd">as</span> [<span class="id">cenv1</span> <span class="id">sz1</span>] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zle_trans</span> <span class="kwd">with</span> <span class="id">sz1</span>. <span class="tactic">eapply</span> <span class="id">assign_variable_incr</span>; <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
<span class="id">Transparent</span> <span class="id">assign_variable</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">inj_offset_aligned_block</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">stacksize</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.inj_offset_aligned</span> (<span class="id">align</span> <span class="id">stacksize</span> (<span class="id">block_alignment</span> <span class="id">sz</span>)) <span class="id">sz</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4583')">Proof.</div>
<div class="proofscript" id="proof4583">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zdivides_trans</span> <span class="kwd">with</span> (<span class="id">block_alignment</span> <span class="id">sz</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">align_chunk</span>.  <span class="tactic">unfold</span> <span class="id">block_alignment</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Zone_divide</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">Zdivide_refl</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (2 | 4). <span class="id">exists</span> 2; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (2 | 8). <span class="id">exists</span> 4; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (4 | 8). <span class="id">exists</span> 2; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 2).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">auto</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 4).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">auto</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 8).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">auto</span>; <span class="id">omegaContradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">align_divides</span>. <span class="tactic">apply</span> <span class="id">block_alignment_pos</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">inj_offset_aligned_block</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">stacksize</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">Mem.inj_offset_aligned</span> (<span class="id">align</span> <span class="id">stacksize</span> (<span class="id">block_alignment</span> <span class="id">sz</span>)) (<span class="id">Zmax</span> 0 <span class="id">sz</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4584')">Proof.</div>
<div class="proofscript" id="proof4584">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">block_alignment</span> <span class="id">sz</span>) <span class="kwd">with</span> (<span class="id">block_alignment</span> (<span class="id">Zmax</span> 0 <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inj_offset_aligned_block</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Zmax_spec</span>. <span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">sz</span> 0); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">transitivity</span> 1. <span class="tactic">reflexivity</span>. <span class="tactic">unfold</span> <span class="id">block_alignment</span>. <span class="tactic">rewrite</span> <span class="id">zlt_true</span>. <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">assign_variable_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv1</span> <span class="id">sz1</span> <span class="id">id</span> <span class="id">sz</span> <span class="id">cenv2</span> <span class="id">sz2</span> <span class="id">vars</span>,<br/>
&nbsp;&nbsp;<span class="id">assign_variable</span> (<span class="id">cenv1</span>, <span class="id">sz1</span>) (<span class="id">id</span>, <span class="id">sz</span>) = (<span class="id">cenv2</span>, <span class="id">sz2</span>) -&gt;<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">sz1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv1</span> <span class="id">vars</span> <span class="id">sz1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_separated</span> <span class="id">cenv1</span> <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv2</span> (<span class="id">vars</span> ++ (<span class="id">id</span>, <span class="id">sz</span>) :: <span class="id">nil</span>) <span class="id">sz2</span><br/>
&nbsp;&nbsp;/\ <span class="id">cenv_separated</span> <span class="id">cenv2</span> (<span class="id">vars</span> ++ (<span class="id">id</span>, <span class="id">sz</span>) :: <span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4585')">Proof.</div>
<div class="proofscript" id="proof4585">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">assign_variable</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">vars</span>; <span class="tactic">intros</span> <span class="id">ASV</span> <span class="id">NOREPET</span> <span class="id">POS</span> <span class="id">COMPAT</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">ASV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">LE</span>: <span class="id">sz1</span> &lt;= <span class="id">align</span> <span class="id">sz1</span> (<span class="id">block_alignment</span> <span class="id">sz</span>)). <span class="tactic">apply</span> <span class="id">align_le</span>. <span class="tactic">apply</span> <span class="id">block_alignment_pos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">EITHER</span>: <span class="kwd">forall</span> <span class="id">id</span>' <span class="id">sz</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id</span>', <span class="id">sz</span>') (<span class="id">vars</span> ++ (<span class="id">id</span>, <span class="id">sz</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">id</span>', <span class="id">sz</span>') <span class="id">vars</span> /\ <span class="id">id</span>' &lt;&gt; <span class="id">id</span> \/ (<span class="id">id</span>', <span class="id">sz</span>') = (<span class="id">id</span>, <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">in_app</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">id</span>'. <span class="tactic">elim</span> <span class="id">NOREPET</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> <span class="id">id</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">id</span>, <span class="id">sz</span>')). <span class="tactic">apply</span> <span class="id">in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">auto</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">EITHER</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[<span class="id">P</span> <span class="id">Q</span>] | <span class="id">P</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">COMPAT</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">ofs</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">zify</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">P</span>. <span class="id">exists</span> (<span class="id">align</span> <span class="id">sz1</span> (<span class="id">block_alignment</span> <span class="id">sz</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">inj_offset_aligned_block</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">EITHER</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">EITHER</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [[<span class="id">P</span> <span class="id">Q</span>] | <span class="id">P</span>]; <span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [[<span class="id">R</span> <span class="id">S</span>] | <span class="id">R</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="kwd">in</span> *; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">SEP</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">R</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gss</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="id">inv</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">COMPAT</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">ofs</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ofs</span> = <span class="id">ofs1</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">ofs</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="id">zify</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">P</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gss</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">inv</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">COMPAT</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">ofs</span> [<span class="id">A</span> [<span class="id">B</span> [<span class="id">C</span> <span class="id">D</span>]]]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">ofs</span> = <span class="id">ofs2</span>) <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">subst</span> <span class="id">ofs</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="id">zify</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">assign_variables_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars</span>' <span class="id">cenv1</span> <span class="id">sz1</span> <span class="id">cenv2</span> <span class="id">sz2</span> <span class="id">vars</span>,<br/>
&nbsp;&nbsp;<span class="id">assign_variables</span> (<span class="id">cenv1</span>, <span class="id">sz1</span>) <span class="id">vars</span>' = (<span class="id">cenv2</span>, <span class="id">sz2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>' ++ <span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>) -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">sz1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv1</span> <span class="id">vars</span> <span class="id">sz1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_separated</span> <span class="id">cenv1</span> <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv2</span> (<span class="id">vars</span> ++ <span class="id">vars</span>') <span class="id">sz2</span> /\ <span class="id">cenv_separated</span> <span class="id">cenv2</span> (<span class="id">vars</span> ++ <span class="id">vars</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4586')">Proof.</div>
<div class="proofscript" id="proof4586">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>'; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">app_nil_r</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id</span> <span class="id">sz</span>].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">in_app</span> <span class="kwd">in</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">list_norepet_app</span> <span class="kwd">in</span> <span class="id">H7</span>. <span class="tactic">destruct</span> <span class="id">H7</span> <span class="kwd">as</span> [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">assign_variable</span> (<span class="id">cenv1</span>, <span class="id">sz1</span>) (<span class="id">id</span>, <span class="id">sz</span>)) <span class="kwd">as</span> [<span class="id">cenv</span>' <span class="id">sz</span>'] <span class="id">eqn</span>:?.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">assign_variable_sound</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">vars</span>). <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHvars</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">vars</span> ++ ((<span class="id">id</span>, <span class="id">sz</span>) :: <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">list_norepet_app</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">apply</span> <span class="id">list_norepet_append_commut</span>. <span class="tactic">simpl</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">simpl</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">in_app</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">subst</span> <span class="id">y</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">subst</span> <span class="id">x</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">assign_variable_incr</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">Heqp</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">app_ass</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">permutation_norepet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Type</span>) (<span class="id">l</span> <span class="id">l</span>': <span class="id">list</span> <span class="id">A</span>), <span class="id">Permutation</span> <span class="id">l</span> <span class="id">l</span>' -&gt; <span class="id">list_norepet</span> <span class="id">l</span> -&gt; <span class="id">list_norepet</span> <span class="id">l</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4587')">Proof.</div>
<div class="proofscript" id="proof4587">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">elim</span> <span class="id">H3</span>. <span class="tactic">apply</span> <span class="id">Permutation_in</span> <span class="kwd">with</span> <span class="id">l</span>'; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Permutation_sym</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="id">inv</span> <span class="id">H3</span>. <span class="id">constructor</span>. <span class="tactic">simpl</span>; <span class="tactic">intuition</span>. <span class="id">constructor</span>. <span class="tactic">intuition</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">build_compilenv_sound</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">sz</span>,<br/>
&nbsp;&nbsp;<span class="id">build_compilenv</span> <span class="id">f</span> = (<span class="id">cenv</span>, <span class="id">sz</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv_compat</span> <span class="id">cenv</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>) <span class="id">sz</span> /\ <span class="id">cenv_separated</span> <span class="id">cenv</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4588')">Proof.</div>
<div class="proofscript" id="proof4588">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">build_compilenv</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">vars1</span> := <span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">VarSort.Permuted_sort</span> <span class="id">vars1</span>). <span class="tactic">intros</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">vars2</span> := <span class="id">VarSort.sort</span> <span class="id">vars1</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">cenv_compat</span> <span class="id">cenv</span> <span class="id">vars2</span> <span class="id">sz</span> /\ <span class="id">cenv_separated</span> <span class="id">cenv</span> <span class="id">vars2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> <span class="id">vars2</span> <span class="kwd">with</span> (<span class="id">nil</span> ++ <span class="id">vars2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">assign_variables_sound</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">app_nil_r</span>. <span class="tactic">apply</span> <span class="id">permutation_norepet</span> <span class="kwd">with</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars1</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Permutation_map</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">Permutation_in</span> <span class="kwd">with</span> <span class="id">vars1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">B</span>; <span class="tactic">eauto</span>; <span class="tactic">apply</span> <span class="id">Permutation_in</span> <span class="kwd">with</span> <span class="id">vars1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">assign_variables_domain</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">vars</span> <span class="id">cesz</span>,<br/>
&nbsp;&nbsp;(<span class="id">fst</span> (<span class="id">assign_variables</span> <span class="id">cesz</span> <span class="id">vars</span>))!<span class="id">id</span> &lt;&gt; <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">fst</span> <span class="id">cesz</span>)!<span class="id">id</span> &lt;&gt; <span class="id">None</span> \/ <span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4589')">Proof.</div>
<div class="proofscript" id="proof4589">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHvars</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">assign_variable</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">id1</span> <span class="id">sz1</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cesz</span> <span class="kwd">as</span> [<span class="id">cenv</span> <span class="id">stksz</span>]. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">id1</span>). <span class="tactic">auto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">build_compilenv_domain</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">id</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">build_compilenv</span> <span class="id">f</span> = (<span class="id">cenv</span>, <span class="id">sz</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">cenv</span>!<span class="id">id</span> = <span class="id">Some</span> <span class="id">ofs</span> -&gt; <span class="id">In</span> <span class="id">id</span> (<span class="id">map</span> <span class="id">fst</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4590')">Proof.</div>
<div class="proofscript" id="proof4590">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">build_compilenv</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">vars1</span> := <span class="id">Csharpminor.fn_vars</span> <span class="id">f</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">VarSort.Permuted_sort</span> <span class="id">vars1</span>). <span class="tactic">intros</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">vars2</span> := <span class="id">VarSort.sort</span> <span class="id">vars1</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">assign_variables_domain</span> <span class="id">id</span> <span class="id">vars2</span> (<span class="id">PTree.empty</span> <span class="id">Z</span>, 0)).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Permutation_in</span> <span class="kwd">with</span> (<span class="id">map</span> <span class="id">fst</span> <span class="id">vars2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Permutation_map</span>. <span class="tactic">apply</span> <span class="id">Permutation_sym</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Initialization of C#minor temporaries and Cminor local variables. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">create_undef_temps_val</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">v</span> <span class="id">temps</span>, (<span class="id">create_undef_temps</span> <span class="id">temps</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">v</span> -&gt; <span class="id">In</span> <span class="id">id</span> <span class="id">temps</span> /\ <span class="id">v</span> = <span class="id">Vundef</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4591')">Proof.</div>
<div class="proofscript" id="proof4591">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">temps</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gempty</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHtemps</span>; <span class="tactic">eauto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">set_params</span>' (<span class="id">vl</span>: <span class="id">list</span> <span class="id">val</span>) (<span class="id">il</span>: <span class="id">list</span> <span class="id">ident</span>) (<span class="id">te</span>: <span class="id">Cminor.env</span>) : <span class="id">Cminor.env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">il</span>, <span class="id">vl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">i1</span> :: <span class="id">is</span>, <span class="id">v1</span> :: <span class="id">vs</span> =&gt; <span class="id">set_params</span>' <span class="id">vs</span> <span class="id">is</span> (<span class="id">PTree.set</span> <span class="id">i1</span> <span class="id">v1</span> <span class="id">te</span>)<br/>
&nbsp;&nbsp;| <span class="id">i1</span> :: <span class="id">is</span>, <span class="id">nil</span> =&gt; <span class="id">set_params</span>' <span class="id">nil</span> <span class="id">is</span> (<span class="id">PTree.set</span> <span class="id">i1</span> <span class="id">Vundef</span> <span class="id">te</span>)<br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">te</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">bind_parameters_agree_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">vars</span> <span class="id">vals</span> <span class="id">tvals</span> <span class="id">le1</span> <span class="id">le2</span> <span class="id">te</span>,<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> <span class="id">vars</span> <span class="id">vals</span> <span class="id">le1</span> = <span class="id">Some</span> <span class="id">le2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">vals</span> <span class="id">tvals</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le1</span> <span class="id">te</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le2</span> (<span class="id">set_params</span>' <span class="id">tvals</span> <span class="id">vars</span> <span class="id">te</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4592')">Proof.</div>
<div class="proofscript" id="proof4592">
<span class="id">Opaque</span> <span class="id">PTree.set</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">vars</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vals</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vals</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="id">inv</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">IHvars</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_params</span>'<span class="id">_outside</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">il</span> <span class="id">vl</span> <span class="id">te</span>, ~<span class="id">In</span> <span class="id">id</span> <span class="id">il</span> -&gt; (<span class="id">set_params</span>' <span class="id">vl</span> <span class="id">il</span> <span class="id">te</span>)!<span class="id">id</span> = <span class="id">te</span>!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4593')">Proof.</div>
<div class="proofscript" id="proof4593">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vl</span>; <span class="tactic">rewrite</span> <span class="id">IHil</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gso</span>. <span class="tactic">intuition</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">PTree.gso</span>. <span class="tactic">intuition</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_params</span>'<span class="id">_inside</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">id</span> <span class="id">il</span> <span class="id">vl</span> <span class="id">te1</span> <span class="id">te2</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> <span class="id">il</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">set_params</span>' <span class="id">vl</span> <span class="id">il</span> <span class="id">te1</span>)!<span class="id">id</span> = (<span class="id">set_params</span>' <span class="id">vl</span> <span class="id">il</span> <span class="id">te2</span>)!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4594')">Proof.</div>
<div class="proofscript" id="proof4594">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">vl</span>; <span class="tactic">destruct</span> (<span class="id">List.in_dec</span> <span class="id">peq</span> <span class="id">id</span> <span class="id">il</span>); <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>;<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">a</span> = <span class="id">id</span>) <span class="tactic">by</span> <span class="tactic">intuition</span>; <span class="tactic">subst</span> <span class="id">a</span>; <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">PTree.gss</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_params_set_params</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">il</span> <span class="id">vl</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">il</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">set_params</span> <span class="id">vl</span> <span class="id">il</span>)!<span class="id">id</span> = (<span class="id">set_params</span>' <span class="id">vl</span> <span class="id">il</span> (<span class="id">PTree.empty</span> <span class="id">val</span>))!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4595')">Proof.</div>
<div class="proofscript" id="proof4595">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">vl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gss</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHil</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">List.in_dec</span> <span class="id">peq</span> <span class="id">id</span> <span class="id">il</span>). <span class="tactic">apply</span> <span class="id">set_params</span>'<span class="id">_inside</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gss</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHil</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">List.in_dec</span> <span class="id">peq</span> <span class="id">id</span> <span class="id">il</span>). <span class="tactic">apply</span> <span class="id">set_params</span>'<span class="id">_inside</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">PTree.gso</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_locals_outside</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">id</span> <span class="id">il</span>,<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">id</span> <span class="id">il</span> -&gt; (<span class="id">set_locals</span> <span class="id">il</span> <span class="id">e</span>)!<span class="id">id</span> = <span class="id">e</span>!<span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4596')">Proof.</div>
<div class="proofscript" id="proof4596">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gso</span>. <span class="tactic">apply</span> <span class="id">IHil</span>. <span class="tactic">tauto</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_locals_inside</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">id</span> <span class="id">il</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">id</span> <span class="id">il</span> -&gt; (<span class="id">set_locals</span> <span class="id">il</span> <span class="id">e</span>)!<span class="id">id</span> = <span class="id">Some</span> <span class="id">Vundef</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4597')">Proof.</div>
<div class="proofscript" id="proof4597">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">il</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">subst</span> <span class="id">a</span>. <span class="tactic">apply</span> <span class="id">PTree.gss</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">PTree.gsspec</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">id</span> <span class="id">a</span>). <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_locals_set_params</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">vars</span> <span class="id">vals</span> <span class="id">params</span> <span class="id">id</span>,<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">params</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_disjoint</span> <span class="id">params</span> <span class="id">vars</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">set_locals</span> <span class="id">vars</span> (<span class="id">set_params</span> <span class="id">vals</span> <span class="id">params</span>)) ! <span class="id">id</span> =<br/>
&nbsp;&nbsp;(<span class="id">set_params</span>' <span class="id">vals</span> <span class="id">params</span> (<span class="id">set_locals</span> <span class="id">vars</span> (<span class="id">PTree.empty</span> <span class="id">val</span>))) ! <span class="id">id</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4598')">Proof.</div>
<div class="proofscript" id="proof4598">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">in_dec</span> <span class="id">peq</span> <span class="id">id</span> <span class="id">vars</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (~<span class="id">In</span> <span class="id">id</span> <span class="id">params</span>). <span class="tactic">apply</span> <span class="id">list_disjoint_notin</span> <span class="kwd">with</span> <span class="id">vars</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">list_disjoint_sym</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">set_locals_inside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">set_locals_inside</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">set_locals_outside</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">set_params_set_params</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">in_dec</span> <span class="id">peq</span> <span class="id">id</span> <span class="id">params</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">set_params</span>'<span class="id">_inside</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">set_params</span>'<span class="id">_outside</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">set_locals_outside</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">bind_parameters_agree</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">params</span> <span class="id">temps</span> <span class="id">vals</span> <span class="id">tvals</span> <span class="id">le</span>,<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> <span class="id">params</span> <span class="id">vals</span> (<span class="id">create_undef_temps</span> <span class="id">temps</span>) = <span class="id">Some</span> <span class="id">le</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">vals</span> <span class="id">tvals</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">params</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_disjoint</span> <span class="id">params</span> <span class="id">temps</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_temps</span> <span class="id">f</span> <span class="id">le</span> (<span class="id">set_locals</span> <span class="id">temps</span> (<span class="id">set_params</span> <span class="id">tvals</span> <span class="id">params</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4599')">Proof.</div>
<div class="proofscript" id="proof4599">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">bind_parameters_agree_rec</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">set_locals</span> <span class="id">temps</span> (<span class="id">PTree.empty</span> <span class="id">val</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">create_undef_temps_val</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>]. <span class="tactic">subst</span> <span class="id">v0</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">Vundef</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">set_locals_inside</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">set_locals_set_params</span>'; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The main result in this section. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">match_callstack_function_entry</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fn</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">m</span> <span class="id">e</span> <span class="id">m</span>' <span class="id">tm</span> <span class="id">tm</span>' <span class="id">sp</span> <span class="id">f</span> <span class="id">cs</span> <span class="id">args</span> <span class="id">targs</span> <span class="id">le</span>,<br/>
&nbsp;&nbsp;<span class="id">build_compilenv</span> <span class="id">fn</span> = (<span class="id">cenv</span>, <span class="id">tf</span>.(<span class="id">fn_stackspace</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">tf</span>.(<span class="id">fn_stackspace</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">map</span> <span class="id">fst</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">fn</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">Csharpminor.fn_params</span> <span class="id">fn</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_disjoint</span> (<span class="id">Csharpminor.fn_params</span> <span class="id">fn</span>) (<span class="id">Csharpminor.fn_temps</span> <span class="id">fn</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">alloc_variables</span> <span class="id">Csharpminor.empty_env</span> <span class="id">m</span> (<span class="id">Csharpminor.fn_vars</span> <span class="id">fn</span>) <span class="id">e</span> <span class="id">m</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">bind_parameters</span> (<span class="id">Csharpminor.fn_params</span> <span class="id">fn</span>) <span class="id">args</span> (<span class="id">create_undef_temps</span> <span class="id">fn</span>.(<span class="id">fn_temps</span>)) = <span class="id">Some</span> <span class="id">le</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">args</span> <span class="id">targs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">tm</span> 0 <span class="id">tf</span>.(<span class="id">fn_stackspace</span>) = (<span class="id">tm</span>', <span class="id">sp</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">te</span> := <span class="id">set_locals</span> (<span class="id">Csharpminor.fn_temps</span> <span class="id">fn</span>) (<span class="id">set_params</span> <span class="id">targs</span> (<span class="id">Csharpminor.fn_params</span> <span class="id">fn</span>)) <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">f</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span>' <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>') :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>') (<span class="id">Mem.nextblock</span> <span class="id">tm</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">Mem.inject</span> <span class="id">f</span>' <span class="id">m</span>' <span class="id">tm</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4600')">Proof.</div>
<div class="proofscript" id="proof4600">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">build_compilenv_sound</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">C1</span> <span class="id">C2</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_alloc_variables</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">build_compilenv_domain</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">bind_parameters_agree</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Compatibility of evaluation functions with respect to memory injections. </h1>
<br/>
<span class="kwd">Remark</span> <span class="id">val_inject_val_of_bool</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">b</span>, <span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Val.of_bool</span> <span class="id">b</span>) (<span class="id">Val.of_bool</span> <span class="id">b</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4601')">Proof.</div>
<div class="proofscript" id="proof4601">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">val_inject_val_of_optbool</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">ob</span>, <span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Val.of_optbool</span> <span class="id">ob</span>) (<span class="id">Val.of_optbool</span> <span class="id">ob</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4602')">Proof.</div>
<div class="proofscript" id="proof4602">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">ob</span>; <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Ltac</span> <span class="id">TrivialExists</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">goal</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| [ |- <span class="id">exists</span> <span class="id">y</span>, <span class="id">Some</span> ?<span class="id">x</span> = <span class="id">Some</span> <span class="id">y</span> /\ <span class="id">Val.inject</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>; <span class="tactic">split</span>; [<span class="tactic">auto</span> | <span class="tactic">try</span>(<span class="id">econstructor</span>; <span class="tactic">eauto</span>)]<br/>
&nbsp;&nbsp;| [ |- <span class="id">exists</span> <span class="id">y</span>, <span class="id">_</span> /\ <span class="id">Val.inject</span> <span class="id">_</span> (<span class="id">Vint</span> ?<span class="id">x</span>) <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vint</span> <span class="id">x</span>); <span class="tactic">split</span>; [<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">evalexpr</span> | <span class="id">constructor</span>]<br/>
&nbsp;&nbsp;| [ |- <span class="id">exists</span> <span class="id">y</span>, <span class="id">_</span> /\ <span class="id">Val.inject</span> <span class="id">_</span> (<span class="id">Vfloat</span> ?<span class="id">x</span>) <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vfloat</span> <span class="id">x</span>); <span class="tactic">split</span>; [<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">evalexpr</span> | <span class="id">constructor</span>]<br/>
&nbsp;&nbsp;| [ |- <span class="id">exists</span> <span class="id">y</span>, <span class="id">_</span> /\ <span class="id">Val.inject</span> <span class="id">_</span> (<span class="id">Vlong</span> ?<span class="id">x</span>) <span class="id">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vlong</span> <span class="id">x</span>); <span class="tactic">split</span>; [<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">evalexpr</span> | <span class="id">constructor</span>]<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">idtac</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Compatibility of <span class="bracket"><span class="id">eval_unop</span></span> with respect to <span class="bracket"><span class="id">Val.inject</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_unop_compat</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">op</span> <span class="id">v1</span> <span class="id">tv1</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_unop</span> <span class="id">op</span> <span class="id">v1</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v1</span> <span class="id">tv1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_unop</span> <span class="id">op</span> <span class="id">tv1</span> = <span class="id">Some</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4603')">Proof.</div>
<div class="proofscript" id="proof4603">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float.to_int</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float.to_intu</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float32.to_int</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float32.to_intu</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span>; <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float.to_long</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float.to_longu</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float32.to_long</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">Float32.to_longu</span> <span class="id">f0</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="id">inv</span> <span class="id">H1</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="id">inv</span> <span class="id">H</span>. <span class="tactic">simpl</span>. <span class="id">TrivialExists</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Compatibility of <span class="bracket"><span class="id">eval_binop</span></span> with respect to <span class="bracket"><span class="id">Val.inject</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">eval_binop_compat</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">op</span> <span class="id">v1</span> <span class="id">tv1</span> <span class="id">v2</span> <span class="id">tv2</span> <span class="id">v</span> <span class="id">m</span> <span class="id">tm</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_binop</span> <span class="id">op</span> <span class="id">v1</span> <span class="id">v2</span> <span class="id">m</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v1</span> <span class="id">tv1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v2</span> <span class="id">tv2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_binop</span> <span class="id">op</span> <span class="id">tv1</span> <span class="id">tv2</span> <span class="id">tm</span> = <span class="id">Some</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4604')">Proof.</div>
<div class="proofscript" id="proof4604">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">Val.add_inject</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">Val.sub_inject</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id">Int.eq</span> <span class="id">i</span> (<span class="id">Int.repr</span> <span class="id">Int.min_signed</span>) &amp;&amp; <span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.mone</span>); <span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.zero</span>); <span class="id">inv</span> <span class="id">H4</span>. <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id">Int.eq</span> <span class="id">i</span> (<span class="id">Int.repr</span> <span class="id">Int.min_signed</span>) &amp;&amp; <span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.mone</span>); <span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.eq</span> <span class="id">i0</span> <span class="id">Int.zero</span>); <span class="id">inv</span> <span class="id">H4</span>. <span class="id">TrivialExists</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int.iwordsize</span>); <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int.iwordsize</span>); <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int.iwordsize</span>); <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">Val.addl_inject</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">Val.subl_inject</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">TrivialExists</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id">Int64.eq</span> <span class="id">i</span> (<span class="id">Int64.repr</span> <span class="id">Int64.min_signed</span>) &amp;&amp; <span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.mone</span>); <span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.zero</span>); <span class="id">inv</span> <span class="id">H4</span>. <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.zero</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| <span class="id">Int64.eq</span> <span class="id">i</span> (<span class="id">Int64.repr</span> <span class="id">Int64.min_signed</span>) &amp;&amp; <span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.mone</span>); <span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int64.eq</span> <span class="id">i0</span> <span class="id">Int64.zero</span>); <span class="id">inv</span> <span class="id">H4</span>. <span class="id">TrivialExists</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>'); <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>'); <span class="id">constructor</span>.<br/>
- <span class="id">TrivialExists</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Int.ltu</span> <span class="id">i0</span> <span class="id">Int64.iwordsize</span>'); <span class="id">constructor</span>.<br/>
- <span class="comment">(*&nbsp;cmp&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">TrivialExists</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H4</span>. <span class="id">eexists</span>; <span class="tactic">split</span>; [<span class="tactic">eauto</span>|]. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
- <span class="comment">(*&nbsp;cmpu&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Val.cmpu_bool</span> (<span class="id">Mem.valid_pointer</span> <span class="id">m</span>) <span class="id">c</span> <span class="id">v1</span> <span class="id">v2</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Val.cmpu_bool</span> (<span class="id">Mem.valid_pointer</span> <span class="id">tm</span>) <span class="id">c</span> <span class="id">tv1</span> <span class="id">tv2</span>) <span class="kwd">with</span> (<span class="id">Some</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="id">TrivialExists</span>. <span class="id">inv</span> <span class="id">H4</span>. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">Val.cmpu_bool_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.different_pointers_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
- <span class="comment">(*&nbsp;cmpf&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
- <span class="comment">(*&nbsp;cmpfs&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H4</span>; <span class="id">TrivialExists</span>. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
- <span class="comment">(*&nbsp;cmpl&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmpl</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H4</span>; <span class="id">inv</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
- <span class="comment">(*&nbsp;cmplu&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.cmplu</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Val.cmplu_bool</span> (<span class="id">Mem.valid_pointer</span> <span class="id">m</span>) <span class="id">c</span> <span class="id">v1</span> <span class="id">v2</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:<span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H4</span>; <span class="id">inv</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Val.cmplu_bool</span> (<span class="id">Mem.valid_pointer</span> <span class="id">tm</span>) <span class="id">c</span> <span class="id">tv1</span> <span class="id">tv2</span>) <span class="kwd">with</span> (<span class="id">Some</span> <span class="id">b</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">val_inject_val_of_bool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">eapply</span> <span class="id">Val.cmplu_bool_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_val</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.weak_valid_pointer_inject_no_overflow</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">Mem.different_pointers_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of Cminor construction functions </h1>
<br/>
<div class="doc">Correctness of the variable accessor <span class="bracket"><span class="id">var_addr</span></span> </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">var_addr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">id</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">m</span> <span class="id">cs</span> <span class="id">tm</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> (<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>) (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">eval_var_addr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">id</span> <span class="id">b</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span> (<span class="id">var_addr</span> <span class="id">cenv</span> <span class="id">id</span>) <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">Ptrofs.zero</span>) <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4605')">Proof.</div>
<div class="proofscript" id="proof4605">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">var_addr</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">match_var</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span>!<span class="id">id</span> <span class="id">cenv</span>!<span class="id">id</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">MENV</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>; <span class="id">inv</span> <span class="id">H0</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;local&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vptr</span> <span class="id">sp</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;global&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_match_globalenvs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">bnd</span> <span class="id">MG</span>]. <span class="id">inv</span> <span class="id">MG</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vptr</span> <span class="id">b</span> <span class="id">Ptrofs.zero</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">simpl</span>. <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Semantic preservation for the translation </h1>
<br/>
<div class="doc">The proof of semantic preservation uses simulation diagrams of the
  following form:
<pre>
       e, m1, s ----------------- sp, te1, tm1, ts
          |                                |
         t|                                |t
          v                                v
       e, m2, out --------------- sp, te2, tm2, tout</pre>
  where <span class="bracket"><span class="id">ts</span></span> is the Cminor statement obtained by translating the
  C#minor statement <span class="bracket"><span class="id">s</span></span>.  The left vertical arrow is an execution
  of a C#minor statement.  The right vertical arrow is an execution
  of a Cminor statement.  The precondition (top vertical bar)
  includes a <span class="bracket"><span class="id">mem_inject</span></span> relation between the memory states <span class="bracket"><span class="id">m1</span></span> and <span class="bracket"><span class="id">tm1</span></span>,
  and a <span class="bracket"><span class="id">match_callstack</span></span> relation for any callstack having
  <span class="bracket"><span class="id">e</span></span>, <span class="bracket"><span class="id">te1</span></span>, <span class="bracket"><span class="id">sp</span></span> as top frame.  The postcondition (bottom vertical bar)
  is the existence of a memory injection <span class="bracket"><span class="id">f2</span></span> that extends the injection
  <span class="bracket"><span class="id">f1</span></span> we started with, preserves the <span class="bracket"><span class="id">match_callstack</span></span> relation for
  the transformed callstack at the final state, and validates a
  <span class="bracket"><span class="id">outcome_inject</span></span> relation between the outcomes <span class="bracket"><span class="id">out</span></span> and <span class="bracket"><span class="id">tout</span></span>.
</div>
<br/>
<h2> Semantic preservation for expressions </h2>
<br/>
<span class="kwd">Remark</span> <span class="id">bool_of_val_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> <span class="id">b</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.bool_of_val</span> <span class="id">v</span> <span class="id">b</span> -&gt; <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt; <span class="id">Val.bool_of_val</span> <span class="id">tv</span> <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4606')">Proof.</div>
<div class="proofscript" id="proof4606">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_constant_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">cst</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.eval_constant</span> <span class="id">cst</span> = <span class="id">Some</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_constant</span> <span class="id">tge</span> <span class="id">sp</span> (<span class="id">transl_constant</span> <span class="id">cst</span>) = <span class="id">Some</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4607')">Proof.</div>
<div class="proofscript" id="proof4607">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cst</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vint</span> <span class="id">i</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vfloat</span> <span class="id">f0</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vsingle</span> <span class="id">f0</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Vlong</span> <span class="id">i</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_expr_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCH</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>)),<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.eval_expr</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_expr</span> <span class="id">cenv</span> <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_expr</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span> <span class="id">ta</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4608')">Proof.</div>
<div class="proofscript" id="proof4608">
&nbsp;&nbsp;<span class="tactic">induction</span> 3; <span class="tactic">intros</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>; <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">TR</span>).<br/>
&nbsp;Etempvar&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MATCH</span>. <span class="id">exploit</span> <span class="id">MTMP</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Eaddrof&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">var_addr_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Econst&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_constant_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Eunop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">EVAL1</span> <span class="id">INJ1</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_unop_compat</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">INJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;Ebinop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_expr1</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">EVAL1</span> <span class="id">INJ1</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_expr2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">EVAL2</span> <span class="id">INJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">eval_binop_compat</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">INJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;Eload&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_expr</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">EVAL1</span> <span class="id">INJ1</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.loadv_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">LOAD</span> <span class="id">INJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>; <span class="tactic">split</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_exprlist_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MATCH</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tf</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>)),<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.eval_exprlist</span> <span class="id">ge</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_exprlist</span> <span class="id">cenv</span> <span class="id">a</span> = <span class="id">OK</span> <span class="id">ta</span>),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_exprlist</span> <span class="id">tge</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span> <span class="id">ta</span> <span class="id">tv</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4609')">Proof.</div>
<div class="proofscript" id="proof4609">
&nbsp;&nbsp;<span class="tactic">induction</span> 3; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">EVAL1</span> <span class="id">VINJ1</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHeval_exprlist</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">EVAL2</span> <span class="id">VINJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">tv1</span> :: <span class="id">tv2</span>); <span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Semantic preservation for statements and functions </h2>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_cont</span>: <span class="id">Csharpminor.cont</span> -&gt; <span class="id">Cminor.cont</span> -&gt; <span class="id">compilenv</span> -&gt; <span class="id">exit_env</span> -&gt; <span class="id">callstack</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_Kstop</span>: <span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">xenv</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">Csharpminor.Kstop</span> <span class="id">Kstop</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kseq</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kseq</span> <span class="id">s</span> <span class="id">k</span>) (<span class="id">Kseq</span> <span class="id">ts</span> <span class="id">tk</span>) <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kseq2</span>: <span class="kwd">forall</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">ts1</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kseq</span> <span class="id">s2</span> <span class="id">k</span>) <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kseq</span> (<span class="id">Csharpminor.Sseq</span> <span class="id">s1</span> <span class="id">s2</span>) <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kseq</span> <span class="id">ts1</span> <span class="id">tk</span>) <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kblock</span>: <span class="kwd">forall</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kblock</span> <span class="id">k</span>) (<span class="id">Kblock</span> <span class="id">tk</span>) <span class="id">cenv</span> (<span class="id">true</span> :: <span class="id">xenv</span>) <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kblock2</span>: <span class="kwd">forall</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> (<span class="id">Kblock</span> <span class="id">tk</span>) <span class="id">cenv</span> (<span class="id">false</span> :: <span class="id">xenv</span>) <span class="id">cs</span><br/>
&nbsp;&nbsp;| <span class="id">match_Kcall</span>: <span class="kwd">forall</span> <span class="id">optid</span> <span class="id">fn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">k</span> <span class="id">tfn</span> <span class="id">sp</span> <span class="id">te</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">sz</span> <span class="id">cenv</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">fn</span> = <span class="id">OK</span> <span class="id">tfn</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kcall</span> <span class="id">optid</span> <span class="id">fn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Kcall</span> <span class="id">optid</span> <span class="id">tfn</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tk</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cenv</span>' <span class="id">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tfn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">Csharpminor.state</span> -&gt; <span class="id">Cminor.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_state</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fn</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tfn</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">sp</span> <span class="id">te</span> <span class="id">tm</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">f</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">fn</span> = <span class="id">OK</span> <span class="id">tfn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tfn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Csharpminor.State</span> <span class="id">fn</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">tfn</span> <span class="id">ts</span> <span class="id">tk</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_state_seq</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fn</span> <span class="id">s1</span> <span class="id">s2</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tfn</span> <span class="id">ts1</span> <span class="id">tk</span> <span class="id">sp</span> <span class="id">te</span> <span class="id">tm</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">f</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">fn</span> = <span class="id">OK</span> <span class="id">tfn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">s1</span> = <span class="id">OK</span> <span class="id">ts1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tfn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> (<span class="id">Csharpminor.Kseq</span> <span class="id">s2</span> <span class="id">k</span>) <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Csharpminor.State</span> <span class="id">fn</span> (<span class="id">Csharpminor.Sseq</span> <span class="id">s1</span> <span class="id">s2</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">tfn</span> <span class="id">ts1</span> <span class="id">tk</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_callstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tfd</span> <span class="id">targs</span> <span class="id">tk</span> <span class="id">tm</span> <span class="id">f</span> <span class="id">cs</span> <span class="id">cenv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_fundef</span> <span class="id">fd</span> = <span class="id">OK</span> <span class="id">tfd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">nil</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ISCC</span>: <span class="id">Csharpminor.is_call_cont</span> <span class="id">k</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGSINJ</span>: <span class="id">Val.inject_list</span> <span class="id">f</span> <span class="id">args</span> <span class="id">targs</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Csharpminor.Callstate</span> <span class="id">fd</span> <span class="id">args</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Callstate</span> <span class="id">tfd</span> <span class="id">targs</span> <span class="id">tk</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;| <span class="id">match_returnstate</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">k</span> <span class="id">m</span> <span class="id">tv</span> <span class="id">tk</span> <span class="id">tm</span> <span class="id">f</span> <span class="id">cs</span> <span class="id">cenv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span> <span class="id">cs</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">nil</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RESINJ</span>: <span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Csharpminor.Returnstate</span> <span class="id">v</span> <span class="id">k</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Returnstate</span> <span class="id">tv</span> <span class="id">tk</span> <span class="id">tm</span>).<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">val_inject_function_pointer</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">bound</span> <span class="id">v</span> <span class="id">fd</span> <span class="id">f</span> <span class="id">tv</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">fd</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_globalenvs</span> <span class="id">f</span> <span class="id">bound</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">f</span> <span class="id">v</span> <span class="id">tv</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tv</span> = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4610')">Proof.</div>
<div class="proofscript" id="proof4610">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">Genv.find_funct_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> <span class="id">EQ</span>]. <span class="tactic">subst</span> <span class="id">v</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_find_funct_ptr</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">f</span> <span class="id">b</span> = <span class="id">Some</span>(<span class="id">b</span>, 0)). <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">DOMAIN</span>. <span class="tactic">eapply</span> <span class="id">FUNCTIONS</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H5</span>; <span class="id">inv</span> <span class="id">H5</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.call_cont</span> <span class="id">k</span>) (<span class="id">call_cont</span> <span class="id">tk</span>) <span class="id">cenv</span> <span class="id">nil</span> <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4611')">Proof.</div>
<div class="proofscript" id="proof4611">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">auto</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_is_call_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">tfn</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">tm</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>,<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.is_call_cont</span> <span class="id">k</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tk</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">tfn</span> <span class="id">Sskip</span> <span class="id">tk</span> <span class="id">sp</span> <span class="id">te</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">tfn</span> <span class="id">Sskip</span> <span class="id">tk</span>' <span class="id">sp</span> <span class="id">te</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">is_call_cont</span> <span class="id">tk</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span>' <span class="id">cenv</span> <span class="id">nil</span> <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4612')">Proof.</div>
<div class="proofscript" id="proof4612">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">I</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHmatch_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tk</span>' [<span class="id">A</span> <span class="id">B</span>]]. <span class="id">exists</span> <span class="id">tk</span>'; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="id">traceEq</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>. <span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">I</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Properties of <span class="bracket"><span class="id">switch</span></span> compilation </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">lbl_stmt_tail</span>: <span class="id">lbl_stmt</span> -&gt; <span class="id">nat</span> -&gt; <span class="id">lbl_stmt</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">lstail_O</span>: <span class="kwd">forall</span> <span class="id">sl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">sl</span> <span class="id">O</span> <span class="id">sl</span><br/>
&nbsp;&nbsp;| <span class="id">lstail_S</span>: <span class="kwd">forall</span> <span class="id">c</span> <span class="id">s</span> <span class="id">sl</span> <span class="id">n</span> <span class="id">sl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">sl</span> <span class="id">n</span> <span class="id">sl</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> (<span class="id">LScons</span> <span class="id">c</span> <span class="id">s</span> <span class="id">sl</span>) (<span class="id">S</span> <span class="id">n</span>) <span class="id">sl</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_table_default</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">base</span>,<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">sl</span> <span class="id">n</span> (<span class="id">select_switch_default</span> <span class="id">sl</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">snd</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">base</span>) = (<span class="id">n</span> + <span class="id">base</span>)%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4613')">Proof.</div>
<div class="proofscript" id="proof4613">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">exists</span> <span class="id">O</span>; <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">omega</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">o</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> (<span class="id">IHsl</span> (<span class="id">S</span> <span class="id">base</span>)) <span class="kwd">as</span> (<span class="id">n</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="id">exists</span> (<span class="id">S</span> <span class="id">n</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">switch_table</span> <span class="id">sl</span> (<span class="id">S</span> <span class="id">base</span>)) <span class="kwd">as</span> [<span class="id">tbl</span> <span class="id">dfl</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exists</span> <span class="id">O</span>; <span class="tactic">split</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">switch_table</span> <span class="id">sl</span> (<span class="id">S</span> <span class="id">base</span>)) <span class="kwd">as</span> [<span class="id">tbl</span> <span class="id">dfl</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_table_case</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">sl</span> <span class="id">base</span> <span class="id">dfl</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">select_switch_case</span> <span class="id">i</span> <span class="id">sl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">switch_target</span> <span class="id">i</span> <span class="id">dfl</span> (<span class="id">fst</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">base</span>)) = <span class="id">dfl</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> <span class="id">sl</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">n</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">sl</span> <span class="id">n</span> <span class="id">sl</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">switch_target</span> <span class="id">i</span> <span class="id">dfl</span> (<span class="id">fst</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">base</span>)) = (<span class="id">n</span> + <span class="id">base</span>)%<span class="id">nat</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4614')">Proof.</div>
<div class="proofscript" id="proof4614">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">switch_table</span> <span class="id">sl</span> (<span class="id">S</span> <span class="id">base</span>)) <span class="kwd">as</span> [<span class="id">tbl1</span> <span class="id">dfl1</span>] <span class="id">eqn</span>:<span class="id">ST</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dec_eq_sym</span>. <span class="tactic">destruct</span> (<span class="id">zeq</span> <span class="id">i</span> <span class="id">z</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">O</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHsl</span> (<span class="id">S</span> <span class="id">base</span>) <span class="id">dfl</span>). <span class="tactic">rewrite</span> <span class="id">ST</span> <span class="kwd">in</span> <span class="id">IHsl</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">select_switch_case</span> <span class="id">i</span> <span class="id">sl</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHsl</span> <span class="kwd">as</span> (<span class="id">x</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="id">exists</span> (<span class="id">S</span> <span class="id">x</span>); <span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHsl</span> (<span class="id">S</span> <span class="id">base</span>) <span class="id">dfl</span>). <span class="tactic">rewrite</span> <span class="id">ST</span> <span class="kwd">in</span> <span class="id">IHsl</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">select_switch_case</span> <span class="id">i</span> <span class="id">sl</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHsl</span> <span class="kwd">as</span> (<span class="id">x</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="id">exists</span> (<span class="id">S</span> <span class="id">x</span>); <span class="tactic">split</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_table_select</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">sl</span>,<br/>
&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">sl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">switch_target</span> <span class="id">i</span> (<span class="id">snd</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">O</span>)) (<span class="id">fst</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">O</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">select_switch</span> <span class="id">i</span> <span class="id">sl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4615')">Proof.</div>
<div class="proofscript" id="proof4615">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">select_switch</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">switch_table_case</span> <span class="id">i</span> <span class="id">sl</span> <span class="id">O</span> (<span class="id">snd</span> (<span class="id">switch_table</span> <span class="id">sl</span> <span class="id">O</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">select_switch_case</span> <span class="id">i</span> <span class="id">sl</span>) <span class="kwd">as</span> [<span class="id">sl</span>'|].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">n</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>). <span class="tactic">replace</span> (<span class="id">n</span> + <span class="id">O</span>)%<span class="id">nat</span> <span class="kwd">with</span> <span class="id">n</span> <span class="kwd">in</span> <span class="id">Q</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">E</span>; <span class="tactic">rewrite</span> <span class="id">E</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">switch_table_default</span> <span class="id">sl</span> <span class="id">O</span>) <span class="kwd">as</span> (<span class="id">n</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">n</span> + <span class="id">O</span>)%<span class="id">nat</span> <span class="kwd">with</span> <span class="id">n</span> <span class="kwd">in</span> <span class="id">Q</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">transl_lblstmt_cont</span>(<span class="id">cenv</span>: <span class="id">compilenv</span>) (<span class="id">xenv</span>: <span class="id">exit_env</span>): <span class="id">lbl_stmt</span> -&gt; <span class="id">cont</span> -&gt; <span class="id">cont</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">tlsc_default</span>: <span class="kwd">forall</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">LSnil</span> <span class="id">k</span> (<span class="id">Kblock</span> (<span class="id">Kseq</span> <span class="id">Sskip</span> <span class="id">k</span>))<br/>
&nbsp;&nbsp;| <span class="id">tlsc_case</span>: <span class="kwd">forall</span> <span class="id">i</span> <span class="id">s</span> <span class="id">ls</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">k</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_stmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> (<span class="id">LScons</span> <span class="id">i</span> <span class="id">s</span> <span class="id">ls</span>) <span class="id">xenv</span>) <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">k</span> <span class="id">k</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> (<span class="id">LScons</span> <span class="id">i</span> <span class="id">s</span> <span class="id">ls</span>) <span class="id">k</span> (<span class="id">Kblock</span> (<span class="id">Kseq</span> <span class="id">ts</span> <span class="id">k</span>')).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_descent</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">k</span> <span class="id">ls</span> <span class="id">body</span> <span class="id">s</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">ls</span> <span class="id">body</span> = <span class="id">OK</span> <span class="id">s</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k</span>',<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">k</span> <span class="id">k</span>'<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">s</span> <span class="id">k</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>) <span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> <span class="id">body</span> <span class="id">k</span>' <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4616')">Proof.</div>
<div class="proofscript" id="proof4616">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H</span>. <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">plus_two</span>. <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H</span>. <span class="id">exploit</span> <span class="id">IHls</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">plus_star_trans</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="id">traceEq</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_ascent</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">n</span> <span class="id">ls</span>',<br/>
&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">ls</span> <span class="id">n</span> <span class="id">ls</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">k</span> <span class="id">k1</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">k</span> <span class="id">k1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k2</span>,<br/>
&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sexit</span> <span class="id">n</span>) <span class="id">k1</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">f</span> (<span class="id">Sexit</span> <span class="id">O</span>) <span class="id">k2</span> <span class="id">sp</span> <span class="id">e</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span>' <span class="id">k</span> <span class="id">k2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4617')">Proof.</div>
<div class="proofscript" id="proof4617">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
- <span class="id">exists</span> <span class="id">k1</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
- <span class="id">inv</span> <span class="id">H0</span>. <span class="id">exploit</span> <span class="id">IHlbl_stmt_tail</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">k2</span> &amp; <span class="id">P</span> &amp; <span class="id">Q</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">k2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>. <span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">constructor</span>. <span class="id">eexact</span> <span class="id">P</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_match_cont</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">k</span> <span class="id">cs</span> <span class="id">tk</span> <span class="id">ls</span> <span class="id">tk</span>',<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">tk</span> <span class="id">tk</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> (<span class="id">Csharpminor.Kseq</span> (<span class="id">seq_of_lbl_stmt</span> <span class="id">ls</span>) <span class="id">k</span>) <span class="id">tk</span>' <span class="id">cenv</span> (<span class="id">false</span> :: <span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4618')">Proof.</div>
<div class="proofscript" id="proof4618">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">match_Kblock2</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">match_Kblock2</span>. <span class="tactic">eapply</span> <span class="id">match_Kseq2</span>. <span class="tactic">auto</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">switch_match_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fn</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> <span class="id">tfn</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">sp</span> <span class="id">te</span> <span class="id">tm</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">f</span> <span class="id">lo</span> <span class="id">hi</span> <span class="id">cs</span> <span class="id">sz</span> <span class="id">ls</span> <span class="id">body</span> <span class="id">tk</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">sz</span> <span class="id">fn</span> = <span class="id">OK</span> <span class="id">tfn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TR</span>: <span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">ls</span> <span class="id">body</span> = <span class="id">OK</span> <span class="id">ts</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MINJ</span>: <span class="id">Mem.inject</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MCS</span>: <span class="id">match_callstack</span> <span class="id">f</span> <span class="id">m</span> <span class="id">tm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tfn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">MK</span>: <span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TK</span>: <span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">tk</span> <span class="id">tk</span>'),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">S</span>,<br/>
&nbsp;&nbsp;<span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> (<span class="id">State</span> <span class="id">tfn</span> (<span class="id">Sexit</span> <span class="id">O</span>) <span class="id">tk</span>' (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span>) <span class="id">E0</span> <span class="id">S</span><br/>
&nbsp;&nbsp;/\ <span class="id">match_states</span> (<span class="id">Csharpminor.State</span> <span class="id">fn</span> (<span class="id">seq_of_lbl_stmt</span> <span class="id">ls</span>) <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span>) <span class="id">S</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4619')">Proof.</div>
<div class="proofscript" id="proof4619">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">TK</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_two</span>. <span class="id">constructor</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_state</span>; <span class="tactic">eauto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">star_one</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">match_state_seq</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">eapply</span> <span class="id">switch_match_cont</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_lblstmt_suffix</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">n</span> <span class="id">ls</span>',<br/>
&nbsp;&nbsp;<span class="id">lbl_stmt_tail</span> <span class="id">ls</span> <span class="id">n</span> <span class="id">ls</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">body</span> <span class="id">ts</span>, <span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">ls</span> <span class="id">body</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">body</span>', <span class="id">exists</span> <span class="id">ts</span>', <span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span>' <span class="id">xenv</span>) <span class="id">ls</span>' <span class="id">body</span>' = <span class="id">OK</span> <span class="id">ts</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4620')">Proof.</div>
<div class="proofscript" id="proof4620">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
- <span class="id">exists</span> <span class="id">body</span>, <span class="id">ts</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Commutation between <span class="bracket"><span class="id">find_label</span></span> and compilation </div>
<br/>
<span class="kwd">Section</span> <span class="id">FIND_LABEL</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">lbl</span>: <span class="id">label</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cenv</span>: <span class="id">compilenv</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cs</span>: <span class="id">callstack</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_lblstmt_find_label_context</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">body</span> <span class="id">ts</span> <span class="id">tk1</span> <span class="id">tk2</span> <span class="id">ts</span>' <span class="id">tk</span>',<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">ls</span> <span class="id">body</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">tk1</span> <span class="id">tk2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">body</span> <span class="id">tk2</span> = <span class="id">Some</span> (<span class="id">ts</span>', <span class="id">tk</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk1</span> = <span class="id">Some</span> (<span class="id">ts</span>', <span class="id">tk</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4621')">Proof.</div>
<div class="proofscript" id="proof4621">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">ls</span>; <span class="tactic">intros</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
- <span class="id">monadInv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">eapply</span> <span class="id">IHls</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> <span class="id">x</span> <span class="kwd">with</span> <span class="id">ts0</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">k</span> <span class="id">xenv</span> <span class="id">ts</span> <span class="id">tk</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">s</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Csharpminor.find_label</span> <span class="id">lbl</span> <span class="id">s</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>', <span class="id">exists</span> <span class="id">xenv</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">Some</span>(<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">k</span>' <span class="id">tk</span>' <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">cs</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span><br/>
<br/>
<span class="kwd">with</span> <span class="id">transl_lblstmt_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">xenv</span> <span class="id">body</span> <span class="id">k</span> <span class="id">ts</span> <span class="id">tk</span> <span class="id">tk1</span>,<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt</span> <span class="id">cenv</span> (<span class="id">switch_env</span> <span class="id">ls</span> <span class="id">xenv</span>) <span class="id">ls</span> <span class="id">body</span> = <span class="id">OK</span> <span class="id">ts</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transl_lblstmt_cont</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">ls</span> <span class="id">tk</span> <span class="id">tk1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">body</span> <span class="id">tk1</span> = <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">Csharpminor.find_label_ls</span> <span class="id">lbl</span> <span class="id">ls</span> <span class="id">k</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span>(<span class="id">s</span>', <span class="id">k</span>') =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>', <span class="id">exists</span> <span class="id">xenv</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">ts</span> <span class="id">tk</span> = <span class="id">Some</span>(<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">k</span>' <span class="id">tk</span>' <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">cs</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4622')">Proof.</div>
<div class="proofscript" id="proof4622">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">try</span> (<span class="id">monadInv</span> <span class="id">H</span>); <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s1</span>). <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_Kseq</span>. <span class="id">eexact</span> <span class="id">EQ1</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Csharpminor.find_label</span> <span class="id">lbl</span> <span class="id">s1</span> (<span class="id">Csharpminor.Kseq</span> <span class="id">s2</span> <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">xenv</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">xenv</span>'. <span class="tactic">intuition</span>. <span class="tactic">rewrite</span> <span class="id">A</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">transl_find_label</span> <span class="kwd">with</span> <span class="id">xenv</span>; <span class="tactic">auto</span>.<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s1</span>). <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Csharpminor.find_label</span> <span class="id">lbl</span> <span class="id">s1</span> <span class="id">k</span>) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>'] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">xenv</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">xenv</span>'. <span class="tactic">intuition</span>. <span class="tactic">rewrite</span> <span class="id">A</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">transl_find_label</span> <span class="kwd">with</span> <span class="id">xenv</span>; <span class="tactic">auto</span>.<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_find_label</span> <span class="kwd">with</span> <span class="id">xenv</span>. <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_find_label</span> <span class="kwd">with</span> (<span class="id">true</span> :: <span class="id">xenv</span>). <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> (<span class="id">switch_table</span> <span class="id">l</span> <span class="id">O</span>) <span class="kwd">as</span> [<span class="id">tbl</span> <span class="id">dfl</span>]. <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">switch_descent</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_lblstmt_find_label</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">o</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ident_eq</span> <span class="id">lbl</span> <span class="id">l</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>; <span class="id">exists</span> <span class="id">tk</span>; <span class="id">exists</span> <span class="id">xenv</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_find_label</span> <span class="kwd">with</span> <span class="id">xenv</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">ls</span>; <span class="id">monadInv</span> <span class="id">H</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;nil&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;cons&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">transl_find_label</span> <span class="id">s</span>). <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">switch_match_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Csharpminor.find_label</span> <span class="id">lbl</span> <span class="id">s</span> (<span class="id">Csharpminor.Kseq</span> (<span class="id">seq_of_lbl_stmt</span> <span class="id">ls</span>) <span class="id">k</span>)) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">k</span>''] | ].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">xenv</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>'; <span class="id">exists</span> <span class="id">tk</span>'; <span class="id">exists</span> <span class="id">xenv</span>'; <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_lblstmt_find_label_context</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">replace</span> <span class="id">x</span> <span class="kwd">with</span> <span class="id">ts0</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">eapply</span> <span class="id">transl_lblstmt_find_label</span>. <span class="tactic">eauto</span>. <span class="tactic">auto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">replace</span> <span class="id">x</span> <span class="kwd">with</span> <span class="id">ts0</span> <span class="tactic">by</span> <span class="tactic">congruence</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">FIND_LABEL</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_find_label_body</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">size</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cs</span> <span class="id">lbl</span> <span class="id">s</span>' <span class="id">k</span>',<br/>
&nbsp;&nbsp;<span class="id">transl_funbody</span> <span class="id">cenv</span> <span class="id">size</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_cont</span> <span class="id">k</span> <span class="id">tk</span> <span class="id">cenv</span> <span class="id">xenv</span> <span class="id">cs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Csharpminor.find_label</span> <span class="id">lbl</span> <span class="id">f</span>.(<span class="id">Csharpminor.fn_body</span>) (<span class="id">Csharpminor.call_cont</span> <span class="id">k</span>) = <span class="id">Some</span> (<span class="id">s</span>', <span class="id">k</span>') -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ts</span>', <span class="id">exists</span> <span class="id">tk</span>', <span class="id">exists</span> <span class="id">xenv</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_label</span> <span class="id">lbl</span> <span class="id">tf</span>.(<span class="id">fn_body</span>) (<span class="id">call_cont</span> <span class="id">tk</span>) = <span class="id">Some</span>(<span class="id">ts</span>', <span class="id">tk</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">transl_stmt</span> <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">s</span>' = <span class="id">OK</span> <span class="id">ts</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">match_cont</span> <span class="id">k</span>' <span class="id">tk</span>' <span class="id">cenv</span> <span class="id">xenv</span>' <span class="id">cs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4623')">Proof.</div>
<div class="proofscript" id="proof4623">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">monadInv</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_find_label</span>. <span class="id">eexact</span> <span class="id">EQ</span>. <span class="tactic">eapply</span> <span class="id">match_call_cont</span>. <span class="id">eexact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">lbl</span>). <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The simulation diagram. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">seq_left_depth</span> (<span class="id">s</span>: <span class="id">Csharpminor.stmt</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">s</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Csharpminor.Sseq</span> <span class="id">s1</span> <span class="id">s2</span> =&gt; <span class="id">S</span> (<span class="id">seq_left_depth</span> <span class="id">s1</span>)<br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">O</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">S</span>: <span class="id">Csharpminor.state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">S</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Csharpminor.State</span> <span class="id">fn</span> <span class="id">s</span> <span class="id">k</span> <span class="id">e</span> <span class="id">le</span> <span class="id">m</span> =&gt; <span class="id">seq_left_depth</span> <span class="id">s</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">O</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span>, <span class="id">Csharpminor.step</span> <span class="id">ge</span> <span class="id">S1</span> <span class="id">t</span> <span class="id">S2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">T1</span>, <span class="id">match_states</span> <span class="id">S1</span> <span class="id">T1</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">exists</span> <span class="id">T2</span>, <span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> <span class="id">T1</span> <span class="id">t</span> <span class="id">T2</span> /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">T2</span>)<br/>
&nbsp;&nbsp;\/ (<span class="kwd">measure</span> <span class="id">S2</span> &lt; <span class="kwd">measure</span> <span class="id">S1</span> /\ <span class="id">t</span> = <span class="id">E0</span> /\ <span class="id">match_states</span> <span class="id">S2</span> <span class="id">T1</span>)%<span class="id">nat</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4624')">Proof.</div>
<div class="proofscript" id="proof4624">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span> <span class="id">T1</span> <span class="id">MSTATE</span>; <span class="id">inv</span> <span class="id">MSTATE</span>.<br/>
<br/>
&nbsp;skip&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_state_seq</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;skip&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;skip&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_is_call_cont</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tk</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_freelist</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">P</span> [<span class="id">Q</span> <span class="id">R</span>]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">step_skip_call</span>. <span class="tactic">auto</span>. <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;set&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">VINJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_set_temp</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;store&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tv1</span> [<span class="id">EVAL1</span> <span class="id">VINJ1</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">H0</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tv2</span> [<span class="id">EVAL2</span> <span class="id">VINJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">Mem.storev_mapped_inject</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">STORE</span>' <span class="id">MINJ</span>']].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">VINJ1</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>. <span class="tactic">unfold</span> <span class="id">Mem.storev</span> <span class="kwd">in</span> <span class="id">STORE</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">Mem.nextblock_store</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">Mem.nextblock_store</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">STORE</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_invariant</span> <span class="kwd">with</span> <span class="id">f0</span> <span class="id">m</span> <span class="id">tm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_store_2</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_store_1</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">exploit</span> <span class="id">functions_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tfd</span> [<span class="id">FIND</span> <span class="id">TRANS</span>]].<br/>
&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tvf</span> [<span class="id">EVAL1</span> <span class="id">VINJ1</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tvf</span> = <span class="id">vf</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_match_globalenvs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">bnd</span> <span class="id">MG</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">val_inject_function_pointer</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">tvf</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tvargs</span> [<span class="id">EVAL2</span> <span class="id">VINJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sig_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_Kcall</span> <span class="kwd">with</span> (<span class="id">cenv</span>' := <span class="id">cenv</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;builtin&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_exprlist_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">tvargs</span> [<span class="id">EVAL2</span> <span class="id">VINJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_match_globalenvs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">hi</span>' <span class="id">MG</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">inj_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">f</span>' [<span class="id">vres</span>' [<span class="id">tm</span>' [<span class="id">EC</span> [<span class="id">VINJ</span> [<span class="id">MINJ</span>' [<span class="id">UNMAPPED</span> [<span class="id">OUTOFREACH</span> [<span class="id">INCR</span> <span class="id">SEPARATED</span>]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">MCS</span>': <span class="id">match_callstack</span> <span class="id">f</span>' <span class="id">m</span>' <span class="id">tm</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Frame</span> <span class="id">cenv</span> <span class="id">tfn</span> <span class="id">e</span> <span class="id">le</span> <span class="id">te</span> <span class="id">sp</span> <span class="id">lo</span> <span class="id">hi</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mem.nextblock</span> <span class="id">m</span>') (<span class="id">Mem.nextblock</span> <span class="id">tm</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_callstack_incr_bound</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_external_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">external_call_max_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<span class="id">Opaque</span> <span class="id">PTree.set</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">set_optvar</span>. <span class="tactic">destruct</span> <span class="id">optid</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_set_temp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;seq&nbsp;2&nbsp;*)</span>&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;ifthenelse&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">VINJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">exists</span> (<span class="id">State</span> <span class="id">tfn</span> (<span class="kwd">if</span> <span class="id">b</span> <span class="kwd">then</span> <span class="id">x0</span> <span class="kwd">else</span> <span class="id">x1</span>) <span class="id">tk</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">te</span> <span class="id">tm</span>); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_ifthenelse</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">bool_of_val_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">destruct</span> <span class="id">b</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">EQ</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;block&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;exit&nbsp;seq&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">plus_left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
<br/>
&nbsp;exit&nbsp;block&nbsp;0&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
<br/>
&nbsp;exit&nbsp;block&nbsp;n+1&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">MK</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHMK</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">plus_star</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
<br/>
&nbsp;switch&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TR</span>. <span class="tactic">destruct</span> (<span class="id">switch_table</span> <span class="id">cases</span> <span class="id">O</span>) <span class="kwd">as</span> [<span class="id">tbl</span> <span class="id">dfl</span>] <span class="id">eqn</span>:<span class="id">STBL</span>. <span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">VINJ</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SA</span>: <span class="id">switch_argument</span> <span class="id">islong</span> <span class="id">tv</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;{ <span class="id">inv</span> <span class="id">H0</span>; <span class="id">inv</span> <span class="id">VINJ</span>; <span class="id">constructor</span>. }<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">switch_descent</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">k1</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">switch_ascent</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> (<span class="id">switch_table_select</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">STBL</span>; <span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">k2</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_lblstmt_suffix</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> (<span class="id">switch_table_select</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">intros</span> [<span class="id">body</span>' [<span class="id">ts</span>' <span class="id">E</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">switch_match_states</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">T2</span> [<span class="id">F</span> <span class="id">G</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">exists</span> <span class="id">T2</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_star_trans</span>. <span class="tactic">eapply</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_left</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">star_trans</span>. <span class="id">eexact</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_star</span>. <span class="id">eexact</span> <span class="id">F</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">reflexivity</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;return&nbsp;none&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_freelist</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_return_0</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_call_cont</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;return&nbsp;some&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_expr_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tv</span> [<span class="id">EVAL</span> <span class="id">VINJ</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_freelist</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tm</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">step_return_1</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">eapply</span> <span class="id">match_call_cont</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;label&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;goto&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_find_label_body</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">ts</span>' [<span class="id">tk</span>' [<span class="id">xenv</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">step_goto</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;internal&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>. <span class="tactic">generalize</span> <span class="id">EQ</span>; <span class="tactic">clear</span> <span class="id">EQ</span>; <span class="tactic">unfold</span> <span class="id">transl_function</span>.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">build_compilenv</span> <span class="id">f</span>). <span class="tactic">intros</span> <span class="id">ce</span> <span class="id">sz</span> <span class="id">BC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zle</span> <span class="id">sz</span> <span class="id">Ptrofs.max_unsigned</span>); <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">TRBODY</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRBODY</span>; <span class="tactic">intro</span> <span class="id">TMP</span>. <span class="id">monadInv</span> <span class="id">TMP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">tf</span> := <span class="id">mkfunction</span> (<span class="id">Csharpminor.fn_sig</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Csharpminor.fn_params</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Csharpminor.fn_temps</span> <span class="id">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sz</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x0</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="id">caseEq</span> (<span class="id">Mem.alloc</span> <span class="id">tm</span> 0 (<span class="id">fn_stackspace</span> <span class="id">tf</span>)). <span class="tactic">intros</span> <span class="id">tm</span>' <span class="id">sp</span> <span class="id">ALLOC</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_function_entry</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">f2</span> [<span class="id">MCS2</span> <span class="id">MINJ2</span>]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">constructor</span>; <span class="tactic">simpl</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">eexact</span> <span class="id">TRBODY</span>. <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">MINJ2</span>. <span class="id">eexact</span> <span class="id">MCS2</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MK</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">ISCC</span>; <span class="id">contradiction</span> || <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;external&nbsp;call&nbsp;*)</span>&nbsp;&nbsp;<span class="id">monadInv</span> <span class="id">TR</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">match_callstack_match_globalenvs</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">hi</span> <span class="id">MG</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_mem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">inj_preserves_globals</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">f</span>' [<span class="id">vres</span>' [<span class="id">tm</span>' [<span class="id">EC</span> [<span class="id">VINJ</span> [<span class="id">MINJ</span>' [<span class="id">UNMAPPED</span> [<span class="id">OUTOFREACH</span> [<span class="id">INCR</span> <span class="id">SEPARATED</span>]]]]]]]]].<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_callstack_incr_bound</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>) (<span class="id">Mem.nextblock</span> <span class="id">tm</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_external_call</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">external_call_max_perm</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_nextblock</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;return&nbsp;*)</span>&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MK</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>; <span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">set_optvar</span>. <span class="tactic">destruct</span> <span class="id">optid</span>; <span class="tactic">simpl</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstack_set_temp</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_globalenvs_init</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.init_mem</span> <span class="id">prog</span> = <span class="id">Some</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_globalenvs</span> (<span class="id">Mem.flat_inj</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)) (<span class="id">Mem.nextblock</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4625')">Proof.</div>
<div class="proofscript" id="proof4625">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span>. <span class="tactic">apply</span> <span class="id">pred_dec_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">Mem.flat_inj</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b1</span> (<span class="id">Mem.nextblock</span> <span class="id">m</span>)); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_symbol_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_funct_ptr_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Genv.find_var_info_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span>, <span class="id">Csharpminor.initial_state</span> <span class="id">prog</span> <span class="id">S</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">R</span>, <span class="id">Cminor.initial_state</span> <span class="id">tprog</span> <span class="id">R</span> /\ <span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4626')">Proof.</div>
<div class="proofscript" id="proof4626">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">FIND</span> <span class="id">TR</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">Genv.init_mem_transf_partial</span> <span class="id">TRANSL</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">fold</span> <span class="id">tge</span>. <span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">prog_main</span> <span class="id">tprog</span>) <span class="kwd">with</span> (<span class="id">prog_main</span> <span class="id">prog</span>). <span class="id">eexact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">unfold</span> <span class="id">transl_program</span> <span class="kwd">in</span> <span class="id">TRANSL</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_program_main</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">FIND</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H2</span>. <span class="tactic">apply</span> <span class="id">sig_preserved</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_callstate</span> <span class="kwd">with</span> (<span class="id">f</span> := <span class="id">Mem.flat_inj</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)) (<span class="id">cs</span> := @<span class="id">nil</span> <span class="id">frame</span>) (<span class="id">cenv</span> := <span class="id">PTree.empty</span> <span class="id">Z</span>).<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.initmem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mcs_nil</span> <span class="kwd">with</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>). <span class="tactic">apply</span> <span class="id">match_globalenvs_init</span>; <span class="tactic">auto</span>. <span class="id">xomega</span>. <span class="id">xomega</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">S</span> <span class="id">R</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">S</span> <span class="id">R</span> -&gt; <span class="id">Csharpminor.final_state</span> <span class="id">S</span> <span class="id">r</span> -&gt; <span class="id">Cminor.final_state</span> <span class="id">R</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4627')">Proof.</div>
<div class="proofscript" id="proof4627">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">MK</span>. <span class="id">inv</span> <span class="id">RESINJ</span>. <span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transl_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">Csharpminor.semantics</span> <span class="id">prog</span>) (<span class="id">Cminor.semantics</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4628')">Proof.</div>
<div class="proofscript" id="proof4628">
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_star</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_initial_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_final_states</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">transl_step_correct</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">TRANSLATION</span>.<br/>
<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
