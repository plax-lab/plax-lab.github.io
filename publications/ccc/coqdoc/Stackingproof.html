<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Stackingproof</title>
<meta name="description" content="Documentation of Coq module Stackingproof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Stackingproof</h1>
<div class="coq">
<br/>
<div class="doc">Correctness proof for the translation from Linear to Mach. </div>
<br/>
<div class="doc">This file proves semantic preservation for the <span class="bracket"><span class="id">Stacking</span></span> pass. </div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span> <span class="id">Errors</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Integers</span> <span class="id">AST</span> <span class="id">Linking</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Values</span> <span class="id">Memory</span> <span class="id">Separation</span> <span class="id">Events</span> <span class="id">Globalenvs</span> <span class="id">Smallstep</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">LTL</span> <span class="id">Op</span> <span class="id">Locations</span> <span class="id">Linear</span> <span class="id">Mach</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Bounds</span> <span class="id">Conventions</span> <span class="id">Stacklayout</span> <span class="id">Lineartyping</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Stacking</span>.<br/>
<br/>
<span class="kwd">Local</span> <span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">sep_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">match_prog</span> (<span class="id">p</span>: <span class="id">Linear.program</span>) (<span class="id">tp</span>: <span class="id">Mach.program</span>) :=<br/>
&nbsp;&nbsp;<span class="id">match_program</span> (<span class="kwd">fun</span> <span class="id">_</span> <span class="id">f</span> <span class="id">tf</span> =&gt; <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>) <span class="id">eq</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_program_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span> <span class="id">tp</span>, <span class="id">transf_program</span> <span class="id">p</span> = <span class="id">OK</span> <span class="id">tp</span> -&gt; <span class="id">match_prog</span> <span class="id">p</span> <span class="id">tp</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3706')">Proof.</div>
<div class="proofscript" id="proof3706">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">match_transform_partial_program</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h1> Basic properties of the translation </h1>
<br/>
<span class="kwd">Lemma</span> <span class="id">typesize_typesize</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span>, <span class="id">AST.typesize</span> <span class="id">ty</span> = 4 * <span class="id">Locations.typesize</span> <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3707')">Proof.</div>
<div class="proofscript" id="proof3707">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">size_type_chunk</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span>, <span class="id">size_chunk</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) = <span class="id">AST.typesize</span> <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3708')">Proof.</div>
<div class="proofscript" id="proof3708">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">align_type_chunk</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span>, <span class="id">align_chunk</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) = 4 * <span class="id">Locations.typealign</span> <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3709')">Proof.</div>
<div class="proofscript" id="proof3709">
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">slot_outgoing_argument_valid</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">sg</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) -&gt; <span class="id">slot_valid</span> <span class="id">f</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3710')">Proof.</div>
<div class="proofscript" id="proof3710">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">loc_arguments_acceptable_2</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">slot_valid</span>. <span class="tactic">unfold</span> <span class="id">proj_sumbool</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zle_true</span> <span class="tactic">by</span> <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">load_result_inject</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ty</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt; <span class="id">Val.has_type</span> <span class="id">v</span> <span class="id">ty</span> -&gt; <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> (<span class="id">Val.load_result</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">v</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3711')">Proof.</div>
<div class="proofscript" id="proof3711">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">v</span>'; <span class="tactic">unfold</span> <span class="id">Val.has_type</span>, <span class="id">Val.load_result</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>;<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> 1; <span class="tactic">intros</span>; <span class="tactic">auto</span>; <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">simpl</span>;<br/>
&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">contradiction</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>; <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Section</span> <span class="id">PRESERVATION</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">return_address_offset</span>: <span class="id">Mach.function</span> -&gt; <span class="id">Mach.code</span> -&gt; <span class="id">ptrofs</span> -&gt; <span class="kwd">Prop</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">return_address_offset_exists</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">sg</span> <span class="id">ros</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">Mcall</span> <span class="id">sg</span> <span class="id">ros</span> :: <span class="id">c</span>) (<span class="id">fn_code</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">ofs</span>, <span class="id">return_address_offset</span> <span class="id">f</span> <span class="id">c</span> <span class="id">ofs</span>.<br/>
<br/>
<span class="kwd">Let</span> <span class="id">step</span> := <span class="id">Mach.step</span> <span class="id">return_address_offset</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">prog</span>: <span class="id">Linear.program</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tprog</span>: <span class="id">Mach.program</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF</span>: <span class="id">match_prog</span> <span class="id">prog</span> <span class="id">tprog</span>.<br/>
<span class="kwd">Let</span> <span class="id">ge</span> := <span class="id">Genv.globalenv</span> <span class="id">prog</span>.<br/>
<span class="kwd">Let</span> <span class="id">tge</span> := <span class="id">Genv.globalenv</span> <span class="id">tprog</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">FRAME_PROPERTIES</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: <span class="id">Linear.function</span>.<br/>
<span class="kwd">Let</span> <span class="id">b</span> := <span class="id">function_bounds</span> <span class="id">f</span>.<br/>
<span class="kwd">Let</span> <span class="id">fe</span> := <span class="id">make_env</span> <span class="id">b</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tf</span>: <span class="id">Mach.function</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF_F</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">unfold_transf_function</span>:<br/>
&nbsp;&nbsp;<span class="id">tf</span> = <span class="id">Mach.mkfunction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">Linear.fn_sig</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">transl_body</span> <span class="id">f</span> <span class="id">fe</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fe</span>.(<span class="id">fe_size</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ptrofs.repr</span> <span class="id">fe</span>.(<span class="id">fe_ofs_link</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ptrofs.repr</span> <span class="id">fe</span>.(<span class="id">fe_ofs_retaddr</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3712')">Proof.</div>
<div class="proofscript" id="proof3712">
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRANSF_F</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">wt_function</span> <span class="id">f</span>); <span class="tactic">simpl</span> <span class="id">negb</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">fe_size</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)))).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fe</span>. <span class="tactic">unfold</span> <span class="id">b</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_function_well_typed</span>:<br/>
&nbsp;&nbsp;<span class="id">wt_function</span> <span class="id">f</span> = <span class="id">true</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3713')">Proof.</div>
<div class="proofscript" id="proof3713">
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRANSF_F</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">wt_function</span> <span class="id">f</span>); <span class="tactic">simpl</span> <span class="id">negb</span>. <span class="tactic">auto</span>. <span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">size_no_overflow</span>: <span class="id">fe</span>.(<span class="id">fe_size</span>) &lt;= <span class="id">Ptrofs.max_unsigned</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3714')">Proof.</div>
<div class="proofscript" id="proof3714">
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="id">TRANSF_F</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">wt_function</span> <span class="id">f</span>); <span class="tactic">simpl</span> <span class="id">negb</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">zlt</span> <span class="id">Ptrofs.max_unsigned</span> (<span class="id">fe_size</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)))).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">fe</span>. <span class="tactic">unfold</span> <span class="id">b</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">bound_stack_data_stacksize</span>:<br/>
&nbsp;&nbsp;<span class="id">f</span>.(<span class="id">Linear.fn_stacksize</span>) &lt;= <span class="id">b</span>.(<span class="id">bound_stack_data</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3715')">Proof.</div>
<div class="proofscript" id="proof3715">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">b</span>, <span class="id">function_bounds</span>, <span class="id">bound_stack_data</span>. <span class="tactic">apply</span> <span class="id">Zmax1</span>.<br/>
Qed.</div>
<br/>
<h1> Memory assertions used to describe the contents of stack frames </h1>
<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">Z.add</span> <span class="id">Z.mul</span> <span class="id">Z.divide</span>.<br/>
<br/>
<div class="doc">Accessing the stack frame using <span class="bracket"><span class="id">load_stack</span></span> and <span class="bracket"><span class="id">store_stack</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_get_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">spec</span> <span class="id">m</span> <span class="id">ty</span> <span class="id">sp</span> <span class="id">ofs</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> <span class="id">ofs</span> <span class="id">spec</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span> /\ <span class="id">spec</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3716')">Proof.</div>
<div class="proofscript" id="proof3716">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">load_stack</span>. <br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Val.offset_ptr</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)) <span class="kwd">with</span> (<span class="id">Vptr</span> <span class="id">sp</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">loadv_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">hasvalue_get_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">hasvalue</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> <span class="id">ofs</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3717')">Proof.</div>
<div class="proofscript" id="proof3717">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">contains_get_stack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_set_stack</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">spec</span>: <span class="id">val</span> -&gt; <span class="kwd">Prop</span>) <span class="id">v</span> <span class="id">spec1</span> <span class="id">m</span> <span class="id">ty</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> <span class="id">ofs</span> <span class="id">spec1</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">spec</span> (<span class="id">Val.load_result</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">v</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">store_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>) <span class="id">v</span> = <span class="id">Some</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">contains</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> <span class="id">ofs</span> <span class="id">spec</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3718')">Proof.</div>
<div class="proofscript" id="proof3718">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">store_stack</span>. <br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">Val.offset_ptr</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)) <span class="kwd">with</span> (<span class="id">Vptr</span> <span class="id">sp</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">storev_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span></span> is a separation logic assertion
  that holds if the memory area at block <span class="bracket"><span class="id">sp</span></span>, offset <span class="bracket"><span class="id">pos</span></span>, size <span class="bracket">4 * <span class="id">bound</span></span>,
  reflects the values of the stack locations of kind <span class="bracket"><span class="id">sl</span></span> given by the
  location map <span class="bracket"><span class="id">ls</span></span>, up to the memory injection <span class="bracket"><span class="id">j</span></span>.
  Two such <span class="bracket"><span class="id">contains_locations</span></span> assertions will be used later, one to
  reason about the values of <span class="bracket"><span class="kwd">Local</span></span> slots, the other about the values of
  <span class="bracket"><span class="id">Outgoing</span></span> slots. </div>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">contains_locations</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">pos</span> <span class="id">bound</span>: <span class="id">Z</span>) (<span class="id">sl</span>: <span class="id">slot</span>) (<span class="id">ls</span>: <span class="id">locset</span>) : <span class="id">massert</span> := {|<br/>
&nbsp;&nbsp;<span class="id">m_pred</span> := <span class="kwd">fun</span> <span class="id">m</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(8 | <span class="id">pos</span>) /\ 0 &lt;= <span class="id">pos</span> /\ <span class="id">pos</span> + 4 * <span class="id">bound</span> &lt;= <span class="id">Ptrofs.modulus</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>) <span class="id">Cur</span> <span class="id">Freeable</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>, 0 &lt;= <span class="id">ofs</span> -&gt; <span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span> &lt;= <span class="id">bound</span> -&gt; (<span class="id">typealign</span> <span class="id">ty</span> | <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">Mem.load</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">m</span> <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>) = <span class="id">Some</span> <span class="id">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>)) <span class="id">v</span>;<br/>
&nbsp;&nbsp;<span class="id">m_footprint</span> := <span class="kwd">fun</span> <span class="id">b</span> <span class="id">ofs</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">b</span> = <span class="id">sp</span> /\ <span class="id">pos</span> &lt;= <span class="id">ofs</span> &lt; <span class="id">pos</span> + 4 * <span class="id">bound</span><br/>
|}.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3719')">Next Obligation.</div>
<div class="proofscript" id="proof3719">
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>. <br/>
- <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_unchanged_on</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">exploit</span> <span class="id">H4</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_unchanged_on</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">size_type_chunk</span>, <span class="id">typesize_typesize</span> <span class="kwd">in</span> <span class="id">H8</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<div class="toggleproof" onclick="toggleDisplay('proof3720')">Next Obligation.</div>
<div class="proofscript" id="proof3720">
&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">valid_access_location</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;(8 | <span class="id">pos</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.range_perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>) <span class="id">Cur</span> <span class="id">Freeable</span> -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">ofs</span> -&gt; <span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span> &lt;= <span class="id">bound</span> -&gt; (<span class="id">typealign</span> <span class="id">ty</span> | <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.valid_access</span> <span class="id">m</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>) <span class="id">p</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3721')">Proof.</div>
<div class="proofscript" id="proof3721">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>.<br/>
- <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">Mem.perm_implies</span> <span class="kwd">with</span> <span class="id">Freeable</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> <span class="id">size_type_chunk</span>, <span class="id">typesize_typesize</span> <span class="kwd">in</span> <span class="id">H4</span>. <span class="tactic">omega</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">align_type_chunk</span>. <span class="tactic">apply</span> <span class="id">Z.divide_add_r</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zdivide_trans</span> <span class="kwd">with</span> 8; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (8 / (4 * <span class="id">typealign</span> <span class="id">ty</span>)); <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Z.mul_divide_mono_l</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">get_location</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span> <span class="id">ofs</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span> -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">ofs</span> -&gt; <span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span> &lt;= <span class="id">bound</span> -&gt; (<span class="id">typealign</span> <span class="id">ty</span> | <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>)) = <span class="id">Some</span> <span class="id">v</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>)) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3722')">Proof.</div>
<div class="proofscript" id="proof3722">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> (<span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span> &amp; <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">U</span> &amp; <span class="id">V</span>). <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">load_stack</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>, <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Ptrofs.max_unsigned</span>. <span class="tactic">generalize</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">set_location</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span> <span class="id">P</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;0 &lt;= <span class="id">ofs</span> -&gt; <span class="id">ofs</span> + <span class="id">typesize</span> <span class="id">ty</span> &lt;= <span class="id">bound</span> -&gt; (<span class="id">typealign</span> <span class="id">ty</span> | <span class="id">ofs</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">store_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>)) <span class="id">v</span>' = <span class="id">Some</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">v</span> <span class="id">ls</span>) ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3723')">Proof.</div>
<div class="proofscript" id="proof3723">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span> &amp; <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="id">edestruct</span> <span class="id">Mem.valid_access_store</span> <span class="kwd">as</span> [<span class="id">m</span>' <span class="id">STORE</span>]. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">valid_access_location</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">PERM</span>: <span class="id">Mem.range_perm</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>) <span class="id">Cur</span> <span class="id">Freeable</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>. }<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>'; <span class="tactic">split</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">store_stack</span>; <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero_l</span>, <span class="id">Ptrofs.unsigned_repr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Ptrofs.max_unsigned</span>. <span class="tactic">generalize</span> (<span class="id">typesize_pos</span> <span class="id">ty</span>). <span class="tactic">omega</span>.<br/>
- <span class="tactic">simpl</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
+ <span class="tactic">unfold</span> <span class="id">Locmap.set</span>. <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Loc.eq</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs0</span> <span class="id">ty0</span>)); [|<span class="tactic">destruct</span> (<span class="id">Loc.diff_dec</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs0</span> <span class="id">ty0</span>))].<br/>
* <span class="comment">(*&nbsp;same&nbsp;location&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">e</span>. <span class="tactic">rename</span> <span class="id">ofs0</span> <span class="id">into</span> <span class="id">ofs</span>. <span class="tactic">rename</span> <span class="id">ty0</span> <span class="id">into</span> <span class="id">ty</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Val.load_result</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">v</span>'); <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.load_store_similar_2</span>; <span class="tactic">eauto</span>. <span class="tactic">omega</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.load_result_inject</span>; <span class="tactic">auto</span>.<br/>
* <span class="comment">(*&nbsp;different&nbsp;locations&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v0</span> &amp; <span class="id">X</span> &amp; <span class="id">Y</span>). <span class="id">exists</span> <span class="id">v0</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">X</span>; <span class="tactic">eapply</span> <span class="id">Mem.load_store_other</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>. <span class="tactic">congruence</span>. <span class="id">right</span>. <span class="tactic">rewrite</span> ! <span class="id">size_type_chunk</span>, ! <span class="id">typesize_typesize</span>. <span class="tactic">omega</span>.<br/>
* <span class="comment">(*&nbsp;overlapping&nbsp;locations&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.valid_access_load</span> <span class="id">m</span>' (<span class="id">chunk_of_type</span> <span class="id">ty0</span>) <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs0</span>)) <span class="kwd">as</span> [<span class="id">v</span>'' <span class="id">LOAD</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Mem.valid_access_implies</span> <span class="kwd">with</span> <span class="id">Writable</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">mem</span>. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">valid_access_location</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>''; <span class="tactic">auto</span>.<br/>
+ <span class="tactic">apply</span> (<span class="id">m_invar</span> <span class="id">P</span>) <span class="kwd">with</span> <span class="id">m</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Mem.store_unchanged_on</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">i</span>; <span class="tactic">rewrite</span> <span class="id">size_type_chunk</span>, <span class="id">typesize_typesize</span>. <span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">eelim</span> <span class="id">C</span>; <span class="tactic">eauto</span>. <span class="tactic">simpl</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">initial_locations</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">P</span> <span class="id">sl</span> <span class="id">ls</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">range</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">pos</span> + 4 * <span class="id">bound</span>) ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;(8 | <span class="id">pos</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) = <span class="id">Vundef</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3724')">Proof.</div>
<div class="proofscript" id="proof3724">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> (<span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span>). <span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span>). <span class="tactic">split</span>.<br/>
- <span class="tactic">simpl</span>; <span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>. <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.valid_access_load</span> <span class="id">m</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> (<span class="id">pos</span> + 4 * <span class="id">ofs</span>)) <span class="kwd">as</span> [<span class="id">v</span> <span class="id">LOAD</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">valid_access_location</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">split</span>; <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls</span>' <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">ls</span>' (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) = <span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3725')">Proof.</div>
<div class="proofscript" id="proof3725">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_locations_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_locations</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">bound</span> <span class="id">sl</span> <span class="id">ls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3726')">Proof.</div>
<div class="proofscript" id="proof3726">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="id">exploit</span> <span class="id">H5</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">rl</span> <span class="id">ls</span></span> is a memory assertion that holds
  if block <span class="bracket"><span class="id">sp</span></span>, starting at offset <span class="bracket"><span class="id">pos</span></span>, contains the values of the
  callee-save registers <span class="bracket"><span class="id">rl</span></span> as given by the location map <span class="bracket"><span class="id">ls</span></span>,
  up to the memory injection <span class="bracket"><span class="id">j</span></span>.  The memory layout of the registers in <span class="bracket"><span class="id">rl</span></span>
  is the same as that implemented by <span class="bracket"><span class="id">save_callee_save_rec</span></span>. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">contains_callee_saves</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">pos</span>: <span class="id">Z</span>) (<span class="id">rl</span>: <span class="id">list</span> <span class="id">mreg</span>) (<span class="id">ls</span>: <span class="id">locset</span>) : <span class="id">massert</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">rl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">pure</span> <span class="id">True</span><br/>
&nbsp;&nbsp;| <span class="id">r</span> :: <span class="id">rl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">ty</span> := <span class="id">mreg_type</span> <span class="id">r</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">sz</span> := <span class="id">AST.typesize</span> <span class="id">ty</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">pos1</span> := <span class="id">align</span> <span class="id">pos</span> <span class="id">sz</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contains</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) <span class="id">sp</span> <span class="id">pos1</span> (<span class="kwd">fun</span> <span class="id">v</span> =&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) <span class="id">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">pos1</span> + <span class="id">sz</span>) <span class="id">rl</span> <span class="id">ls</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_callee_saves_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">rl</span> <span class="id">pos</span>,<br/>
&nbsp;&nbsp;<span class="id">massert_imp</span> (<span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">rl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_callee_saves</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">pos</span> <span class="id">rl</span> <span class="id">ls</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3727')">Proof.</div>
<div class="proofscript" id="proof3727">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span> <span class="kwd">as</span> [ | <span class="id">r1</span> <span class="id">rl</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">reflexivity</span>.<br/>
- <span class="tactic">apply</span> <span class="id">sepconj_morph_1</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">contains_imp</span>. <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">contains_callee_saves_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls</span>' <span class="id">rl</span> <span class="id">pos</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">rl</span> -&gt; <span class="id">ls</span>' (<span class="id">R</span> <span class="id">r</span>) = <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">massert_eqv</span> (<span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">rl</span> <span class="id">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">rl</span> <span class="id">ls</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3728')">Proof.</div>
<div class="proofscript" id="proof3728">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span> <span class="kwd">as</span> [ | <span class="id">r1</span> <span class="id">rl</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">reflexivity</span>.<br/>
- <span class="tactic">apply</span> <span class="id">sepconj_morph_2</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Separation logic assertions describing the stack frame at <span class="bracket"><span class="id">sp</span></span>.
  It must contain:
  - the values of the <span class="bracket"><span class="kwd">Local</span></span> stack slots of <span class="bracket"><span class="id">ls</span></span>, as per <span class="bracket"><span class="id">contains_locations</span></span>
  - the values of the <span class="bracket"><span class="id">Outgoing</span></span> stack slots of <span class="bracket"><span class="id">ls</span></span>, as per <span class="bracket"><span class="id">contains_locations</span></span>
  - the <span class="bracket"><span class="id">parent</span></span> pointer representing the back link to the caller's frame
  - the <span class="bracket"><span class="id">retaddr</span></span> pointer representing the saved return address
  - the initial values of the used callee-save registers as given by <span class="bracket"><span class="id">ls0</span></span>,
    as per <span class="bracket"><span class="id">contains_callee_saves</span></span>.
In addition, we use a nonseparating conjunction to record the fact that
we have full access rights on the stack frame, except the part that
represents the Linear stack data. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">frame_contents_1</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) (<span class="id">parent</span> <span class="id">retaddr</span>: <span class="id">val</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_local</span>) <span class="id">b</span>.(<span class="id">bound_local</span>) <span class="kwd">Local</span> <span class="id">ls</span><br/>
&nbsp;** <span class="id">contains_locations</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe_ofs_arg</span> <span class="id">b</span>.(<span class="id">bound_outgoing</span>) <span class="id">Outgoing</span> <span class="id">ls</span><br/>
&nbsp;** <span class="id">hasvalue</span> <span class="id">Mptr</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_link</span>) <span class="id">parent</span><br/>
&nbsp;** <span class="id">hasvalue</span> <span class="id">Mptr</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_retaddr</span>) <span class="id">retaddr</span><br/>
&nbsp;** <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_callee_save</span>) <span class="id">b</span>.(<span class="id">used_callee_save</span>) <span class="id">ls0</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">frame_contents</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">sp</span>: <span class="id">block</span>) (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) (<span class="id">parent</span> <span class="id">retaddr</span>: <span class="id">val</span>) :=<br/>
&nbsp;&nbsp;<span class="id">mconj</span> (<span class="id">frame_contents_1</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">range</span> <span class="id">sp</span> 0 <span class="id">fe</span>.(<span class="id">fe_stack_data</span>) **<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">range</span> <span class="id">sp</span> (<span class="id">fe</span>.(<span class="id">fe_stack_data</span>) + <span class="id">b</span>.(<span class="id">bound_stack_data</span>)) <span class="id">fe</span>.(<span class="id">fe_size</span>)).<br/>
<br/>
<div class="doc">Accessing components of the frame. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_get_local</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span> -&gt; <span class="id">slot_valid</span> <span class="id">f</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">offset_local</span> <span class="id">fe</span> <span class="id">ofs</span>)) = <span class="id">Some</span> <span class="id">v</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">S</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span>)) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3729')">Proof.</div>
<div class="proofscript" id="proof3729">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">slot_valid</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">InvBooleans</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">get_location</span>; <span class="tactic">eauto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_get_outgoing</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span> -&gt; <span class="id">slot_valid</span> <span class="id">f</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">offset_arg</span> <span class="id">ofs</span>)) = <span class="id">Some</span> <span class="id">v</span><br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>)) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3730')">Proof.</div>
<div class="proofscript" id="proof3730">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">slot_valid</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">InvBooleans</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_pick2</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">get_location</span>; <span class="tactic">eauto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_get_parent</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> (<span class="id">Ptrofs.repr</span> <span class="id">fe</span>.(<span class="id">fe_ofs_link</span>)) = <span class="id">Some</span> <span class="id">parent</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3731')">Proof.</div>
<div class="proofscript" id="proof3731">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_pick3</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">chunk_of_Tptr</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">hasvalue_get_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_get_retaddr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> (<span class="id">Ptrofs.repr</span> <span class="id">fe</span>.(<span class="id">fe_ofs_retaddr</span>)) = <span class="id">Some</span> <span class="id">retaddr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3732')">Proof.</div>
<div class="proofscript" id="proof3732">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_pick4</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">chunk_of_Tptr</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">hasvalue_get_stack</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Assigning a <span class="bracket"><span class="kwd">Local</span></span> or <span class="bracket"><span class="id">Outgoing</span></span> stack slot. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_set_local</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">v</span> <span class="id">v</span>' <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span> -&gt; <span class="id">slot_valid</span> <span class="id">f</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">store_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">offset_local</span> <span class="id">fe</span> <span class="id">ofs</span>)) <span class="id">v</span>' = <span class="id">Some</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="kwd">Local</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3733')">Proof.</div>
<div class="proofscript" id="proof3733">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">frame_contents</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">mconj_proj1</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">frame_contents_1</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span>; <span class="tactic">intros</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">slot_valid</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">InvBooleans</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">set_location</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">m</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;{  <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_store_1</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_mconj</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>; <span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span>; <span class="tactic">exact</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj1</span>. <span class="tactic">eapply</span> <span class="id">mconj_proj2</span>. <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">range_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">range_preserved</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_set_outgoing</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">v</span> <span class="id">v</span>' <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span> -&gt; <span class="id">slot_valid</span> <span class="id">f</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">store_stack</span> <span class="id">m</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> (<span class="id">offset_arg</span> <span class="id">ofs</span>)) <span class="id">v</span>' = <span class="id">Some</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3734')">Proof.</div>
<div class="proofscript" id="proof3734">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">frame_contents</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">mconj_proj1</span>; <span class="tactic">eauto</span>. <span class="tactic">unfold</span> <span class="id">frame_contents_1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span>, <span class="id">sep_swap</span>. <span class="tactic">intros</span> <span class="id">SEP</span>. <br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">slot_valid</span> <span class="kwd">in</span> <span class="id">H1</span>; <span class="id">InvBooleans</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">set_location</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">m</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">m</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">i</span> <span class="id">k</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;{  <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_store_1</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_mconj</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>; <span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span>, <span class="id">sep_swap</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj1</span>. <span class="tactic">eapply</span> <span class="id">mconj_proj2</span>. <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">range_preserved</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">range_preserved</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by change of location maps. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">ls</span>' <span class="id">ls0</span>' <span class="id">j</span> <span class="id">sp</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">P</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">ls</span>' (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) = <span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">b</span>.(<span class="id">used_callee_save</span>) -&gt; <span class="id">ls0</span>' (<span class="id">R</span> <span class="id">r</span>) = <span class="id">ls0</span> (<span class="id">R</span> <span class="id">r</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span>' <span class="id">ls0</span>' <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3735')">Proof.</div>
<div class="proofscript" id="proof3735">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- ! (<span class="id">contains_locations_exten</span> <span class="id">ls</span> <span class="id">ls</span>') <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span>  &lt;- <span class="id">contains_callee_saves_exten</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by assignment to registers. </div>
<br/>
<span class="kwd">Corollary</span> <span class="id">frame_set_reg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">Locmap.set</span> (<span class="id">R</span> <span class="id">r</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3736')">Proof.</div>
<div class="proofscript" id="proof3736">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">frame_contents_exten</span> <span class="kwd">with</span> <span class="id">ls</span> <span class="id">ls0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Corollary</span> <span class="id">frame_undef_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span> <span class="id">rl</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3737')">Proof.</div>
<div class="proofscript" id="proof3737">
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">frame_set_reg</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Corollary</span> <span class="id">frame_set_regpair</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span> <span class="id">p</span> <span class="id">v</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">Locmap.setpair</span> <span class="id">p</span> <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3738')">Proof.</div>
<div class="proofscript" id="proof3738">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_set_reg</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_set_reg</span>; <span class="tactic">apply</span> <span class="id">frame_set_reg</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Corollary</span> <span class="id">frame_set_res</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span> <span class="id">res</span> <span class="id">v</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> (<span class="id">Locmap.setres</span> <span class="id">res</span> <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3739')">Proof.</div>
<div class="proofscript" id="proof3739">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">res</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">apply</span> <span class="id">frame_set_reg</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance by change of memory injection. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">frame_contents_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> <span class="id">m</span> <span class="id">P</span> <span class="id">j</span>',<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span>' <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3740')">Proof.</div>
<div class="proofscript" id="proof3740">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">contains_locations_incr</span> <span class="id">j</span> <span class="id">j</span>') <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- (<span class="id">contains_locations_incr</span> <span class="id">j</span> <span class="id">j</span>') <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span>  &lt;- <span class="id">contains_callee_saves_incr</span> <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<h1> Agreement between location sets and Mach states </h1>
<br/>
<div class="doc">Agreement with Mach register states </div>
<br/>
<span class="kwd">Definition</span> <span class="id">agree_regs</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">ls</span>: <span class="id">locset</span>) (<span class="id">rs</span>: <span class="id">regset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">rs</span> <span class="id">r</span>).<br/>
<br/>
<div class="doc">Agreement over locations </div>
<br/>
<span class="kwd">Record</span> <span class="id">agree_locs</span> (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">mk_agree_locs</span> {<br/>
<br/>
<div class="doc">Unused registers have the same value as in the caller </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_unused_reg</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, ~(<span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) -&gt; <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>) = <span class="id">ls0</span> (<span class="id">R</span> <span class="id">r</span>);<br/>
<br/>
<div class="doc">Incoming stack slots have the same value as the
        corresponding Outgoing stack slots in the caller </div>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">agree_incoming</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">S</span> <span class="id">Incoming</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_parameters</span> <span class="id">f</span>.(<span class="id">Linear.fn_sig</span>))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">ls</span> (<span class="id">S</span> <span class="id">Incoming</span> <span class="id">ofs</span> <span class="id">ty</span>) = <span class="id">ls0</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>)<br/>
}.<br/>
<br/>
<div class="doc">Auxiliary predicate used at call points </div>
<br/>
<span class="kwd">Definition</span> <span class="id">agree_callee_save</span> (<span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">l</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">R</span> <span class="id">r</span> =&gt; <span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">S</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">ls</span> <span class="id">l</span> = <span class="id">ls0</span> <span class="id">l</span>.<br/>
<br/>
<h2> Properties of <span class="bracket"><span class="id">agree_regs</span></span>. </h2>
<br/>
<div class="doc">Values of registers </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_reg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">rs</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3741')">Proof.</div>
<div class="proofscript" id="proof3741">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_reglist</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">rl</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt; <span class="id">Val.inject_list</span> <span class="id">j</span> (<span class="id">reglist</span> <span class="id">ls</span> <span class="id">rl</span>) (<span class="id">rs</span>##<span class="id">rl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3742')">Proof.</div>
<div class="proofscript" id="proof3742">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span> <span class="kwd">using</span> <span class="id">agree_reg</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">agree_reg</span> <span class="id">agree_reglist</span>: <span class="id">stacking</span>.<br/>
<br/>
<div class="doc">Preservation under assignments of machine registers. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_set_reg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">r</span> <span class="id">v</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">Locmap.set</span> (<span class="id">R</span> <span class="id">r</span>) <span class="id">v</span> <span class="id">ls</span>) (<span class="id">Regmap.set</span> <span class="id">r</span> <span class="id">v</span>' <span class="id">rs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3743')">Proof.</div>
<div class="proofscript" id="proof3743">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Regmap.set</span>. <span class="tactic">destruct</span> (<span class="id">RegEq.eq</span> <span class="id">r0</span> <span class="id">r</span>). <span class="tactic">subst</span> <span class="id">r0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Locmap.gss</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_set_pair</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">p</span> <span class="id">v</span> <span class="id">v</span>' <span class="id">ls</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">Locmap.setpair</span> <span class="id">p</span> <span class="id">v</span> <span class="id">ls</span>) (<span class="id">set_pair</span> <span class="id">p</span> <span class="id">v</span>' <span class="id">rs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3744')">Proof.</div>
<div class="proofscript" id="proof3744">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span>.<br/>
- <span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>. <span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.hiword_inject</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">Val.loword_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_set_res</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">res</span> <span class="id">v</span> <span class="id">v</span>' <span class="id">ls</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">Locmap.setres</span> <span class="id">res</span> <span class="id">v</span> <span class="id">ls</span>) (<span class="id">set_res</span> <span class="id">res</span> <span class="id">v</span>' <span class="id">rs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3745')">Proof.</div>
<div class="proofscript" id="proof3745">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">res</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">IHres2</span>. <span class="tactic">apply</span> <span class="id">IHres1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.hiword_inject</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.loword_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_exten</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">ls</span>' <span class="id">rs</span>',<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">ls</span>' (<span class="id">R</span> <span class="id">r</span>) = <span class="id">Vundef</span> \/ <span class="id">ls</span>' (<span class="id">R</span> <span class="id">r</span>) = <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>) /\ <span class="id">rs</span>' <span class="id">r</span> = <span class="id">rs</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span>' <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3746')">Proof.</div>
<div class="proofscript" id="proof3746">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">H0</span> <span class="id">r</span>) <span class="kwd">as</span> [<span class="id">A</span> | [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">A</span>; <span class="tactic">rewrite</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_undef_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">rl</span> <span class="id">ls</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span>) (<span class="id">Mach.undef_regs</span> <span class="id">rl</span> <span class="id">rs</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3747')">Proof.</div>
<div class="proofscript" id="proof3747">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation under assignment of stack slot </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_set_slot</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3748')">Proof.</div>
<div class="proofscript" id="proof3748">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation by increasing memory injections </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_inject_incr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">j</span>',<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt; <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt; <span class="id">agree_regs</span> <span class="id">j</span>' <span class="id">ls</span> <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3749')">Proof.</div>
<div class="proofscript" id="proof3749">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">stacking</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation at function entry. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_regs_call_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">call_regs</span> <span class="id">ls</span>) <span class="id">rs</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3750')">Proof.</div>
<div class="proofscript" id="proof3750">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">call_regs</span>; <span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Properties of <span class="bracket"><span class="id">agree_locs</span></span> </h2>
<br/>
<div class="doc">Preservation under assignment of machine register. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_set_reg</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">r</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">Locmap.set</span> (<span class="id">R</span> <span class="id">r</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3751')">Proof.</div>
<div class="proofscript" id="proof3751">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">red</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">caller_save_reg_within_bounds</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">false</span> -&gt; <span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3752')">Proof.</div>
<div class="proofscript" id="proof3752">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_set_pair</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls0</span> <span class="id">p</span> <span class="id">v</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">forall_rpair</span> (<span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">false</span>) <span class="id">p</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">Locmap.setpair</span> <span class="id">p</span> <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3753')">Proof.</div>
<div class="proofscript" id="proof3753">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">caller_save_reg_within_bounds</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">caller_save_reg_within_bounds</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">caller_save_reg_within_bounds</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_set_res</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls0</span> <span class="id">res</span> <span class="id">v</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> (<span class="id">params_of_builtin_res</span> <span class="id">res</span>) -&gt; <span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">Locmap.setres</span> <span class="id">res</span> <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3754')">Proof.</div>
<div class="proofscript" id="proof3754">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">res</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">eapply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">IHres2</span>; <span class="tactic">auto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_undef_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls0</span> <span class="id">regs</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">regs</span> -&gt; <span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">LTL.undef_regs</span> <span class="id">regs</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3755')">Proof.</div>
<div class="proofscript" id="proof3755">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">regs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_undef_locs_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls0</span> <span class="id">regs</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">regs</span> -&gt; <span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">false</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">LTL.undef_regs</span> <span class="id">regs</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3756')">Proof.</div>
<div class="proofscript" id="proof3756">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">agree_locs_undef_regs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">caller_save_reg_within_bounds</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_undef_locs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls0</span> <span class="id">regs</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">existsb</span> <span class="id">is_callee_save</span> <span class="id">regs</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">LTL.undef_regs</span> <span class="id">regs</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3757')">Proof.</div>
<div class="proofscript" id="proof3757">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">eapply</span> <span class="id">agree_locs_undef_locs_1</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">is_callee_save</span> <span class="id">r</span>) <span class="id">eqn</span>:<span class="id">CS</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">existsb</span> <span class="id">is_callee_save</span> <span class="id">regs</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">existsb_exists</span>. <span class="id">exists</span> <span class="id">r</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation by assignment to local slot </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_set_slot</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">slot_writable</span> <span class="id">sl</span> = <span class="id">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) <span class="id">v</span> <span class="id">ls</span>) <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3758')">Proof.</div>
<div class="proofscript" id="proof3758">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>. <span class="id">left</span>. <span class="tactic">destruct</span> <span class="id">sl</span>; <span class="tactic">discriminate</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation at return points (when <span class="bracket"><span class="id">ls</span></span> is changed but not <span class="bracket"><span class="id">ls0</span></span>). </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_return</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">ls</span>',<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> <span class="id">ls</span>' <span class="id">ls</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span>' <span class="id">ls0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3759')">Proof.</div>
<div class="proofscript" id="proof3759">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">unfold</span> <span class="id">mreg_within_bounds</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation at tailcalls (when <span class="bracket"><span class="id">ls0</span></span> is changed but not <span class="bracket"><span class="id">ls</span></span>). </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_locs_tailcall</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">ls0</span>',<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> <span class="id">ls0</span> <span class="id">ls0</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3760')">Proof.</div>
<div class="proofscript" id="proof3760">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>; <span class="tactic">auto</span>. <span class="tactic">unfold</span> <span class="id">mreg_within_bounds</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">tauto</span>.<br/>
- <span class="tactic">rewrite</span> &lt;- <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Properties of <span class="bracket"><span class="id">agree_callee_save</span></span>. </h2>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_callee_save_return_regs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ls1</span> <span class="id">ls2</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> (<span class="id">return_regs</span> <span class="id">ls1</span> <span class="id">ls2</span>) <span class="id">ls1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3761')">Proof.</div>
<div class="proofscript" id="proof3761">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">return_regs</span>. <span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">agree_callee_save_set_result</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sg</span> <span class="id">v</span> <span class="id">ls1</span> <span class="id">ls2</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> <span class="id">ls1</span> <span class="id">ls2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> (<span class="id">Locmap.setpair</span> (<span class="id">loc_result</span> <span class="id">sg</span>) <span class="id">v</span> <span class="id">ls1</span>) <span class="id">ls2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3762')">Proof.</div>
<div class="proofscript" id="proof3762">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Locmap.gpo</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">X</span>: <span class="kwd">forall</span> <span class="id">r</span>, <span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">false</span> -&gt; <span class="id">Loc.diff</span> <span class="id">l</span> (<span class="id">R</span> <span class="id">r</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>; <span class="tactic">congruence</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">loc_result_caller_save</span> <span class="id">sg</span>). <span class="tactic">destruct</span> (<span class="id">loc_result</span> <span class="id">sg</span>); <span class="tactic">simpl</span>; <span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h2> Properties of destroyed registers. </h2>
<br/>
<span class="kwd">Definition</span> <span class="id">no_callee_saves</span> (<span class="id">l</span>: <span class="id">list</span> <span class="id">mreg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">existsb</span> <span class="id">is_callee_save</span> <span class="id">l</span> = <span class="id">false</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_op_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span>, <span class="id">no_callee_saves</span> (<span class="id">destroyed_by_op</span> <span class="id">op</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3763')">Proof.</div>
<div class="proofscript" id="proof3763">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_callee_saves</span>; <span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_load_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span>, <span class="id">no_callee_saves</span> (<span class="id">destroyed_by_load</span> <span class="id">chunk</span> <span class="id">addr</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3764')">Proof.</div>
<div class="proofscript" id="proof3764">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_callee_saves</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_store_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span>, <span class="id">no_callee_saves</span> (<span class="id">destroyed_by_store</span> <span class="id">chunk</span> <span class="id">addr</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3765')">Proof.</div>
<div class="proofscript" id="proof3765">
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">destroyed_by_store</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_callee_saves</span>, <span class="id">destroyed_by_store</span>; <span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">try</span> <span class="tactic">reflexivity</span>; <span class="tactic">destruct</span> <span class="id">Archi.ptr64</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_cond_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cond</span>, <span class="id">no_callee_saves</span> (<span class="id">destroyed_by_cond</span> <span class="id">cond</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3766')">Proof.</div>
<div class="proofscript" id="proof3766">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_callee_saves</span>; <span class="tactic">destruct</span> <span class="id">cond</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_jumptable_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="id">no_callee_saves</span> <span class="id">destroyed_by_jumptable</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3767')">Proof.</div>
<div class="proofscript" id="proof3767">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_setstack_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span>, <span class="id">no_callee_saves</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3768')">Proof.</div>
<div class="proofscript" id="proof3768">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_callee_saves</span>; <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_at_function_entry_caller_save</span>:<br/>
&nbsp;&nbsp;<span class="id">no_callee_saves</span> <span class="id">destroyed_at_function_entry</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3769')">Proof.</div>
<div class="proofscript" id="proof3769">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="kwd">Resolve</span> <span class="id">destroyed_by_op_caller_save</span> <span class="id">destroyed_by_load_caller_save</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destroyed_by_store_caller_save</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destroyed_by_cond_caller_save</span> <span class="id">destroyed_by_jumptable_caller_save</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destroyed_at_function_entry_caller_save</span>: <span class="id">stacking</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">destroyed_by_setstack_function_entry</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span>, <span class="id">incl</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>) <span class="id">destroyed_at_function_entry</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3770')">Proof.</div>
<div class="proofscript" id="proof3770">
<span class="kwd">Local</span> <span class="id">Transparent</span> <span class="id">destroyed_by_setstack</span> <span class="id">destroyed_at_function_entry</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">incl</span>; <span class="tactic">destruct</span> <span class="id">ty</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_destroyed_by_op</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">op</span> <span class="id">e</span>, <span class="id">destroyed_by_op</span> (<span class="id">transl_op</span> <span class="id">e</span> <span class="id">op</span>) = <span class="id">destroyed_by_op</span> <span class="id">op</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3771')">Proof.</div>
<div class="proofscript" id="proof3771">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">op</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_destroyed_by_load</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">e</span>, <span class="id">destroyed_by_load</span> <span class="id">chunk</span> (<span class="id">transl_addr</span> <span class="id">e</span> <span class="id">addr</span>) = <span class="id">destroyed_by_load</span> <span class="id">chunk</span> <span class="id">addr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3772')">Proof.</div>
<div class="proofscript" id="proof3772">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">transl_destroyed_by_store</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">chunk</span> <span class="id">addr</span> <span class="id">e</span>, <span class="id">destroyed_by_store</span> <span class="id">chunk</span> (<span class="id">transl_addr</span> <span class="id">e</span> <span class="id">addr</span>) = <span class="id">destroyed_by_store</span> <span class="id">chunk</span> <span class="id">addr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3773')">Proof.</div>
<div class="proofscript" id="proof3773">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">destruct</span> <span class="id">chunk</span>; <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<h1> Correctness of saving and restoring of callee-save registers </h1>
<br/>
<div class="doc">The following lemmas show the correctness of the register saving
  code generated by <span class="bracket"><span class="id">save_callee_save</span></span>: after this code has executed,
  the register save areas of the current frame do contain the
  values of the callee-save registers used by the function. </div>
<br/>
<span class="kwd">Section</span> <span class="id">SAVE_CALLEE_SAVE</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">j</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cs</span>: <span class="id">list</span> <span class="id">stackframe</span>.<br/>
<span class="kwd">Variable</span> <span class="id">fb</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ls</span>: <span class="id">locset</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">ls_temp_undef</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>) -&gt; <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>) = <span class="id">Vundef</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">wt_ls</span>: <span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.has_type</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">mreg_type</span> <span class="id">r</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">save_callee_save_rec_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">k</span> <span class="id">l</span> <span class="id">pos</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">l</span> -&gt; <span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">true</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">range</span> <span class="id">sp</span> <span class="id">pos</span> (<span class="id">size_callee_save_area_rec</span> <span class="id">l</span> <span class="id">pos</span>) ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">save_callee_save_rec</span> <span class="id">l</span> <span class="id">pos</span> <span class="id">k</span>) <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">pos</span> <span class="id">l</span> <span class="id">ls</span> ** <span class="id">P</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3774')">Proof.</div>
<div class="proofscript" id="proof3774">
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">mreg_type</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | <span class="id">r</span> <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">until</span> <span class="id">P</span>; <span class="tactic">intros</span> <span class="id">CS</span> <span class="id">SEP</span> <span class="id">AG</span>.<br/>
- <span class="id">exists</span> <span class="id">rs</span>, <span class="id">m</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">sep_pure</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">sep_drop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
- <span class="tactic">set</span> (<span class="id">ty</span> := <span class="id">mreg_type</span> <span class="id">r</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">sz</span> := <span class="id">AST.typesize</span> <span class="id">ty</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">pos1</span> := <span class="id">align</span> <span class="id">pos</span> <span class="id">sz</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SZPOS</span>: <span class="id">sz</span> &gt; 0) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">AST.typesize_pos</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SZREC</span>: <span class="id">pos1</span> + <span class="id">sz</span> &lt;= <span class="id">size_callee_save_area_rec</span> <span class="id">l</span> (<span class="id">pos1</span> + <span class="id">sz</span>)) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">size_callee_save_area_rec_incr</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">POS1</span>: <span class="id">pos</span> &lt;= <span class="id">pos1</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">align_le</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">AL1</span>: (<span class="id">align_chunk</span> (<span class="id">chunk_of_type</span> <span class="id">ty</span>) | <span class="id">pos1</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">pos1</span>. <span class="tactic">apply</span> <span class="id">Zdivide_trans</span> <span class="kwd">with</span> <span class="id">sz</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sz</span>; <span class="tactic">rewrite</span> &lt;- <span class="id">size_type_chunk</span>. <span class="tactic">apply</span> <span class="id">align_size_chunk_divides</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">align_divides</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">range_drop_left</span> <span class="kwd">with</span> (<span class="id">mid</span> := <span class="id">pos1</span>) <span class="kwd">in</span> <span class="id">SEP</span>; [ | <span class="tactic">omega</span> ].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">range_split</span> <span class="kwd">with</span> (<span class="id">mid</span> := <span class="id">pos1</span> + <span class="id">sz</span>) <span class="kwd">in</span> <span class="id">SEP</span>; [ | <span class="tactic">omega</span> ].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">sz</span> <span class="tactic">at</span> 1 <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">size_type_chunk</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">range_contains</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">contains_set_stack</span> (<span class="kwd">fun</span> <span class="id">v</span>' =&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) <span class="id">v</span>') (<span class="id">rs</span> <span class="id">r</span>)).<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">load_result_inject</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">wt_ls</span>. <br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">m1</span> &amp; <span class="id">STORE</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">rs1</span> := <span class="id">undef_regs</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>) <span class="id">rs</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">AG1</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs1</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">rs1</span>. <span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">mreg_eq</span> <span class="id">r0</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">ls_temp_undef</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">undef_regs_other</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">AG</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHl</span> (<span class="id">pos1</span> + <span class="id">sz</span>) <span class="id">rs1</span> <span class="id">m1</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">rs2</span> &amp; <span class="id">m2</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs2</span>, <span class="id">m2</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_left</span>; <span class="tactic">eauto</span>. <span class="id">constructor</span>. <span class="tactic">exact</span> <span class="id">STORE</span>. <span class="tactic">auto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">sep_assoc</span>, <span class="id">sep_swap</span>. <span class="tactic">exact</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">C</span>. <span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> <span class="id">STORE</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">STORE</span>. <span class="tactic">eapply</span> <span class="id">Mem.perm_store_1</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">SAVE_CALLEE_SAVE</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">LTL_undef_regs_same</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">rl</span> <span class="id">ls</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">rl</span> -&gt; <span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>) = <span class="id">Vundef</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3775')">Proof.</div>
<div class="proofscript" id="proof3775">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Locmap.set</span>. <span class="tactic">destruct</span> (<span class="id">Loc.eq</span> (<span class="id">R</span> <span class="id">a</span>) (<span class="id">R</span> <span class="id">r</span>)). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Loc.diff_dec</span> (<span class="id">R</span> <span class="id">a</span>) (<span class="id">R</span> <span class="id">r</span>)); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHrl</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">LTL_undef_regs_others</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">rl</span> <span class="id">ls</span>, ~<span class="id">In</span> <span class="id">r</span> <span class="id">rl</span> -&gt; <span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>) = <span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3776')">Proof.</div>
<div class="proofscript" id="proof3776">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>. <span class="tactic">apply</span> <span class="id">IHrl</span>. <span class="tactic">intuition</span>. <span class="tactic">red</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">LTL_undef_regs_slot</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span> <span class="id">rl</span> <span class="id">ls</span>, <span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) = <span class="id">ls</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3777')">Proof.</div>
<div class="proofscript" id="proof3777">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Locmap.gso</span>. <span class="tactic">apply</span> <span class="id">IHrl</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">undef_regs_type</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">ty</span> <span class="id">l</span> <span class="id">rl</span> <span class="id">ls</span>,<br/>
&nbsp;&nbsp;<span class="id">Val.has_type</span> (<span class="id">ls</span> <span class="id">l</span>) <span class="id">ty</span> -&gt; <span class="id">Val.has_type</span> (<span class="id">LTL.undef_regs</span> <span class="id">rl</span> <span class="id">ls</span> <span class="id">l</span>) <span class="id">ty</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3778')">Proof.</div>
<div class="proofscript" id="proof3778">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">rl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">unfold</span> <span class="id">Locmap.set</span>. <span class="tactic">destruct</span> (<span class="id">Loc.eq</span> (<span class="id">R</span> <span class="id">a</span>) <span class="id">l</span>). <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Loc.diff_dec</span> (<span class="id">R</span> <span class="id">a</span>) <span class="id">l</span>); <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">save_callee_save_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">cs</span> <span class="id">fb</span> <span class="id">k</span> <span class="id">m</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">range</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_callee_save</span>) (<span class="id">size_callee_save_area</span> <span class="id">b</span> <span class="id">fe</span>.(<span class="id">fe_ofs_callee_save</span>)) ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.has_type</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">mreg_type</span> <span class="id">r</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">ls1</span> := <span class="id">LTL.undef_regs</span> <span class="id">destroyed_at_function_entry</span> (<span class="id">LTL.call_regs</span> <span class="id">ls</span>) <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">rs1</span> := <span class="id">undef_regs</span> <span class="id">destroyed_at_function_entry</span> <span class="id">rs</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">m</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">save_callee_save</span> <span class="id">fe</span> <span class="id">k</span>) <span class="id">rs1</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs</span>' <span class="id">m</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">m</span>' |= <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">fe</span>.(<span class="id">fe_ofs_callee_save</span>) <span class="id">b</span>.(<span class="id">used_callee_save</span>) <span class="id">ls0</span> ** <span class="id">P</span><br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m</span>' <span class="id">sp</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls1</span> <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3779')">Proof.</div>
<div class="proofscript" id="proof3779">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">P</span>; <span class="tactic">intros</span> <span class="id">SEP</span> <span class="id">TY</span> <span class="id">AGCS</span> <span class="id">AG</span>; <span class="tactic">intros</span> <span class="id">ls1</span> <span class="id">rs1</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">save_callee_save_rec_correct</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">fb</span> <span class="id">sp</span> <span class="id">ls1</span>).<br/>
- <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">ls1</span>. <span class="tactic">apply</span> <span class="id">LTL_undef_regs_same</span>. <span class="tactic">eapply</span> <span class="id">destroyed_by_setstack_function_entry</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">ls1</span>. <span class="tactic">apply</span> <span class="id">undef_regs_type</span>. <span class="tactic">apply</span> <span class="id">TY</span>. <br/>
- <span class="tactic">exact</span> <span class="id">b</span>.(<span class="id">used_callee_save_prop</span>).<br/>
- <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
- <span class="id">instantiate</span> (1 := <span class="id">rs1</span>). <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>. <span class="tactic">apply</span> <span class="id">agree_regs_call_regs</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">clear</span> <span class="id">SEP</span>. <span class="tactic">intros</span> (<span class="id">rs</span>' &amp; <span class="id">m</span>' &amp; <span class="id">EXEC</span> &amp; <span class="id">SEP</span> &amp; <span class="id">PERMS</span> &amp; <span class="id">AG</span>').<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">m</span>'. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">EXEC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> (<span class="id">contains_callee_saves_exten</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls0</span> <span class="id">ls1</span>). <span class="tactic">exact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">b</span>.(<span class="id">used_callee_save_prop</span>) <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ls1</span>. <span class="tactic">rewrite</span> <span class="id">LTL_undef_regs_others</span>. <span class="tactic">unfold</span> <span class="id">call_regs</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">AGCS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">existsb</span> <span class="id">is_callee_save</span> <span class="id">destroyed_at_function_entry</span> = <span class="id">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">by</span>  (<span class="tactic">apply</span> <span class="id">destroyed_at_function_entry_caller_save</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">existsb</span> <span class="id">is_callee_save</span> <span class="id">destroyed_at_function_entry</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">existsb_exists</span>. <span class="id">exists</span> <span class="id">r</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">PERMS</span>. <span class="tactic">exact</span> <span class="id">AG</span>'.<br/>
Qed.</div>
<br/>
<div class="doc">As a corollary of the previous lemmas, we obtain the following
  correctness theorem for the execution of a function prologue
  (allocation of the frame + saving of the link and return address +
  saving of the used callee-save registers). </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_prologue_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">ls1</span> <span class="id">rs</span> <span class="id">rs1</span> <span class="id">m1</span> <span class="id">m1</span>' <span class="id">m2</span> <span class="id">sp</span> <span class="id">parent</span> <span class="id">ra</span> <span class="id">cs</span> <span class="id">fb</span> <span class="id">k</span> <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_callee_save</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">Val.has_type</span> (<span class="id">ls</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">mreg_type</span> <span class="id">r</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">ls1</span> = <span class="id">LTL.undef_regs</span> <span class="id">destroyed_at_function_entry</span> (<span class="id">LTL.call_regs</span> <span class="id">ls</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">rs1</span> = <span class="id">undef_regs</span> <span class="id">destroyed_at_function_entry</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m1</span> 0 <span class="id">f</span>.(<span class="id">Linear.fn_stacksize</span>) = (<span class="id">m2</span>, <span class="id">sp</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.has_type</span> <span class="id">parent</span> <span class="id">Tptr</span> -&gt; <span class="id">Val.has_type</span> <span class="id">ra</span> <span class="id">Tptr</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m1</span>' |= <span class="id">minjection</span> <span class="id">j</span> <span class="id">m1</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>', <span class="id">exists</span> <span class="id">rs</span>', <span class="id">exists</span> <span class="id">m2</span>', <span class="id">exists</span> <span class="id">sp</span>', <span class="id">exists</span> <span class="id">m3</span>', <span class="id">exists</span> <span class="id">m4</span>', <span class="id">exists</span> <span class="id">m5</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Mem.alloc</span> <span class="id">m1</span>' 0 <span class="id">tf</span>.(<span class="id">fn_stacksize</span>) = (<span class="id">m2</span>', <span class="id">sp</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">store_stack</span> <span class="id">m2</span>' (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> <span class="id">tf</span>.(<span class="id">fn_link_ofs</span>) <span class="id">parent</span> = <span class="id">Some</span> <span class="id">m3</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">store_stack</span> <span class="id">m3</span>' (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> <span class="id">tf</span>.(<span class="id">fn_retaddr_ofs</span>) <span class="id">ra</span> = <span class="id">Some</span> <span class="id">m4</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">save_callee_save</span> <span class="id">fe</span> <span class="id">k</span>) <span class="id">rs1</span> <span class="id">m4</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs</span>' <span class="id">m5</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">agree_regs</span> <span class="id">j</span>' <span class="id">ls1</span> <span class="id">rs</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">agree_locs</span> <span class="id">ls1</span> <span class="id">ls0</span><br/>
&nbsp;&nbsp;/\ <span class="id">m5</span>' |= <span class="id">frame_contents</span> <span class="id">j</span>' <span class="id">sp</span>' <span class="id">ls1</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">ra</span> ** <span class="id">minjection</span> <span class="id">j</span>' <span class="id">m2</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>' ** <span class="id">P</span><br/>
&nbsp;&nbsp;/\ <span class="id">j</span>' <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', <span class="id">fe</span>.(<span class="id">fe_stack_data</span>))<br/>
&nbsp;&nbsp;/\ <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3780')">Proof.</div>
<div class="proofscript" id="proof3780">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">P</span>; <span class="tactic">intros</span> <span class="id">AGREGS</span> <span class="id">AGCS</span> <span class="id">WTREGS</span> <span class="id">LS1</span> <span class="id">RS1</span> <span class="id">ALLOC</span> <span class="id">TYPAR</span> <span class="id">TYRA</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">unfold_transf_function</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">fn_stacksize</span>, <span class="id">fn_link_ofs</span>, <span class="id">fn_retaddr_ofs</span>.<br/>
&nbsp;Stack&nbsp;layout&nbsp;info&nbsp;*)</span><span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">b</span> <span class="id">fe</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">frame_env_range</span> <span class="id">b</span>) (<span class="id">frame_env_aligned</span> <span class="id">b</span>). <span class="tactic">replace</span> (<span class="id">make_env</span> <span class="id">b</span>) <span class="kwd">with</span> <span class="id">fe</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">simpl</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">LAYOUT1</span> <span class="id">LAYOUT2</span>.<br/>
&nbsp;Allocation&nbsp;step&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Mem.alloc</span> <span class="id">m1</span>' 0 (<span class="id">fe_size</span> <span class="id">fe</span>)) <span class="kwd">as</span> [<span class="id">m2</span>' <span class="id">sp</span>'] <span class="id">eqn</span>:<span class="id">ALLOC</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">alloc_parallel_rule_2</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">SEP</span>. <span class="id">eexact</span> <span class="id">ALLOC</span>. <span class="id">eexact</span> <span class="id">ALLOC</span>'. <br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">fe_stack_data</span> <span class="id">fe</span>). <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">fe_stack_data</span> <span class="id">fe</span> + <span class="id">bound_stack_data</span> <span class="id">b</span>). <span class="tactic">rewrite</span> <span class="id">Z.max_comm</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">bound_stack_data_pos</span> <span class="id">b</span>) <span class="id">size_no_overflow</span>; <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>. <span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">SEP</span> &amp; <span class="id">INCR</span> &amp; <span class="id">SAME</span>).<br/>
&nbsp;Remember&nbsp;the&nbsp;freeable&nbsp;permissions&nbsp;using&nbsp;a&nbsp;mconj&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SEPCONJ</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m2</span>' |= <span class="id">mconj</span> (<span class="id">range</span> <span class="id">sp</span>' 0 (<span class="id">fe_stack_data</span> <span class="id">fe</span>) ** <span class="id">range</span> <span class="id">sp</span>' (<span class="id">fe_stack_data</span> <span class="id">fe</span> + <span class="id">bound_stack_data</span> <span class="id">b</span>) (<span class="id">fe_size</span> <span class="id">fe</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">range</span> <span class="id">sp</span>' 0 (<span class="id">fe_stack_data</span> <span class="id">fe</span>) ** <span class="id">range</span> <span class="id">sp</span>' (<span class="id">fe_stack_data</span> <span class="id">fe</span> + <span class="id">bound_stack_data</span> <span class="id">b</span>) (<span class="id">fe_size</span> <span class="id">fe</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> <span class="id">j</span>' <span class="id">m2</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>' ** <span class="id">P</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">apply</span> <span class="id">mconj_intro</span>; <span class="tactic">rewrite</span> <span class="id">sep_assoc</span>; <span class="tactic">assumption</span>. }<br/>
&nbsp;Dividing&nbsp;up&nbsp;the&nbsp;frame&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">frame_env_separated</span> <span class="id">b</span>) <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">replace</span> (<span class="id">make_env</span> <span class="id">b</span>) <span class="kwd">with</span> <span class="id">fe</span> <span class="kwd">in</span> <span class="id">SEP</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;Store&nbsp;of&nbsp;parent&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap3</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">range_contains</span> <span class="id">Mptr</span>) <span class="kwd">in</span> <span class="id">SEP</span>; [|<span class="tactic">tauto</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">contains_set_stack</span> (<span class="kwd">fun</span> <span class="id">v</span>' =&gt; <span class="id">v</span>' = <span class="id">parent</span>) <span class="id">parent</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">True</span>) <span class="id">m2</span>' <span class="id">Tptr</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">chunk_of_Tptr</span>; <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">Val.load_result_same</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">m3</span>' &amp; <span class="id">STORE_PARENT</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap3</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;Store&nbsp;of&nbsp;return&nbsp;address&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap4</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">range_contains</span> <span class="id">Mptr</span>) <span class="kwd">in</span> <span class="id">SEP</span>; [|<span class="tactic">tauto</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">contains_set_stack</span> (<span class="kwd">fun</span> <span class="id">v</span>' =&gt; <span class="id">v</span>' = <span class="id">ra</span>) <span class="id">ra</span> (<span class="kwd">fun</span> <span class="id">_</span> =&gt; <span class="id">True</span>) <span class="id">m3</span>' <span class="id">Tptr</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">chunk_of_Tptr</span>; <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">Val.load_result_same</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">m4</span>' &amp; <span class="id">STORE_RETADDR</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap4</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;Saving&nbsp;callee-save&nbsp;registers&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap5</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">save_callee_save_correct</span> <span class="id">j</span>' <span class="id">ls</span> <span class="id">ls0</span> <span class="id">rs</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_inject_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">LTL.undef_regs</span> <span class="id">destroyed_at_function_entry</span> (<span class="id">call_regs</span> <span class="id">ls</span>)) <span class="kwd">with</span> <span class="id">ls1</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">undef_regs</span> <span class="id">destroyed_at_function_entry</span> <span class="id">rs</span>) <span class="kwd">with</span> <span class="id">rs1</span> <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">rs2</span> &amp; <span class="id">m5</span>' &amp; <span class="id">SAVE_CS</span> &amp; <span class="id">SEP</span> &amp; <span class="id">PERMS</span> &amp; <span class="id">AGREGS</span>').<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap5</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;Materializing&nbsp;the&nbsp;Local&nbsp;and&nbsp;Outgoing&nbsp;locations&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">initial_locations</span> <span class="id">j</span>'). <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">tauto</span>. <br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="kwd">Local</span>). <span class="id">instantiate</span> (1 := <span class="id">ls1</span>). <br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">rewrite</span> <span class="id">LS1</span>. <span class="tactic">rewrite</span> <span class="id">LTL_undef_regs_slot</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">initial_locations</span> <span class="id">j</span>'). <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">tauto</span>. <br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">Outgoing</span>). <span class="id">instantiate</span> (1 := <span class="id">ls1</span>). <br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">rewrite</span> <span class="id">LS1</span>. <span class="tactic">rewrite</span> <span class="id">LTL_undef_regs_slot</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;Now&nbsp;we&nbsp;frame&nbsp;this&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SEPFINAL</span>: <span class="id">m5</span>' |= <span class="id">frame_contents</span> <span class="id">j</span>' <span class="id">sp</span>' <span class="id">ls1</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">ra</span> ** <span class="id">minjection</span> <span class="id">j</span>' <span class="id">m2</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>' ** <span class="id">P</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">frame_mconj</span>. <span class="id">eexact</span> <span class="id">SEPCONJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">chunk_of_Tptr</span> <span class="kwd">in</span> <span class="id">SEP</span>.  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span>; <span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span>. <span class="tactic">exact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>, <span class="id">Mem.perm</span> <span class="id">m2</span>' <span class="id">sp</span>' <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span> -&gt; <span class="id">Mem.perm</span> <span class="id">m5</span>' <span class="id">sp</span>' <span class="id">ofs</span> <span class="id">k</span> <span class="id">p</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">PERMS</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">store_stack</span> <span class="kwd">in</span> <span class="id">STORE_PARENT</span>, <span class="id">STORE_RETADDR</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">STORE_PARENT</span>, <span class="id">STORE_RETADDR</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">Mem.perm_store_1</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_preserved</span>. <span class="tactic">eapply</span> <span class="id">sep_proj1</span>. <span class="tactic">eapply</span> <span class="id">mconj_proj2</span>. <span class="id">eexact</span> <span class="id">SEPCONJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">range_preserved</span> <span class="kwd">with</span> <span class="id">m2</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">range_preserved</span> <span class="kwd">with</span> <span class="id">m2</span>'; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span> <span class="id">SEPCONJ</span>.<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exists</span> <span class="id">j</span>', <span class="id">rs2</span>, <span class="id">m2</span>', <span class="id">sp</span>', <span class="id">m3</span>', <span class="id">m4</span>', <span class="id">m5</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">STORE_PARENT</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">STORE_RETADDR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">SAVE_CS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">AGREGS</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> <span class="id">LS1</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>; [|<span class="tactic">reflexivity</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">call_regs</span>. <span class="tactic">apply</span> <span class="id">AGCS</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mreg_within_bounds</span> <span class="kwd">in</span> <span class="id">H</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">call_regs</span>. <span class="tactic">apply</span> <span class="id">AGCS</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">SEPFINAL</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">SAME</span>. <span class="tactic">exact</span> <span class="id">INCR</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The following lemmas show the correctness of the register reloading
  code generated by <span class="bracket"><span class="id">reload_callee_save</span></span>: after this code has executed,
  all callee-save registers contain the same values they had at
  function entry. </div>
<br/>
<span class="kwd">Section</span> <span class="id">RESTORE_CALLEE_SAVE</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">j</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cs</span>: <span class="id">list</span> <span class="id">stackframe</span>.<br/>
<span class="kwd">Variable</span> <span class="id">fb</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sp</span>: <span class="id">block</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ls0</span>: <span class="id">locset</span>.<br/>
<span class="kwd">Variable</span> <span class="id">m</span>: <span class="id">mem</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">agree_unused</span> (<span class="id">ls0</span>: <span class="id">locset</span>) (<span class="id">rs</span>: <span class="id">regset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, ~(<span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) -&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls0</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">rs</span> <span class="id">r</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">restore_callee_save_rec_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">rs</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">contains_callee_saves</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ofs</span> <span class="id">l</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_unused</span> <span class="id">ls0</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">l</span> -&gt; <span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">restore_callee_save_rec</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>) <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs</span>' <span class="id">m</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">l</span> -&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls0</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">rs</span>' <span class="id">r</span>))<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>, ~(<span class="id">In</span> <span class="id">r</span> <span class="id">l</span>) -&gt; <span class="id">rs</span>' <span class="id">r</span> = <span class="id">rs</span> <span class="id">r</span>)<br/>
&nbsp;&nbsp;/\ <span class="id">agree_unused</span> <span class="id">ls0</span> <span class="id">rs</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3781')">Proof.</div>
<div class="proofscript" id="proof3781">
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">mreg_type</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span> <span class="kwd">as</span> [ | <span class="id">r</span> <span class="id">l</span>]; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="comment">(*&nbsp;base&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">star_refl</span>.<br/>
- <span class="comment">(*&nbsp;inductive&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ty</span> := <span class="id">mreg_type</span> <span class="id">r</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">sz</span> := <span class="id">AST.typesize</span> <span class="id">ty</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ofs1</span> := <span class="id">align</span> <span class="id">ofs</span> <span class="id">sz</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SZPOS</span>: <span class="id">sz</span> &gt; 0) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">AST.typesize_pos</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">OFSLE</span>: <span class="id">ofs</span> &lt;= <span class="id">ofs1</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">align_le</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">BOUND</span>: <span class="id">mreg_within_bounds</span> <span class="id">b</span> <span class="id">r</span>) <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">contains_get_stack</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj1</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">LOAD</span> &amp; <span class="id">SPEC</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">IHl</span> (<span class="id">ofs1</span> + <span class="id">sz</span>) (<span class="id">rs</span>#<span class="id">r</span> &lt;- <span class="id">v</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj2</span>; <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gso</span>. <span class="tactic">auto</span>. <span class="tactic">intuition</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">rs</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">eapply</span> <span class="id">star_step</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">exact</span> <span class="id">LOAD</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">mreg_eq</span> <span class="id">r0</span> <span class="id">l</span>). <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">r</span> = <span class="id">r0</span>) <span class="tactic">by</span> <span class="tactic">tauto</span>. <span class="tactic">subst</span> <span class="id">r0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">Regmap.gss</span>. <span class="tactic">exact</span> <span class="id">SPEC</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span> <span class="tactic">by</span> <span class="tactic">tauto</span>. <span class="tactic">apply</span> <span class="id">Regmap.gso</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">D</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">RESTORE_CALLEE_SAVE</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">restore_callee_save_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">pa</span> <span class="id">ra</span> <span class="id">P</span> <span class="id">rs</span> <span class="id">k</span> <span class="id">cs</span> <span class="id">fb</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">ls0</span> <span class="id">pa</span> <span class="id">ra</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_unused</span> <span class="id">j</span> <span class="id">ls0</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) (<span class="id">restore_callee_save</span> <span class="id">fe</span> <span class="id">k</span>) <span class="id">rs</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs</span>' <span class="id">m</span>)<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">true</span> -&gt; <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls0</span> (<span class="id">R</span> <span class="id">r</span>)) (<span class="id">rs</span>' <span class="id">r</span>))<br/>
&nbsp;&nbsp;/\ (<span class="kwd">forall</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_callee_save</span> <span class="id">r</span> = <span class="id">false</span> -&gt; <span class="id">rs</span>' <span class="id">r</span> = <span class="id">rs</span> <span class="id">r</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3782')">Proof.</div>
<div class="proofscript" id="proof3782">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span>, <span class="id">frame_contents_1</span> <span class="kwd">in</span> <span class="id">H</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">sep_pick5</span> <span class="kwd">in</span> <span class="id">H</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">restore_callee_save_rec_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">unfold</span> <span class="id">mreg_within_bounds</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">rs</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eexact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">In_dec</span> <span class="id">mreg_eq</span> <span class="id">r</span> (<span class="id">used_callee_save</span> <span class="id">b</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">B</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">C</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">mreg_within_bounds</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">C</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> (<span class="id">used_callee_save_prop</span> <span class="id">b</span>) <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">As a corollary, we obtain the following correctness result for
  the execution of a function epilogue (reloading of used callee-save
  registers + reloading of the link and return address + freeing
  of the frame). </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_epilogue_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>' <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> <span class="id">ls0</span> <span class="id">pa</span> <span class="id">ra</span> <span class="id">P</span> <span class="id">m</span> <span class="id">rs</span> <span class="id">sp</span> <span class="id">m1</span> <span class="id">k</span> <span class="id">cs</span> <span class="id">fb</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span>' |= <span class="id">frame_contents</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> <span class="id">ls0</span> <span class="id">pa</span> <span class="id">ra</span> ** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span> ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">agree_locs</span> <span class="id">ls</span> <span class="id">ls0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', <span class="id">fe</span>.(<span class="id">fe_stack_data</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mem.free</span> <span class="id">m</span> <span class="id">sp</span> 0 <span class="id">f</span>.(<span class="id">Linear.fn_stacksize</span>) = <span class="id">Some</span> <span class="id">m1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs1</span>, <span class="id">exists</span> <span class="id">m1</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">load_stack</span> <span class="id">m</span>' (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> <span class="id">tf</span>.(<span class="id">fn_link_ofs</span>) = <span class="id">Some</span> <span class="id">pa</span><br/>
&nbsp;&nbsp;/\ <span class="id">load_stack</span> <span class="id">m</span>' (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">Tptr</span> <span class="id">tf</span>.(<span class="id">fn_retaddr_ofs</span>) = <span class="id">Some</span> <span class="id">ra</span><br/>
&nbsp;&nbsp;/\ <span class="id">Mem.free</span> <span class="id">m</span>' <span class="id">sp</span>' 0 <span class="id">tf</span>.(<span class="id">fn_stacksize</span>) = <span class="id">Some</span> <span class="id">m1</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">star</span> <span class="id">step</span> <span class="id">tge</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">restore_callee_save</span> <span class="id">fe</span> <span class="id">k</span>) <span class="id">rs</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E0</span> (<span class="id">State</span> <span class="id">cs</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">k</span> <span class="id">rs1</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;/\ <span class="id">agree_regs</span> <span class="id">j</span> (<span class="id">return_regs</span> <span class="id">ls0</span> <span class="id">ls</span>) <span class="id">rs1</span><br/>
&nbsp;&nbsp;/\ <span class="id">agree_callee_save</span> (<span class="id">return_regs</span> <span class="id">ls0</span> <span class="id">ls</span>) <span class="id">ls0</span><br/>
&nbsp;&nbsp;/\ <span class="id">m1</span>' |= <span class="id">minjection</span> <span class="id">j</span> <span class="id">m1</span> ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3783')">Proof.</div>
<div class="proofscript" id="proof3783">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">fb</span>; <span class="tactic">intros</span> <span class="id">SEP</span> <span class="id">AGR</span> <span class="id">AGL</span> <span class="id">INJ</span> <span class="id">FREE</span>.<br/>
&nbsp;Can&nbsp;free&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">free_parallel_rule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>. <span class="tactic">eapply</span> <span class="id">mconj_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">FREE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">Z.max_comm</span>; <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">m1</span>' &amp; <span class="id">FREE</span>' &amp; <span class="id">SEP</span>').<br/>
&nbsp;Reloading&nbsp;the&nbsp;callee-save&nbsp;registers&nbsp;*)</span>&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">restore_callee_save_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">rs</span>). <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">AGL</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">agree_unused_reg0</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">AGR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">rs</span>' &amp; <span class="id">LOAD_CS</span> &amp; <span class="id">CS</span> &amp; <span class="id">NCS</span>).<br/>
&nbsp;Reloading&nbsp;the&nbsp;back&nbsp;link&nbsp;and&nbsp;return&nbsp;address&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">apply</span> <span class="id">mconj_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">frame_contents_1</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">rewrite</span> ! <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">hasvalue_get_stack</span> <span class="id">Tptr</span>). <span class="tactic">rewrite</span> <span class="id">chunk_of_Tptr</span>. <span class="tactic">eapply</span> <span class="id">sep_pick3</span>; <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">intros</span> <span class="id">LOAD_LINK</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> (<span class="id">hasvalue_get_stack</span> <span class="id">Tptr</span>). <span class="tactic">rewrite</span> <span class="id">chunk_of_Tptr</span>. <span class="tactic">eapply</span> <span class="id">sep_pick4</span>; <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">intros</span> <span class="id">LOAD_RETADDR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>.<br/>
&nbsp;Conclusions&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">unfold_transf_function</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">rs</span>', <span class="id">m1</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">eassumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">return_regs</span>; <span class="tactic">intros</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">is_callee_save</span> <span class="id">r</span>) <span class="id">eqn</span>:<span class="id">C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">CS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">NCS</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">AGR</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">red</span>; <span class="tactic">unfold</span> <span class="id">return_regs</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">FRAME_PROPERTIES</span>.<br/>
<br/>
<h1> Call stack invariants </h1>
<br/>
<div class="doc">This is the memory assertion that captures the contents of the stack frames
  mentioned in the call stacks. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">stack_contents</span> (<span class="id">j</span>: <span class="id">meminj</span>) (<span class="id">cs</span>: <span class="id">list</span> <span class="id">Linear.stackframe</span>) (<span class="id">cs</span>': <span class="id">list</span> <span class="id">Mach.stackframe</span>) : <span class="id">massert</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">cs</span>, <span class="id">cs</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span>, <span class="id">nil</span> =&gt; <span class="id">pure</span> <span class="id">True</span><br/>
&nbsp;&nbsp;| <span class="id">Linear.Stackframe</span> <span class="id">f</span> <span class="id">_</span> <span class="id">ls</span> <span class="id">c</span> :: <span class="id">cs</span>, <span class="id">Mach.Stackframe</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">_</span>) <span class="id">ra</span> <span class="id">c</span>' :: <span class="id">cs</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>) (<span class="id">parent_sp</span> <span class="id">cs</span>') (<span class="id">parent_ra</span> <span class="id">cs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'<br/>
&nbsp;&nbsp;| <span class="id">_</span>, <span class="id">_</span> =&gt; <span class="id">pure</span> <span class="id">False</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc"><span class="bracket"><span class="id">match_stacks</span></span> captures additional properties (not related to memory)
  of the Linear and Mach call stacks. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_stacks</span> (<span class="id">j</span>: <span class="id">meminj</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list</span> <span class="id">Linear.stackframe</span> -&gt; <span class="id">list</span> <span class="id">stackframe</span> -&gt; <span class="id">signature</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_stacks_empty</span>: <span class="kwd">forall</span> <span class="id">sg</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tailcall_possible</span> <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;| <span class="id">match_stacks_cons</span>: <span class="kwd">forall</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">ls</span> <span class="id">c</span> <span class="id">cs</span> <span class="id">fb</span> <span class="id">sp</span>' <span class="id">ra</span> <span class="id">c</span>' <span class="id">cs</span>' <span class="id">sg</span> <span class="id">trf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TAIL</span>: <span class="id">is_tail</span> <span class="id">c</span> (<span class="id">Linear.fn_code</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FINDF</span>: <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">trf</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRF</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">trf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRC</span>: <span class="id">transl_code</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">c</span> = <span class="id">c</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJ</span>: <span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', (<span class="id">fe_stack_data</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TY_RA</span>: <span class="id">Val.has_type</span> <span class="id">ra</span> <span class="id">Tptr</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGL</span>: <span class="id">agree_locs</span> <span class="id">f</span> <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">ARGS</span>: <span class="kwd">forall</span> <span class="id">ofs</span> <span class="id">ty</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">S</span> <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">slot_within_bounds</span> (<span class="id">function_bounds</span> <span class="id">f</span>) <span class="id">Outgoing</span> <span class="id">ofs</span> <span class="id">ty</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STK</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' (<span class="id">Linear.fn_sig</span> <span class="id">f</span>)),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Linear.Stackframe</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">ls</span> <span class="id">c</span> :: <span class="id">cs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Stackframe</span> <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">ra</span> <span class="id">c</span>' :: <span class="id">cs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sg</span>.<br/>
<br/>
<div class="doc">Invariance with respect to change of memory injection. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">stack_contents_change_meminj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">j</span> <span class="id">j</span>', <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">P</span>,<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' ** <span class="id">P</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">stack_contents</span> <span class="id">j</span>' <span class="id">cs</span> <span class="id">cs</span>' ** <span class="id">P</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3784')">Proof.</div>
<div class="proofscript" id="proof3784">
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">sepconj</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">cs</span> <span class="kwd">as</span> [ | [] <span class="id">cs</span>]; <span class="tactic">destruct</span> <span class="id">cs</span>' <span class="kwd">as</span> [ | [] <span class="id">cs</span>']; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sp0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_assoc</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_contents_incr</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span>. <span class="tactic">apply</span> <span class="id">IHcs</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap</span>. <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_change_meminj</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">j</span>', <span class="id">inject_incr</span> <span class="id">j</span> <span class="id">j</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span>' <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3785')">Proof.</div>
<div class="proofscript" id="proof3785">
&nbsp;&nbsp;<span class="tactic">induction</span> 2; <span class="tactic">intros</span>.<br/>
- <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Invariance with respect to change of signature. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_change_sig</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sg1</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">tailcall_possible</span> <span class="id">sg1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3786')">Proof.</div>
<div class="proofscript" id="proof3786">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span>. <span class="tactic">elim</span> (<span class="id">H0</span> <span class="id">_</span> <span class="id">H1</span>).<br/>
Qed.</div>
<br/>
<div class="doc">Typing properties of <span class="bracket"><span class="id">match_stacks</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_type_sp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.has_type</span> (<span class="id">parent_sp</span> <span class="id">cs</span>') <span class="id">Tptr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3787')">Proof.</div>
<div class="proofscript" id="proof3787">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">unfold</span> <span class="id">parent_sp</span>. <span class="tactic">apply</span> <span class="id">Val.Vnullptr_has_type</span>. <span class="tactic">apply</span> <span class="id">Val.Vptr_has_type</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">match_stacks_type_retaddr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>,<br/>
&nbsp;&nbsp;<span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Val.has_type</span> (<span class="id">parent_ra</span> <span class="id">cs</span>') <span class="id">Tptr</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3788')">Proof.</div>
<div class="proofscript" id="proof3788">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">unfold</span> <span class="id">parent_ra</span>. <span class="tactic">apply</span> <span class="id">Val.Vnullptr_has_type</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Syntactic properties of the translation </h1>
<br/>
<div class="doc">Preservation of code labels through the translation. </div>
<br/>
<span class="kwd">Section</span> <span class="id">LABELS</span>.<br/>
<br/>
<span class="kwd">Remark</span> <span class="id">find_label_save_callee_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> (<span class="id">save_callee_save_rec</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>) = <span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3789')">Proof.</div>
<div class="proofscript" id="proof3789">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">find_label_restore_callee_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> (<span class="id">restore_callee_save_rec</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>) = <span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">k</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3790')">Proof.</div>
<div class="proofscript" id="proof3790">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_code_eq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fe</span> <span class="id">i</span> <span class="id">c</span>, <span class="id">transl_code</span> <span class="id">fe</span> (<span class="id">i</span> :: <span class="id">c</span>) = <span class="id">transl_instr</span> <span class="id">fe</span> <span class="id">i</span> (<span class="id">transl_code</span> <span class="id">fe</span> <span class="id">c</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3791')">Proof.</div>
<div class="proofscript" id="proof3791">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_code</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">list_fold_right_eq</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_transl_code</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fe</span> <span class="id">lbl</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> (<span class="id">transl_code</span> <span class="id">fe</span> <span class="id">c</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option_map</span> (<span class="id">transl_code</span> <span class="id">fe</span>) (<span class="id">Linear.find_label</span> <span class="id">lbl</span> <span class="id">c</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3792')">Proof.</div>
<div class="proofscript" id="proof3792">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">auto</span>.<br/>
- <span class="tactic">rewrite</span> <span class="id">transl_code_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span>; <span class="tactic">unfold</span> <span class="id">transl_instr</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">restore_callee_save</span>. <span class="tactic">rewrite</span> <span class="id">find_label_restore_callee_save</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">destruct</span> (<span class="id">peq</span> <span class="id">lbl</span> <span class="id">l</span>). <span class="tactic">reflexivity</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">restore_callee_save</span>. <span class="tactic">rewrite</span> <span class="id">find_label_restore_callee_save</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_find_label</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">lbl</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Linear.find_label</span> <span class="id">lbl</span> <span class="id">f</span>.(<span class="id">Linear.fn_code</span>) = <span class="id">Some</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Mach.find_label</span> <span class="id">lbl</span> <span class="id">tf</span>.(<span class="id">Mach.fn_code</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Some</span> (<span class="id">transl_code</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">c</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3793')">Proof.</div>
<div class="proofscript" id="proof3793">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> (<span class="id">unfold_transf_function</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).  <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_body</span>. <span class="tactic">unfold</span> <span class="id">save_callee_save</span>. <span class="tactic">rewrite</span> <span class="id">find_label_save_callee_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">find_label_transl_code</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">LABELS</span>.<br/>
<br/>
<div class="doc">Code tail property for Linear executions. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_label_tail</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">lbl</span> <span class="id">c</span> <span class="id">c</span>',<br/>
&nbsp;&nbsp;<span class="id">Linear.find_label</span> <span class="id">lbl</span> <span class="id">c</span> = <span class="id">Some</span> <span class="id">c</span>' -&gt; <span class="id">is_tail</span> <span class="id">c</span>' <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3794')">Proof.</div>
<div class="proofscript" id="proof3794">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">c</span>'. <span class="tactic">case</span> (<span class="id">Linear.is_label</span> <span class="id">lbl</span> <span class="id">a</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">injection</span> <span class="id">H</span>; <span class="tactic">intro</span>; <span class="tactic">subst</span> <span class="id">c</span>'. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Code tail property for translations </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_save_callee_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">k</span> (<span class="id">save_callee_save_rec</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3795')">Proof.</div>
<div class="proofscript" id="proof3795">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_restore_callee_save</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">k</span> (<span class="id">restore_callee_save_rec</span> <span class="id">l</span> <span class="id">ofs</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3796')">Proof.</div>
<div class="proofscript" id="proof3796">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">l</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_transl_instr</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fe</span> <span class="id">i</span> <span class="id">k</span>,<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">k</span> (<span class="id">transl_instr</span> <span class="id">fe</span> <span class="id">i</span> <span class="id">k</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3797')">Proof.</div>
<div class="proofscript" id="proof3797">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">i</span>; <span class="tactic">unfold</span> <span class="id">transl_instr</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">s</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">restore_callee_save</span>.  <span class="tactic">eapply</span> <span class="id">is_tail_trans</span>. 2: <span class="tactic">apply</span> <span class="id">is_tail_restore_callee_save</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">restore_callee_save</span>.  <span class="tactic">eapply</span> <span class="id">is_tail_trans</span>. 2: <span class="tactic">apply</span> <span class="id">is_tail_restore_callee_save</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_transl_code</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">fe</span> <span class="id">c1</span> <span class="id">c2</span>, <span class="id">is_tail</span> <span class="id">c1</span> <span class="id">c2</span> -&gt; <span class="id">is_tail</span> (<span class="id">transl_code</span> <span class="id">fe</span> <span class="id">c1</span>) (<span class="id">transl_code</span> <span class="id">fe</span> <span class="id">c2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3798')">Proof.</div>
<div class="proofscript" id="proof3798">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>. <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">transl_code_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_trans</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">is_tail_transl_instr</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_tail_transf_function</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span> <span class="id">c</span>,<br/>
&nbsp;&nbsp;<span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> <span class="id">c</span> (<span class="id">Linear.fn_code</span> <span class="id">f</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_tail</span> (<span class="id">transl_code</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">c</span>) (<span class="id">fn_code</span> <span class="id">tf</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3799')">Proof.</div>
<div class="proofscript" id="proof3799">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> (<span class="id">unfold_transf_function</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>). <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_body</span>, <span class="id">save_callee_save</span>. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_tail_trans</span>. 2: <span class="tactic">apply</span> <span class="id">is_tail_save_callee_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_tail_transl_code</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Semantic preservation </h1>
<br/>
<div class="doc">Preservation / translation of global symbols and functions. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">symbols_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span>: <span class="id">ident</span>), <span class="id">Genv.find_symbol</span> <span class="id">tge</span> <span class="id">s</span> = <span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">s</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_symbol_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">senv_preserved</span>:<br/>
&nbsp;&nbsp;<span class="id">Senv.equiv</span> <span class="id">ge</span> <span class="id">tge</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.senv_match</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">functions_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">v</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">ge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct</span> <span class="id">tge</span> <span class="id">v</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">function_ptr_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">b</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">ge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;<span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">b</span> = <span class="id">Some</span> <span class="id">tf</span> /\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Proof</span> (<span class="id">Genv.find_funct_ptr_transf_partial</span> <span class="id">TRANSF</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">sig_preserved</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">f</span> <span class="id">tf</span>, <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span> -&gt; <span class="id">Mach.funsig</span> <span class="id">tf</span> = <span class="id">Linear.funsig</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3800')">Proof.</div>
<div class="proofscript" id="proof3800">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">tf</span>; <span class="tactic">unfold</span> <span class="id">transf_fundef</span>, <span class="id">transf_partial_fundef</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">f</span>; <span class="tactic">intros</span>; <span class="id">monadInv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">unfold_transf_function</span> <span class="id">_</span> <span class="id">_</span> <span class="id">EQ</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">find_function_translated</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> <span class="id">m</span> <span class="id">ros</span> <span class="id">f</span>,<br/>
&nbsp;&nbsp;<span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">m</span> |= <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">Linear.find_function</span> <span class="id">ge</span> <span class="id">ros</span> <span class="id">ls</span> = <span class="id">Some</span> <span class="id">f</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">bf</span>, <span class="id">exists</span> <span class="id">tf</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">find_function_ptr</span> <span class="id">tge</span> <span class="id">ros</span> <span class="id">rs</span> = <span class="id">Some</span> <span class="id">bf</span><br/>
&nbsp;&nbsp;/\ <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">bf</span> = <span class="id">Some</span> <span class="id">tf</span><br/>
&nbsp;&nbsp;/\ <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3801')">Proof.</div>
<div class="proofscript" id="proof3801">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">f</span>; <span class="tactic">intros</span> <span class="id">AG</span> [<span class="id">bound</span> [<span class="id">_</span> [?????]]] <span class="id">FF</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ros</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">FF</span>.<br/>
- <span class="id">exploit</span> <span class="id">Genv.find_funct_inv</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">b</span> <span class="id">EQ</span>]. <span class="tactic">rewrite</span> <span class="id">EQ</span> <span class="kwd">in</span> <span class="id">FF</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Genv.find_funct_find_funct_ptr</span> <span class="kwd">in</span> <span class="id">FF</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>; <span class="id">exists</span> <span class="id">tf</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">AG</span> <span class="id">m0</span>). <span class="tactic">rewrite</span> <span class="id">EQ</span>. <span class="tactic">intro</span> <span class="id">INJ</span>. <span class="id">inv</span> <span class="id">INJ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">DOMAIN</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="id">inv</span> <span class="id">H2</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">FUNCTIONS</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">i</span>) <span class="kwd">as</span> [<span class="id">b</span>|] <span class="id">eqn</span>:?; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">b</span>; <span class="id">exists</span> <span class="id">tf</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Preservation of the arguments to an external call. </div>
<br/>
<span class="kwd">Section</span> <span class="id">EXTERNAL_ARGUMENTS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">j</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cs</span>: <span class="id">list</span> <span class="id">Linear.stackframe</span>.<br/>
<span class="kwd">Variable</span> <span class="id">cs</span>': <span class="id">list</span> <span class="id">stackframe</span>.<br/>
<span class="kwd">Variable</span> <span class="id">sg</span>: <span class="id">signature</span>.<br/>
<span class="kwd">Variables</span> <span class="id">bound</span> <span class="id">bound</span>': <span class="id">block</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">MS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>.<br/>
<span class="kwd">Variable</span> <span class="id">ls</span>: <span class="id">locset</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rs</span>: <span class="id">regset</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">AGR</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">AGCS</span>: <span class="id">agree_callee_save</span> <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>).<br/>
<span class="kwd">Variable</span> <span class="id">m</span>': <span class="id">mem</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">SEP</span>: <span class="id">m</span>' |= <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_external_argument</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">l</span> (<span class="id">regs_of_rpairs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">extcall_arg</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">parent_sp</span> <span class="id">cs</span>') <span class="id">l</span> <span class="id">v</span> /\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">ls</span> <span class="id">l</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3802')">Proof.</div>
<div class="proofscript" id="proof3802">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">loc_argument_acceptable</span> <span class="id">l</span>) <span class="tactic">by</span> (<span class="tactic">apply</span> <span class="id">loc_arguments_acceptable_2</span> <span class="kwd">with</span> <span class="id">sg</span>; <span class="tactic">auto</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>; <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
- <span class="id">exists</span> (<span class="id">rs</span> <span class="id">r</span>); <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="tactic">auto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">sl</span>; <span class="tactic">try</span> <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">MS</span>.<br/>
+ <span class="tactic">elim</span> (<span class="id">H1</span> <span class="id">_</span> <span class="id">H</span>).<br/>
+ <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">unfold</span> <span class="id">parent_sp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">slot_valid</span> <span class="id">f</span> <span class="id">Outgoing</span> <span class="id">pos</span> <span class="id">ty</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">slot_valid</span>, <span class="id">proj_sumbool</span>. <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">zle_true</span> <span class="tactic">by</span> <span class="tactic">omega</span>. <span class="tactic">rewrite</span> <span class="id">pred_dec_true</span> <span class="tactic">by</span> <span class="tactic">auto</span>. <span class="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">slot_within_bounds</span> (<span class="id">function_bounds</span> <span class="id">f</span>) <span class="id">Outgoing</span> <span class="id">pos</span> <span class="id">ty</span>) <span class="tactic">by</span> <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">frame_get_outgoing</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">exact</span> <span class="id">A</span>. <span class="tactic">red</span> <span class="kwd">in</span> <span class="id">AGCS</span>. <span class="tactic">rewrite</span> <span class="id">AGCS</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_external_argument_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">p</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">p</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>, <span class="id">extcall_arg_pair</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">parent_sp</span> <span class="id">cs</span>') <span class="id">p</span> <span class="id">v</span> /\ <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">Locmap.getpair</span> <span class="id">p</span> <span class="id">ls</span>) <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3803')">Proof.</div>
<div class="proofscript" id="proof3803">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">p</span> <span class="kwd">as</span> [<span class="id">l</span> | <span class="id">l1</span> <span class="id">l2</span>].<br/>
- <span class="tactic">destruct</span> (<span class="id">transl_external_argument</span> <span class="id">l</span>) <span class="kwd">as</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="tactic">eapply</span> <span class="id">in_regs_of_rpairs</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <br/>
- <span class="tactic">destruct</span> (<span class="id">transl_external_argument</span> <span class="id">l1</span>) <span class="kwd">as</span> (<span class="id">v1</span> &amp; <span class="id">A1</span> &amp; <span class="id">B1</span>). <span class="tactic">eapply</span> <span class="id">in_regs_of_rpairs</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">transl_external_argument</span> <span class="id">l2</span>) <span class="kwd">as</span> (<span class="id">v2</span> &amp; <span class="id">A2</span> &amp; <span class="id">B2</span>). <span class="tactic">eapply</span> <span class="id">in_regs_of_rpairs</span>; <span class="tactic">eauto</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Val.longofwords</span> <span class="id">v1</span> <span class="id">v2</span>); <span class="tactic">split</span>. <br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.longofwords_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_external_arguments_rec</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">locs</span>,<br/>
&nbsp;&nbsp;<span class="id">incl</span> <span class="id">locs</span> (<span class="id">loc_arguments</span> <span class="id">sg</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">list_forall2</span> (<span class="id">extcall_arg_pair</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">parent_sp</span> <span class="id">cs</span>')) <span class="id">locs</span> <span class="id">vl</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">j</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">p</span> =&gt; <span class="id">Locmap.getpair</span> <span class="id">p</span> <span class="id">ls</span>) <span class="id">locs</span>) <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3804')">Proof.</div>
<div class="proofscript" id="proof3804">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">locs</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>. <span class="id">constructor</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_external_argument_2</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">intros</span> [<span class="id">v</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHlocs</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">intros</span> [<span class="id">vl</span> [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">v</span> :: <span class="id">vl</span>); <span class="tactic">split</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_external_arguments</span>:<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extcall_arguments</span> <span class="id">rs</span> <span class="id">m</span>' (<span class="id">parent_sp</span> <span class="id">cs</span>') <span class="id">sg</span> <span class="id">vl</span><br/>
&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">j</span> (<span class="id">map</span> (<span class="kwd">fun</span> <span class="id">p</span> =&gt; <span class="id">Locmap.getpair</span> <span class="id">p</span> <span class="id">ls</span>) (<span class="id">loc_arguments</span> <span class="id">sg</span>)) <span class="id">vl</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3805')">Proof.</div>
<div class="proofscript" id="proof3805">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">extcall_arguments</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_external_arguments_rec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">EXTERNAL_ARGUMENTS</span>.<br/>
<br/>
<div class="doc">Preservation of the arguments to a builtin. </div>
<br/>
<span class="kwd">Section</span> <span class="id">BUILTIN_ARGUMENTS</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">f</span>: <span class="id">Linear.function</span>.<br/>
<span class="kwd">Let</span> <span class="id">b</span> := <span class="id">function_bounds</span> <span class="id">f</span>.<br/>
<span class="kwd">Let</span> <span class="id">fe</span> := <span class="id">make_env</span> <span class="id">b</span>.<br/>
<span class="kwd">Variable</span> <span class="id">tf</span>: <span class="id">Mach.function</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">TRANSF_F</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>.<br/>
<span class="kwd">Variable</span> <span class="id">j</span>: <span class="id">meminj</span>.<br/>
<span class="kwd">Variables</span> <span class="id">m</span> <span class="id">m</span>': <span class="id">mem</span>.<br/>
<span class="kwd">Variables</span> <span class="id">ls</span> <span class="id">ls0</span>: <span class="id">locset</span>.<br/>
<span class="kwd">Variable</span> <span class="id">rs</span>: <span class="id">regset</span>.<br/>
<span class="kwd">Variables</span> <span class="id">sp</span> <span class="id">sp</span>': <span class="id">block</span>.<br/>
<span class="kwd">Variables</span> <span class="id">parent</span> <span class="id">retaddr</span>: <span class="id">val</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">INJ</span>: <span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', <span class="id">fe</span>.(<span class="id">fe_stack_data</span>)).<br/>
<span class="kwd">Hypothesis</span> <span class="id">AGR</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">SEP</span>: <span class="id">m</span>' |= <span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> <span class="id">ls0</span> <span class="id">parent</span> <span class="id">retaddr</span> ** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_builtin_arg_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">a</span> <span class="id">v</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> <span class="id">ls</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">a</span> <span class="id">v</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">In</span> <span class="id">l</span> (<span class="id">params_of_builtin_arg</span> <span class="id">a</span>) -&gt; <span class="id">loc_valid</span> <span class="id">f</span> <span class="id">l</span> = <span class="id">true</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">params_of_builtin_arg</span> <span class="id">a</span>) -&gt; <span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_builtin_arg</span> <span class="id">ge</span> <span class="id">rs</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">m</span>' (<span class="id">transl_builtin_arg</span> <span class="id">fe</span> <span class="id">a</span>) <span class="id">v</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3806')">Proof.</div>
<div class="proofscript" id="proof3806">
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">SYMB</span>: <span class="kwd">forall</span> <span class="id">id</span> <span class="id">ofs</span>, <span class="id">Val.inject</span> <span class="id">j</span> (<span class="id">Senv.symbol_address</span> <span class="id">ge</span> <span class="id">id</span> <span class="id">ofs</span>) (<span class="id">Senv.symbol_address</span> <span class="id">ge</span> <span class="id">id</span> <span class="id">ofs</span>)).<br/>
&nbsp;&nbsp;{ <span class="tactic">assert</span> (<span class="id">G</span>: <span class="id">meminj_preserves_globals</span> <span class="id">ge</span> <span class="id">j</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="tactic">eapply</span> <span class="id">globalenv_inject_preserves_globals</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">unfold</span> <span class="id">Senv.symbol_address</span>; <span class="tactic">simpl</span>; <span class="tactic">unfold</span> <span class="id">Genv.symbol_address</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">Genv.find_symbol</span> <span class="id">ge</span> <span class="id">id</span>) <span class="id">eqn</span>:<span class="id">FS</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">G</span>. <span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">Ptrofs.add_zero</span>; <span class="tactic">auto</span>. }<br/>
<span class="kwd">Local</span> <span class="id">Opaque</span> <span class="id">fe</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">VALID</span> <span class="id">BOUNDS</span>.<br/>
- <span class="tactic">assert</span> (<span class="id">loc_valid</span> <span class="id">f</span> <span class="id">x</span> = <span class="id">true</span>) <span class="tactic">by</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span> <span class="kwd">as</span> [<span class="id">r</span> | [] <span class="id">ofs</span> <span class="id">ty</span>]; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exists</span> (<span class="id">rs</span> <span class="id">r</span>); <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;+ <span class="id">exploit</span> <span class="id">frame_get_local</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">v</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="tactic">set</span> (<span class="id">ofs</span>' := <span class="id">Ptrofs.add</span> <span class="id">ofs</span> (<span class="id">Ptrofs.repr</span> (<span class="id">fe_stack_data</span> <span class="id">fe</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">exploit</span> <span class="id">loadv_parallel_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">Val.offset_ptr</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">ofs</span>').<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> ! <span class="id">Ptrofs.add_zero_l</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>; <span class="tactic">auto</span>. <br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">Val.offset_ptr</span>. <span class="tactic">rewrite</span> ! <span class="id">Ptrofs.add_zero_l</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">exploit</span> <span class="id">loadv_parallel_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>). <span class="id">exists</span> <span class="id">v</span>'; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
- <span class="id">econstructor</span>; <span class="tactic">split</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">barg</span>. <br/>
- <span class="tactic">destruct</span> <span class="id">IHeval_builtin_arg1</span> <span class="kwd">as</span> (<span class="id">v1</span> &amp; <span class="id">A1</span> &amp; <span class="id">B1</span>); <span class="tactic">auto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHeval_builtin_arg2</span> <span class="kwd">as</span> (<span class="id">v2</span> &amp; <span class="id">A2</span> &amp; <span class="id">B2</span>); <span class="tactic">auto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Val.longofwords</span> <span class="id">v1</span> <span class="id">v2</span>); <span class="tactic">split</span>; <span class="tactic">auto</span> <span class="kwd">with</span> <span class="id">barg</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.longofwords_inject</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transl_builtin_args_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">al</span> <span class="id">vl</span>,<br/>
&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">ge</span> <span class="id">ls</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">m</span> <span class="id">al</span> <span class="id">vl</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">In</span> <span class="id">l</span> (<span class="id">params_of_builtin_args</span> <span class="id">al</span>) -&gt; <span class="id">loc_valid</span> <span class="id">f</span> <span class="id">l</span> = <span class="id">true</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>, <span class="id">In</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">params_of_builtin_args</span> <span class="id">al</span>) -&gt; <span class="id">slot_within_bounds</span> <span class="id">b</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">vl</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_builtin_args</span> <span class="id">ge</span> <span class="id">rs</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">m</span>' (<span class="id">List.map</span> (<span class="id">transl_builtin_arg</span> <span class="id">fe</span>) <span class="id">al</span>) <span class="id">vl</span>'<br/>
&nbsp;&nbsp;/\ <span class="id">Val.inject_list</span> <span class="id">j</span> <span class="id">vl</span> <span class="id">vl</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3807')">Proof.</div>
<div class="proofscript" id="proof3807">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">simpl</span>; <span class="tactic">intros</span> <span class="id">VALID</span> <span class="id">BOUNDS</span>.<br/>
- <span class="id">exists</span> (@<span class="id">nil</span> <span class="id">val</span>); <span class="tactic">split</span>; <span class="id">constructor</span>.<br/>
- <span class="id">exploit</span> <span class="id">transl_builtin_arg_correct</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>. <span class="tactic">intros</span> (<span class="id">v1</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">IHlist_forall2</span>; <span class="tactic">eauto</span> <span class="kwd">using</span> <span class="id">in_or_app</span>. <span class="tactic">intros</span> (<span class="id">vl</span>' &amp; <span class="id">C</span> &amp; <span class="id">D</span>).<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">v1</span>'::<span class="id">vl</span>'); <span class="tactic">split</span>; <span class="id">constructor</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">BUILTIN_ARGUMENTS</span>.<br/>
<br/>
<div class="doc">The proof of semantic preservation relies on simulation diagrams
  of the following form:
<pre>
           st1 --------------- st2
            |                   |
           t|                  +|t
            |                   |
            v                   v
           st1'--------------- st2'</pre>
  Matching between source and target states is defined by <span class="bracket"><span class="id">match_states</span></span>
  below.  It implies:
<ul>
<li>
 Satisfaction of the separation logic assertions that describe the contents 
  of memory.  This is a separating conjunction of facts about:
<ul>
<li>
 the current stack frame
</li>
<li>
 the frames in the call stack
</li>
<li>
 the injection from the Linear memory state into the Mach memory state
</li>
<li>
 the preservation of the global environment.
</li>
</ul>
 Agreement between, on the Linear side, the location sets <span class="bracket"><span class="id">ls</span></span>
  and <span class="bracket"><span class="id">parent_locset</span> <span class="id">s</span></span> of the current function and its caller,
  and on the Mach side the register set <span class="bracket"><span class="id">rs</span></span>.
</li>
<li>
 The Linear code <span class="bracket"><span class="id">c</span></span> is a suffix of the code of the
  function <span class="bracket"><span class="id">f</span></span> being executed.
</li>
<li>
 Well-typedness of <span class="bracket"><span class="id">f</span></span>.
</li>
</ul>
</div>
<br/>
<span class="kwd">Inductive</span> <span class="id">match_states</span>: <span class="id">Linear.state</span> -&gt; <span class="id">Mach.state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">match_states_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">sp</span> <span class="id">c</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">cs</span>' <span class="id">fb</span> <span class="id">sp</span>' <span class="id">rs</span> <span class="id">m</span>' <span class="id">j</span> <span class="id">tf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">f</span>.(<span class="id">Linear.fn_sig</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRANSL</span>: <span class="id">transf_function</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FIND</span>: <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">fb</span> = <span class="id">Some</span> (<span class="id">Internal</span> <span class="id">tf</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGREGS</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGLOCS</span>: <span class="id">agree_locs</span> <span class="id">f</span> <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">INJSP</span>: <span class="id">j</span> <span class="id">sp</span> = <span class="id">Some</span>(<span class="id">sp</span>', <span class="id">fe_stack_data</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TAIL</span>: <span class="id">is_tail</span> <span class="id">c</span> (<span class="id">Linear.fn_code</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m</span>' |= <span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>) (<span class="id">parent_sp</span> <span class="id">cs</span>') (<span class="id">parent_ra</span> <span class="id">cs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Linear.State</span> <span class="id">cs</span> <span class="id">f</span> (<span class="id">Vptr</span> <span class="id">sp</span> <span class="id">Ptrofs.zero</span>) <span class="id">c</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mach.State</span> <span class="id">cs</span>' <span class="id">fb</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">transl_code</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">c</span>) <span class="id">rs</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_call</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">cs</span>' <span class="id">fb</span> <span class="id">rs</span> <span class="id">m</span>' <span class="id">j</span> <span class="id">tf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' (<span class="id">Linear.funsig</span> <span class="id">f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">TRANSL</span>: <span class="id">transf_fundef</span> <span class="id">f</span> = <span class="id">OK</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">FIND</span>: <span class="id">Genv.find_funct_ptr</span> <span class="id">tge</span> <span class="id">fb</span> = <span class="id">Some</span> <span class="id">tf</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGREGS</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGLOCS</span>: <span class="id">agree_callee_save</span> <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m</span>' |= <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Linear.Callstate</span> <span class="id">cs</span> <span class="id">f</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mach.Callstate</span> <span class="id">cs</span>' <span class="id">fb</span> <span class="id">rs</span> <span class="id">m</span>')<br/>
&nbsp;&nbsp;| <span class="id">match_states_return</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">cs</span> <span class="id">ls</span> <span class="id">m</span> <span class="id">cs</span>' <span class="id">rs</span> <span class="id">m</span>' <span class="id">j</span> <span class="id">sg</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">STACKS</span>: <span class="id">match_stacks</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>' <span class="id">sg</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGREGS</span>: <span class="id">agree_regs</span> <span class="id">j</span> <span class="id">ls</span> <span class="id">rs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">AGLOCS</span>: <span class="id">agree_callee_save</span> <span class="id">ls</span> (<span class="id">parent_locset</span> <span class="id">cs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">SEP</span>: <span class="id">m</span>' |= <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">cs</span> <span class="id">cs</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">match_states</span> (<span class="id">Linear.Returnstate</span> <span class="id">cs</span> <span class="id">ls</span> <span class="id">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Mach.Returnstate</span> <span class="id">cs</span>' <span class="id">rs</span> <span class="id">m</span>').<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_step_correct</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span>, <span class="id">Linear.step</span> <span class="id">ge</span> <span class="id">s1</span> <span class="id">t</span> <span class="id">s2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">WTS</span>: <span class="id">wt_state</span> <span class="id">s1</span>) <span class="id">s1</span>' (<span class="id">MS</span>: <span class="id">match_states</span> <span class="id">s1</span> <span class="id">s1</span>'),<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">s2</span>', <span class="id">plus</span> <span class="id">step</span> <span class="id">tge</span> <span class="id">s1</span>' <span class="id">t</span> <span class="id">s2</span>' /\ <span class="id">match_states</span> <span class="id">s2</span> <span class="id">s2</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3808')">Proof.</div>
<div class="proofscript" id="proof3808">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="tactic">try</span> <span class="id">inv</span> <span class="id">MS</span>;<br/>
&nbsp;&nbsp;<span class="tactic">try</span> <span class="tactic">rewrite</span> <span class="id">transl_code_eq</span>;<br/>
&nbsp;&nbsp;<span class="tactic">try</span> (<span class="tactic">generalize</span> (<span class="id">function_is_within_bounds</span> <span class="id">f</span> <span class="id">_</span> (<span class="id">is_tail_in</span> <span class="id">TAIL</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">BOUND</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">BOUND</span>);<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transl_instr</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lgetstack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">BOUND</span> <span class="kwd">as</span> [<span class="id">BOUND1</span> <span class="id">BOUND2</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">wt_state_getstack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">SV</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">destroyed_by_getstack</span>; <span class="tactic">destruct</span> <span class="id">sl</span>.<br/>
+ <span class="comment">(*&nbsp;Lgetstack,&nbsp;local&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">frame_get_local</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">exec_Mgetstack</span>. <span class="tactic">exact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;Lgetstack,&nbsp;incoming&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">slot_valid</span> <span class="kwd">in</span> <span class="id">SV</span>. <span class="id">InvBooleans</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">incoming_slot_in_parameters</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">IN_ARGS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">STACKS</span>; <span class="tactic">clear</span> <span class="id">STACKS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">H1</span> <span class="id">_</span> <span class="id">IN_ARGS</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">s</span> <span class="id">cs</span>'.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">frame_get_outgoing</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">ARGS</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">slot_outgoing_argument_valid</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Mgetparam</span>; <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">unfold_transf_function</span> <span class="id">_</span> <span class="id">_</span> <span class="id">TRANSL</span>). <span class="tactic">unfold</span> <span class="id">fn_link_ofs</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_get_parent</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>. <span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">agree_incoming</span> <span class="tactic">by</span> <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">B</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>; <span class="tactic">auto</span>.<br/>
+ <span class="comment">(*&nbsp;Lgetstack,&nbsp;outgoing&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">frame_get_outgoing</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">v</span> &amp; <span class="id">A</span> &amp; <span class="id">B</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">exec_Mgetstack</span>. <span class="tactic">exact</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lsetstack&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">wt_state_setstack</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> (<span class="id">SV</span> &amp; <span class="id">SW</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ofs</span>' := <span class="kwd">match</span> <span class="id">sl</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="kwd">Local</span> =&gt; <span class="id">offset_local</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Incoming</span> =&gt; 0 <span class="comment">(*&nbsp;dummy&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Outgoing</span> =&gt; <span class="id">offset_arg</span> <span class="id">ofs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_undef_regs</span> <span class="kwd">with</span> (<span class="id">rl</span> := <span class="id">destroyed_by_setstack</span> <span class="id">ty</span>) <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">A</span>: <span class="id">exists</span> <span class="id">m</span>'',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">store_stack</span> <span class="id">m</span>' (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) <span class="id">ty</span> (<span class="id">Ptrofs.repr</span> <span class="id">ofs</span>') (<span class="id">rs0</span> <span class="id">src</span>) = <span class="id">Some</span> <span class="id">m</span>''<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">m</span>'' |= <span class="id">frame_contents</span> <span class="id">f</span> <span class="id">j</span> <span class="id">sp</span>' (<span class="id">Locmap.set</span> (<span class="id">S</span> <span class="id">sl</span> <span class="id">ofs</span> <span class="id">ty</span>) (<span class="id">rs</span> (<span class="id">R</span> <span class="id">src</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">LTL.undef_regs</span> (<span class="id">destroyed_by_setstack</span> <span class="id">ty</span>) <span class="id">rs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">parent_locset</span> <span class="id">s</span>) (<span class="id">parent_sp</span> <span class="id">cs</span>') (<span class="id">parent_ra</span> <span class="id">cs</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">stack_contents</span> <span class="id">j</span> <span class="id">s</span> <span class="id">cs</span>' ** <span class="id">minjection</span> <span class="id">j</span> <span class="id">m</span> ** <span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">unfold</span> <span class="id">ofs</span>'; <span class="tactic">destruct</span> <span class="id">sl</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_set_local</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_set_outgoing</span>; <span class="tactic">eauto</span>. }<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">destruct</span> <span class="id">A</span> <span class="kwd">as</span> (<span class="id">m</span>'' &amp; <span class="id">STORE</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">destruct</span> <span class="id">sl</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">eexact</span> <span class="id">STORE</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="id">eexact</span> <span class="id">STORE</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_slot</span>. <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_slot</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_setstack_caller_save</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>. <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">v</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_operation</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">transl_op</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">op</span>) <span class="id">rs0</span>##<span class="id">args</span> <span class="id">m</span>' = <span class="id">Some</span> <span class="id">v</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">v</span> <span class="id">v</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_operation_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">globalenv_inject_preserves_globals</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_reglist</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">exact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">v</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">v</span>'). <span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_operation_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">transl_destroyed_by_op</span>.  <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_op_caller_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_set_reg</span>. <span class="tactic">apply</span> <span class="id">frame_undef_regs</span>. <span class="tactic">exact</span> <span class="id">SEP</span>. <br/>
<br/>
- <span class="comment">(*&nbsp;Lload&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">a</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">transl_addr</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">addr</span>) <span class="id">rs0</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">a</span> <span class="id">a</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_addressing_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">globalenv_inject_preserves_globals</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_reglist</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">loadv_parallel_rule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">v</span>' [<span class="id">C</span> <span class="id">D</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">a</span>'). <span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">C</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_reg</span>. <span class="tactic">rewrite</span> <span class="id">transl_destroyed_by_load</span>. <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_reg</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_load_caller_save</span>. <span class="tactic">auto</span>. <br/>
<br/>
- <span class="comment">(*&nbsp;Lstore&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> <span class="id">a</span>',<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">eval_addressing</span> <span class="id">ge</span> (<span class="id">Vptr</span> <span class="id">sp</span>' <span class="id">Ptrofs.zero</span>) (<span class="id">transl_addr</span> (<span class="id">make_env</span> (<span class="id">function_bounds</span> <span class="id">f</span>)) <span class="id">addr</span>) <span class="id">rs0</span>##<span class="id">args</span> = <span class="id">Some</span> <span class="id">a</span>'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id">Val.inject</span> <span class="id">j</span> <span class="id">a</span> <span class="id">a</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_addressing_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">globalenv_inject_preserves_globals</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">agree_reglist</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">a</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap3</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">storev_parallel_rule</span>. <span class="id">eexact</span> <span class="id">SEP</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">AGREGS</span>. <br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">m1</span>' &amp; <span class="id">C</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap3</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="id">instantiate</span> (1 := <span class="id">a</span>'). <span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">eval_addressing_preserved</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">C</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">transl_destroyed_by_store</span>. <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_store_caller_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">frame_undef_regs</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">bf</span> [<span class="id">tf</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">is_tail_transf_function</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> <span class="id">IST</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">transl_code_eq</span> <span class="kwd">in</span> <span class="id">IST</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">IST</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">return_address_offset_exists</span>. <span class="id">eexact</span> <span class="id">IST</span>. <span class="tactic">intros</span> [<span class="id">ra</span> <span class="id">D</span>].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Val.Vptr_has_type</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Zle_trans</span> <span class="kwd">with</span> (<span class="id">size_arguments</span> (<span class="id">Linear.funsig</span> <span class="id">f</span>')); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">loc_arguments_bounded</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">sep_assoc</span>. <span class="tactic">exact</span> <span class="id">SEP</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Ltailcall&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sep_swap</span> (<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">s</span> <span class="id">cs</span>')) <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_epilogue_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>. <span class="tactic">intros</span> (<span class="id">rs1</span> &amp; <span class="id">m1</span>' &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span> &amp; <span class="id">S</span> &amp; <span class="id">T</span> &amp; <span class="id">U</span> &amp; <span class="id">SEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">find_function_translated</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="tactic">eapply</span> <span class="id">sep_proj2</span>. <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">bf</span> [<span class="id">tf</span>' [<span class="id">A</span> [<span class="id">B</span> <span class="id">C</span>]]]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">S</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">match_stacks_change_sig</span> <span class="kwd">with</span> (<span class="id">Linear.fn_sig</span> <span class="id">f</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">zero_size_arguments_tailcall_possible</span>. <span class="tactic">eapply</span> <span class="id">wt_state_tailcall</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lbuiltin&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">BOUND</span> <span class="kwd">as</span> [<span class="id">BND1</span> <span class="id">BND2</span>].<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_builtin_args_correct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">apply</span> <span class="id">sep_proj2</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="id">eexact</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eauto</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">forallb_forall</span>. <span class="tactic">eapply</span> <span class="id">wt_state_builtin</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">BND2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">vargs</span>' [<span class="id">P</span> <span class="id">Q</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>, <span class="id">sep_comm</span>, <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_parallel_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>; <span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">res</span>' &amp; <span class="id">m1</span>' &amp; <span class="id">EC</span> &amp; <span class="id">RES</span> &amp; <span class="id">SEP</span> &amp; <span class="id">INCR</span> &amp; <span class="id">ISEP</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">sep_assoc</span>, <span class="id">sep_comm</span>, <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_builtin_args_preserved</span> <span class="kwd">with</span> (<span class="id">ge1</span> := <span class="id">ge</span>); <span class="tactic">eauto</span>. <span class="tactic">exact</span> <span class="id">symbols_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_intro</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>'); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_change_meminj</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_res</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">agree_regs_inject_incr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_set_res</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">agree_locs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_set_res</span>. <span class="tactic">apply</span> <span class="id">frame_undef_regs</span>. <span class="tactic">apply</span> <span class="id">frame_contents_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap2</span>. <span class="tactic">apply</span> <span class="id">stack_contents_change_meminj</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">SEP</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Llabel&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>; <span class="tactic">apply</span> <span class="id">exec_Mlabel</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lgoto&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>; <span class="tactic">eapply</span> <span class="id">exec_Mgoto</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_label_tail</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lcond,&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Mcond_true</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_condition_inject</span> <span class="kwd">with</span> (<span class="id">m1</span> := <span class="id">m</span>). <span class="tactic">eapply</span> <span class="id">agree_reglist</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sep_pick3</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">exact</span> <span class="id">SEP</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_cond_caller_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">find_label_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_undef_regs</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lcond,&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_Mcond_false</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">eval_condition_inject</span> <span class="kwd">with</span> (<span class="id">m1</span> := <span class="id">m</span>). <span class="tactic">eapply</span> <span class="id">agree_reglist</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sep_pick3</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">exact</span> <span class="id">SEP</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_cond_caller_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_undef_regs</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Ljumptable&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">rs0</span> <span class="id">arg</span> = <span class="id">Vint</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">generalize</span> (<span class="id">AGREGS</span> <span class="id">arg</span>). <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">intro</span> <span class="id">IJ</span>; <span class="id">inv</span> <span class="id">IJ</span>; <span class="tactic">auto</span>. }<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>; <span class="tactic">eapply</span> <span class="id">exec_Mjumptable</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transl_find_label</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_undef_regs</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_undef_locs</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">destroyed_by_jumptable_caller_save</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">find_label_tail</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_undef_regs</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;Lreturn&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sep_swap</span> (<span class="id">stack_contents</span> <span class="id">j</span> <span class="id">s</span> <span class="id">cs</span>')) <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_epilogue_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">rs</span>' &amp; <span class="id">m1</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_right</span>. <span class="id">eexact</span> <span class="id">D</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span>; <span class="tactic">exact</span> <span class="id">G</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;internal&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">revert</span> <span class="id">TRANSL</span>. <span class="tactic">unfold</span> <span class="id">transf_fundef</span>, <span class="id">transf_partial_fundef</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">transf_function</span> <span class="id">f</span>) <span class="kwd">as</span> [<span class="id">tfn</span>|] <span class="id">eqn</span>:<span class="id">TRANSL</span>; <span class="tactic">simpl</span>; <span class="tactic">try</span> <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">EQ</span>; <span class="tactic">inversion</span> <span class="id">EQ</span>; <span class="tactic">clear</span> <span class="id">EQ</span>; <span class="tactic">subst</span> <span class="id">tf</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_comm</span>, <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>. <br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_prologue_correct</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">eapply</span> <span class="id">wt_callstate_wt_regs</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_type_sp</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_type_retaddr</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">SEP</span>;<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">rs</span>' &amp; <span class="id">m2</span>' &amp; <span class="id">sp</span>' &amp; <span class="id">m3</span>' &amp; <span class="id">m4</span>' &amp; <span class="id">m5</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span> &amp; <span class="id">F</span> &amp; <span class="id">SEP</span> &amp; <span class="id">J</span> &amp; <span class="id">K</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sep_comm</span> (<span class="id">globalenv_inject</span> <span class="id">ge</span> <span class="id">j</span>')) <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">sep_swap</span> (<span class="id">minjection</span> <span class="id">j</span>' <span class="id">m</span>')) <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">plus_left</span>. <span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">unfold_transf_function</span> <span class="id">_</span> <span class="id">_</span> <span class="id">TRANSL</span>). <span class="tactic">unfold</span> <span class="id">fn_code</span>. <span class="tactic">unfold</span> <span class="id">transl_body</span>.<br/>
&nbsp;&nbsp;<span class="id">eexact</span> <span class="id">D</span>. <span class="id">traceEq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_intro</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>'); <span class="tactic">eauto</span> <span class="kwd">with</span> <span class="id">coqlib</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_change_meminj</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_swap</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> <span class="id">sep_swap</span>. <span class="tactic">eapply</span> <span class="id">stack_contents_change_meminj</span>; <span class="tactic">eauto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;external&nbsp;function&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">TRANSL</span>. <span class="tactic">inversion</span> <span class="id">TRANSL</span>; <span class="tactic">subst</span> <span class="id">tf</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transl_external_arguments</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">sep_proj1</span> <span class="kwd">in</span> <span class="id">SEP</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">vl</span> [<span class="id">ARGS</span> <span class="id">VINJ</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_comm</span>, <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">external_call_parallel_rule</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> (<span class="id">j</span>' &amp; <span class="id">res</span>' &amp; <span class="id">m1</span>' &amp; <span class="id">A</span> &amp; <span class="id">B</span> &amp; <span class="id">C</span> &amp; <span class="id">D</span> &amp; <span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">eapply</span> <span class="id">exec_function_external</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">external_call_symbols_preserved</span>; <span class="tactic">eauto</span>. <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_return</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_stacks_change_meminj</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_regs_set_pair</span>. <span class="tactic">apply</span> <span class="id">agree_regs_inject_incr</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_callee_save_set_result</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">stack_contents_change_meminj</span> <span class="kwd">with</span> <span class="id">j</span>; <span class="tactic">auto</span>. <br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">sep_comm</span>, <span class="id">sep_assoc</span>; <span class="tactic">auto</span>.<br/>
<br/>
- <span class="comment">(*&nbsp;return&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">inv</span> <span class="id">STACKS</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">AGLOCS</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">SEP</span>. <span class="tactic">rewrite</span> <span class="id">sep_assoc</span> <span class="kwd">in</span> <span class="id">SEP</span>. <br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">plus_one</span>. <span class="tactic">apply</span> <span class="id">exec_return</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">agree_locs_return</span> <span class="kwd">with</span> <span class="id">rs0</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">frame_contents_exten</span> <span class="kwd">with</span> <span class="id">rs0</span> (<span class="id">parent_locset</span> <span class="id">s</span>); <span class="tactic">auto</span>. <br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_initial_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span>, <span class="id">Linear.initial_state</span> <span class="id">prog</span> <span class="id">st1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>, <span class="id">Mach.initial_state</span> <span class="id">tprog</span> <span class="id">st2</span> /\ <span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3809')">Proof.</div>
<div class="proofscript" id="proof3809">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">function_ptr_translated</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">tf</span> [<span class="id">FIND</span> <span class="id">TR</span>]].<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> (<span class="id">Genv.init_mem_transf_partial</span> <span class="id">TRANSF</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">match_program_main</span> <span class="id">TRANSF</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">symbols_preserved</span>. <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">j</span> := <span class="id">Mem.flat_inj</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">match_states_call</span> <span class="kwd">with</span> (<span class="id">j</span> := <span class="id">j</span>); <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H3</span>, <span class="id">loc_arguments_main</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">sep_pure</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">split</span>;[|<span class="tactic">split</span>].<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">Genv.initmem_inject</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">exists</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>); <span class="tactic">split</span>. <span class="tactic">apply</span> <span class="id">Ple_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">j</span>, <span class="id">Mem.flat_inj</span>; <span class="id">constructor</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pred_dec_true</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">plt</span> <span class="id">b1</span> (<span class="id">Mem.nextblock</span> <span class="id">m0</span>)); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m0</span> <span class="id">b0</span>). <span class="tactic">eapply</span> <span class="id">Genv.find_symbol_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m0</span> <span class="id">b0</span>). <span class="tactic">eapply</span> <span class="id">Genv.find_funct_ptr_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> (<span class="id">Mem.valid_block</span> <span class="id">m0</span> <span class="id">b0</span>). <span class="tactic">eapply</span> <span class="id">Genv.find_var_info_not_fresh</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transf_final_states</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st1</span> <span class="id">st2</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="id">match_states</span> <span class="id">st1</span> <span class="id">st2</span> -&gt; <span class="id">Linear.final_state</span> <span class="id">st1</span> <span class="id">r</span> -&gt; <span class="id">Mach.final_state</span> <span class="id">st2</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3810')">Proof.</div>
<div class="proofscript" id="proof3810">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">inv</span> <span class="id">H0</span>. <span class="id">inv</span> <span class="id">H</span>. <span class="id">inv</span> <span class="id">STACKS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">R</span>: <span class="id">exists</span> <span class="id">r</span>, <span class="id">loc_result</span> <span class="id">signature_main</span> = <span class="id">One</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;{ <span class="tactic">destruct</span> (<span class="id">loc_result</span> <span class="id">signature_main</span>) <span class="kwd">as</span> [<span class="id">r1</span> | <span class="id">r1</span> <span class="id">r2</span>] <span class="id">eqn</span>:<span class="id">LR</span>.<br/>
&nbsp;&nbsp;- <span class="id">exists</span> <span class="id">r1</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">generalize</span> (<span class="id">loc_result_type</span> <span class="id">signature_main</span>). <span class="tactic">rewrite</span> <span class="id">LR</span>. <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">R</span> <span class="kwd">as</span> [<span class="id">rres</span> <span class="id">EQ</span>]. <span class="tactic">rewrite</span> <span class="id">EQ</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">AGREGS</span> <span class="id">rres</span>). <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">intros</span> <span class="id">A</span>; <span class="id">inv</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="id">econstructor</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">wt_prog</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">i</span> <span class="id">fd</span>, <span class="id">In</span> (<span class="id">i</span>, <span class="id">Gfun</span> <span class="id">fd</span>) <span class="id">prog</span>.(<span class="id">prog_defs</span>) -&gt; <span class="id">wt_fundef</span> <span class="id">fd</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3811')">Proof.</div>
<div class="proofscript" id="proof3811">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">list_forall2_in_left</span>. <span class="id">eexact</span> (<span class="id">proj1</span> <span class="id">TRANSF</span>). <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> ([<span class="id">i</span>' <span class="id">g</span>] &amp; <span class="id">P</span> &amp; <span class="id">Q</span> &amp; <span class="id">R</span>). <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="id">inv</span> <span class="id">R</span>. <span class="tactic">destruct</span> <span class="id">fd</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
- <span class="id">monadInv</span> <span class="id">H2</span>. <span class="tactic">unfold</span> <span class="id">transf_function</span> <span class="kwd">in</span> <span class="id">EQ</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">wt_function</span> <span class="id">f</span>). <span class="tactic">auto</span>. <span class="tactic">discriminate</span>.<br/>
- <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transf_program_correct</span>:<br/>
&nbsp;&nbsp;<span class="id">forward_simulation</span> (<span class="id">Linear.semantics</span> <span class="id">prog</span>) (<span class="id">Mach.semantics</span> <span class="id">return_address_offset</span> <span class="id">tprog</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3812')">Proof.</div>
<div class="proofscript" id="proof3812">
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">ms</span> := <span class="kwd">fun</span> <span class="id">s</span> <span class="id">s</span>' =&gt; <span class="id">wt_state</span> <span class="id">s</span> /\ <span class="id">match_states</span> <span class="id">s</span> <span class="id">s</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">forward_simulation_plus</span> <span class="kwd">with</span> (<span class="id">match_states</span> := <span class="id">ms</span>).<br/>
- <span class="tactic">apply</span> <span class="id">senv_preserved</span>.<br/>
- <span class="tactic">intros</span>. <span class="id">exploit</span> <span class="id">transf_initial_states</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">st2</span> [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">st2</span>; <span class="tactic">split</span>; <span class="tactic">auto</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wt_initial_state</span> <span class="kwd">with</span> (<span class="id">prog</span> := <span class="id">prog</span>); <span class="tactic">auto</span>. <span class="tactic">exact</span> <span class="id">wt_prog</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">eapply</span> <span class="id">transf_final_states</span>; <span class="tactic">eauto</span>.<br/>
- <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">exploit</span> <span class="id">transf_step_correct</span>; <span class="tactic">eauto</span>. <span class="tactic">intros</span> [<span class="id">s2</span>' [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">s2</span>'; <span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">A</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">step_type_preservation</span>; <span class="tactic">eauto</span>. <span class="id">eexact</span> <span class="id">wt_prog</span>. <span class="id">eexact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PRESERVATION</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
