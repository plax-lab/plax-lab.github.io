<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module Parmov</title>
<meta name="description" content="Documentation of Coq module Parmov" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module Parmov</h1>
<div class="coq">
<br/>
<div class="doc">Translation of parallel moves into sequences of individual moves </div>
<br/>
<div class="doc">The ``parallel move'' problem, also known as ``parallel assignment'',
  is the following.  We are given a list of (source, destination) pairs
  of locations.  The goal is to find a sequence of elementary
  moves (<span class="bracket"><span class="id">loc</span> &lt;- <span class="id">loc</span></span> assignments) such that, at the end of the sequence,
  location <span class="bracket"><span class="id">dst</span></span> contains the value of location <span class="bracket"><span class="id">src</span></span> at the beginning of
  the sequence, for each (<span class="bracket"><span class="id">src</span></span>, <span class="bracket"><span class="id">dst</span></span>) pairs in the given problem.
  Moreover, other locations should keep their values, except one register
  of each type, which can be used as temporaries in the generated sequences.
  The parallel move problem is trivial if the sources and destinations do
  not overlap.  For instance,
<pre>
  (R1, R2) &lt;- (R3, R4)     becomes    R1 &lt;- R3; R2 &lt;- R4</pre>
  However, arbitrary overlap is allowed between sources and destinations.
  This requires some care in ordering the individual moves, as in
<pre>
  (R1, R2) &lt;- (R3, R1)     becomes    R2 &lt;- R1; R1 &lt;- R3</pre>
  Worse, cycles (permutations) can require the use of temporaries, as in
<pre>
  (R1, R2, R3) &lt;- (R2, R3, R1)   becomes   T &lt;- R1; R1 &lt;- R2; R2 &lt;- R3; R3 &lt;- T;</pre>
  An amazing fact is that for any parallel move problem, at most one temporary
  (or in our case one integer temporary and one float temporary) is needed.
  The development in this section was designed by Laurence Rideau and
  Bernard Serpette.  It is described in the paper
  ``Tilting at windmills with Coq: Formal verification of
  a compilation algorithm for parallel moves'',
  <A HREF="http://hal.inria.fr/inria-00176007">
  http://hal.inria.fr/inria-00176007
  </A>
</div>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Relations</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Axioms</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coqlib</span>.<br/>
<span class="kwd">Require</span> <span class="id">Recdef</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">PARMOV</span>.<br/>
<br/>
<h1> Registers, moves, and their semantics </h1>
<br/>
<div class="doc">The development is parameterized by the type of registers,
    equipped with a decidable equality. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">reg</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Variable</span> <span class="id">reg_eq</span> : <span class="kwd">forall</span> (<span class="id">r1</span> <span class="id">r2</span>: <span class="id">reg</span>), {<span class="id">r1</span>=<span class="id">r2</span>} + {<span class="id">r1</span>&lt;&gt;<span class="id">r2</span>}.<br/>
<br/>
<div class="doc">The <span class="bracket"><span class="id">temp</span></span> function maps every register <span class="bracket"><span class="id">r</span></span> to the register that
    should be used to save the value of <span class="bracket"><span class="id">r</span></span> temporarily while performing
    a cyclic assignment involving <span class="bracket"><span class="id">r</span></span>.  In the simplest case, there is
    only one such temporary register <span class="bracket"><span class="id">rtemp</span></span> and <span class="bracket"><span class="id">temp</span></span> is the constant
    function <span class="bracket"><span class="kwd">fun</span> <span class="id">r</span> =&gt; <span class="id">rtemp</span></span>.  In more realistic cases, different temporary
    registers can be used to hold different values.  In the case of Compcert,
    we have two temporary registers, one for integer values and the other
    for floating-point values, and <span class="bracket"><span class="id">temp</span></span> returns the appropriate temporary
    depending on the type of its argument. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">temp</span>: <span class="id">reg</span> -&gt; <span class="id">reg</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">is_temp</span> (<span class="id">r</span>: <span class="id">reg</span>): <span class="kwd">Prop</span> := <span class="id">exists</span> <span class="id">s</span>, <span class="id">r</span> = <span class="id">temp</span> <span class="id">s</span>.<br/>
<br/>
<div class="doc">A set of moves is a list of pairs of registers, of the form
    (source, destination). </div>
<br/>
<span class="kwd">Definition</span> <span class="id">moves</span> := (<span class="id">list</span> (<span class="id">reg</span> * <span class="id">reg</span>))%<span class="id">type</span>.  <br/>
<br/>
<span class="kwd">Definition</span> <span class="id">srcs</span> (<span class="id">m</span>: <span class="id">moves</span>) := <span class="id">List.map</span> (@<span class="id">fst</span> <span class="id">reg</span> <span class="id">reg</span>) <span class="id">m</span>.<br/>
<span class="kwd">Definition</span> <span class="id">dests</span> (<span class="id">m</span>: <span class="id">moves</span>) := <span class="id">List.map</span> (@<span class="id">snd</span> <span class="id">reg</span> <span class="id">reg</span>) <span class="id">m</span>.<br/>
<br/>
<h2> Semantics of moves </h2>
<br/>
<div class="doc">The dynamic  semantics of moves is given in terms of environments.
    An environment is a mapping of registers to their current values. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">val</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Definition</span> <span class="id">env</span> := <span class="id">reg</span> -&gt; <span class="id">val</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">env_ext</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">e1</span> <span class="id">e2</span>: <span class="id">env</span>),<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">e1</span> <span class="id">r</span> = <span class="id">e2</span> <span class="id">r</span>) -&gt; <span class="id">e1</span> = <span class="id">e2</span>.<br/>
<span class="kwd">Proof</span> (@<span class="tactic">extensionality</span> <span class="id">reg</span> <span class="id">val</span>).<br/>
<br/>
<div class="doc">The main operation over environments is update: it assigns
  a value <span class="bracket"><span class="id">v</span></span> to a register <span class="bracket"><span class="id">r</span></span> and preserves the values of other
  registers. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">update</span> (<span class="id">r</span>: <span class="id">reg</span>) (<span class="id">v</span>: <span class="id">val</span>) (<span class="id">e</span>: <span class="id">env</span>) : <span class="id">env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">r</span>' =&gt; <span class="kwd">if</span> <span class="id">reg_eq</span> <span class="id">r</span>' <span class="id">r</span> <span class="kwd">then</span> <span class="id">v</span> <span class="kwd">else</span> <span class="id">e</span> <span class="id">r</span>'.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_s</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span>, <span class="id">update</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r</span> = <span class="id">v</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof944')">Proof.</div>
<div class="proofscript" id="proof944">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">update</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span> <span class="id">r</span>). <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_o</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r</span>', <span class="id">r</span>' &lt;&gt; <span class="id">r</span> -&gt; <span class="id">update</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r</span>' =  <span class="id">e</span> <span class="id">r</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof945')">Proof.</div>
<div class="proofscript" id="proof945">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">update</span>; <span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span>' <span class="id">r</span>). <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_ident</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">e</span>, <span class="id">update</span> <span class="id">r</span> (<span class="id">e</span> <span class="id">r</span>) <span class="id">e</span> = <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof946')">Proof.</div>
<div class="proofscript" id="proof946">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">env_ext</span>; <span class="tactic">intro</span>. <span class="tactic">unfold</span> <span class="id">update</span>. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_commut</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">v1</span> <span class="id">r2</span> <span class="id">v2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">r1</span> &lt;&gt; <span class="id">r2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">update</span> <span class="id">r1</span> <span class="id">v1</span> (<span class="id">update</span> <span class="id">r2</span> <span class="id">v2</span> <span class="id">e</span>) = <span class="id">update</span> <span class="id">r2</span> <span class="id">v2</span> (<span class="id">update</span> <span class="id">r1</span> <span class="id">v1</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof947')">Proof.</div>
<div class="proofscript" id="proof947">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">env_ext</span>; <span class="tactic">intro</span>; <span class="tactic">unfold</span> <span class="id">update</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span> <span class="id">r1</span>); <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span> <span class="id">r2</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">update_twice</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">update</span> <span class="id">r</span> <span class="id">v</span> (<span class="id">update</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span>) = <span class="id">update</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof948')">Proof.</div>
<div class="proofscript" id="proof948">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">env_ext</span>; <span class="tactic">intro</span>; <span class="tactic">unfold</span> <span class="id">update</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r0</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">A list of moves <span class="bracket">(<span class="id">src1</span>, <span class="id">dst1</span>), ..., (<span class="id">srcN</span>, <span class="id">dstN</span>)</span> can be given
  three different semantics, as environment transformers.
  The first semantics corresponds to a parallel assignment:
  <span class="bracket"><span class="id">dst1</span>, ..., <span class="id">dstN</span></span> are set to the initial values of <span class="bracket"><span class="id">src1</span>, ..., <span class="id">srcN</span></span>. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">exec_par</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">e</span>: <span class="id">env</span>) {<span class="kwd">struct</span> <span class="id">m</span>}: <span class="id">env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">e</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>' =&gt; <span class="id">update</span> <span class="id">d</span> (<span class="id">e</span> <span class="id">s</span>) (<span class="id">exec_par</span> <span class="id">m</span>' <span class="id">e</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The second semantics corresponds to a sequence of individual
  assignments: first, <span class="bracket"><span class="id">dst1</span></span> is set to the initial value of <span class="bracket"><span class="id">src1</span></span>;
  then, <span class="bracket"><span class="id">dst2</span></span> is set to the current value of <span class="bracket"><span class="id">src2</span></span> after the first
  assignment; etc. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">exec_seq</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">e</span>: <span class="id">env</span>) {<span class="kwd">struct</span> <span class="id">m</span>}: <span class="id">env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">e</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>' =&gt; <span class="id">exec_seq</span> <span class="id">m</span>' (<span class="id">update</span> <span class="id">d</span> (<span class="id">e</span> <span class="id">s</span>) <span class="id">e</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">The third semantics is also sequential, but executes the moves
  in reverse order, starting with <span class="bracket"><span class="id">srcN</span>, <span class="id">dstN</span></span> and finishing with
  <span class="bracket"><span class="id">src1</span>, <span class="id">dst1</span></span>. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">exec_seq_rev</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">e</span>: <span class="id">env</span>) {<span class="kwd">struct</span> <span class="id">m</span>}: <span class="id">env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">e</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">e</span>' := <span class="id">exec_seq_rev</span> <span class="id">m</span>' <span class="id">e</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">update</span> <span class="id">d</span> (<span class="id">e</span>' <span class="id">s</span>) <span class="id">e</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<h1> Specification of the non-deterministic algorithm </h1>
<br/>
<div class="doc">Rideau and Serpette's parallel move compilation algorithm is first
   specified as a non-deterministic set of rewriting rules operating
   over triples <span class="bracket">(<span class="id">mu</span>, <span class="id">sigma</span>, <span class="id">tau</span>)</span> of moves.  We define these rules
   as an inductive predicate <span class="bracket"><span class="id">transition</span></span> relating triples of moves,
   and its reflexive transitive closure <span class="bracket"><span class="id">transitions</span></span>. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">state</span>: <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id">State</span> (<span class="id">mu</span>: <span class="id">moves</span>) (<span class="id">sigma</span>: <span class="id">moves</span>) (<span class="id">tau</span>: <span class="id">moves</span>) : <span class="id">state</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">no_read</span> (<span class="id">mu</span>: <span class="id">moves</span>) (<span class="id">d</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">d</span> (<span class="id">srcs</span> <span class="id">mu</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">transition</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">tr_nop</span>: <span class="kwd">forall</span> <span class="id">mu1</span> <span class="id">r</span> <span class="id">mu2</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> (<span class="id">mu1</span> ++ (<span class="id">r</span>, <span class="id">r</span>) :: <span class="id">mu2</span>) <span class="id">sigma</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> (<span class="id">mu1</span> ++ <span class="id">mu2</span>) <span class="id">sigma</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">tr_start</span>: <span class="kwd">forall</span> <span class="id">mu1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">mu2</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> (<span class="id">mu1</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">mu2</span>) <span class="id">nil</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> (<span class="id">mu1</span> ++ <span class="id">mu2</span>) ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">tr_push</span>: <span class="kwd">forall</span> <span class="id">mu1</span> <span class="id">d</span> <span class="id">r</span> <span class="id">mu2</span> <span class="id">s</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> (<span class="id">mu1</span> ++ (<span class="id">d</span>, <span class="id">r</span>) :: <span class="id">mu2</span>) ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">sigma</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> (<span class="id">mu1</span> ++ <span class="id">mu2</span>) ((<span class="id">d</span>, <span class="id">r</span>) :: (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">sigma</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">tr_loop</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">s</span> <span class="id">d</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> <span class="id">mu</span> (<span class="id">sigma</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> (<span class="id">sigma</span> ++ (<span class="id">temp</span> <span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) ((<span class="id">s</span>, <span class="id">temp</span> <span class="id">s</span>) :: <span class="id">tau</span>))<br/>
&nbsp;&nbsp;| <span class="id">tr_pop</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s0</span> <span class="id">d0</span> <span class="id">s1</span> <span class="id">d1</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu</span> <span class="id">d1</span> -&gt; <span class="id">d1</span> &lt;&gt; <span class="id">s0</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">tau</span>))<br/>
&nbsp;&nbsp;| <span class="id">tr_last</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">transition</span> (<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">tau</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">transitions</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">clos_refl_trans</span> <span class="id">state</span> <span class="id">transition</span>.<br/>
<br/>
<h2> Well-formedness properties of states </h2>
<br/>
<div class="doc">A state <span class="bracket"><span class="id">mu</span>, <span class="id">sigma</span>, <span class="id">tau</span></span> is well-formed if the following properties hold:
<ul>
<li>
 <span class="bracket"><span class="id">mu</span></span> concatenated with <span class="bracket"><span class="id">sigma</span></span> is a ``mill'', that is, no destination
  appears twice (predicate <span class="bracket"><span class="id">is_mill</span></span> below).
</li>
<li>
 No temporary register appears in <span class="bracket"><span class="id">mu</span></span> (predicate <span class="bracket"><span class="id">move_no_temp</span></span>).
</li>
<li>
 No temporary register appears in <span class="bracket"><span class="id">sigma</span></span> except perhaps as the source
  of the last move in <span class="bracket"><span class="id">sigma</span></span> (predicate <span class="bracket"><span class="id">temp_last</span></span>).
</li>
<li>
 <span class="bracket"><span class="id">sigma</span></span> is a ``path'', that is, the source of a move is the destination
  of the following move.
</li>
</ul>
</div>
<br/>
<span class="kwd">Definition</span> <span class="id">is_mill</span> (<span class="id">m</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> (<span class="id">dests</span> <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">is_not_temp</span> (<span class="id">r</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d</span>, <span class="id">r</span> &lt;&gt; <span class="id">temp</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">move_no_temp</span> (<span class="id">m</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">m</span> -&gt; <span class="id">is_not_temp</span> <span class="id">s</span> /\ <span class="id">is_not_temp</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">temp_last</span> (<span class="id">m</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">List.rev</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>' =&gt; <span class="id">is_not_temp</span> <span class="id">d</span> /\ <span class="id">move_no_temp</span> <span class="id">m</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">is_first_dest</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">d</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">True</span><br/>
&nbsp;&nbsp;| (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">_</span> =&gt; <span class="id">d</span> = <span class="id">d0</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">is_path</span>: <span class="id">moves</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">is_path_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_path</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">is_path_cons</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_first_dest</span> <span class="id">m</span> <span class="id">s</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_path</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_path</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>).<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">state_wf</span>: <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">state_wf_intro</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_mill</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">temp_last</span> <span class="id">sigma</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_path</span> <span class="id">sigma</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">state_wf</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span>).<br/>
<br/>
<div class="doc">Some trivial properties of srcs and dests. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>, <span class="id">dests</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) = <span class="id">dests</span> <span class="id">m1</span> ++ <span class="id">dests</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof949')">Proof.</div>
<div class="proofscript" id="proof949">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">dests</span>. <span class="tactic">apply</span> <span class="id">map_app</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_decomp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m2</span>, <span class="id">dests</span> (<span class="id">m1</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m2</span>) = <span class="id">dests</span> <span class="id">m1</span> ++ <span class="id">d</span> :: <span class="id">dests</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof950')">Proof.</div>
<div class="proofscript" id="proof950">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">dests</span>. <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">srcs_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>, <span class="id">srcs</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) = <span class="id">srcs</span> <span class="id">m1</span> ++ <span class="id">srcs</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof951')">Proof.</div>
<div class="proofscript" id="proof951">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">srcs</span>. <span class="tactic">apply</span> <span class="id">map_app</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">srcs_decomp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m2</span>, <span class="id">srcs</span> (<span class="id">m1</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m2</span>) = <span class="id">srcs</span> <span class="id">m1</span> ++ <span class="id">s</span> :: <span class="id">srcs</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof952')">Proof.</div>
<div class="proofscript" id="proof952">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">srcs</span>. <span class="tactic">rewrite</span> <span class="id">map_app</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">srcs_dests_combine</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">s</span> = <span class="id">List.length</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">srcs</span> (<span class="id">List.combine</span> <span class="id">s</span> <span class="id">d</span>) = <span class="id">s</span> /\<br/>
&nbsp;&nbsp;<span class="id">dests</span> (<span class="id">List.combine</span> <span class="id">s</span> <span class="id">d</span>) = <span class="id">d</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof953')">Proof.</div>
<div class="proofscript" id="proof953">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">s</span>; <span class="tactic">destruct</span> <span class="id">d</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">IHs</span> <span class="id">d</span>); <span class="tactic">intros</span>. <span class="tactic">split</span>; <span class="tactic">congruence</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Some properties of <span class="bracket"><span class="id">is_mill</span></span> and <span class="bracket"><span class="id">dests_disjoint</span></span>. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">dests_disjoint</span> (<span class="id">m1</span> <span class="id">m2</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">list_disjoint</span> (<span class="id">dests</span> <span class="id">m1</span>) (<span class="id">dests</span> <span class="id">m2</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_disjoint_sym</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m2</span> &lt;-&gt; <span class="id">dests_disjoint</span> <span class="id">m2</span> <span class="id">m1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof954')">Proof.</div>
<div class="proofscript" id="proof954">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dests_disjoint</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">list_disjoint_sym</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_disjoint_cons_left</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m1</span>) <span class="id">m2</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m2</span> /\ ~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof955')">Proof.</div>
<div class="proofscript" id="proof955">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dests_disjoint</span>, <span class="id">list_disjoint</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">firstorder</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">elim</span> <span class="id">H0</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intro</span>; <span class="tactic">subst</span>. <span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_disjoint_cons_right</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m2</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m2</span> /\ ~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m1</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof956')">Proof.</div>
<div class="proofscript" id="proof956">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">dests_disjoint_sym</span>. <span class="tactic">rewrite</span> <span class="id">dests_disjoint_cons_left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dests_disjoint_sym</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_disjoint_append_left</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">m3</span>,<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">m3</span> &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m3</span> /\ <span class="id">dests_disjoint</span> <span class="id">m2</span> <span class="id">m3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof957')">Proof.</div>
<div class="proofscript" id="proof957">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dests_disjoint</span>, <span class="id">list_disjoint</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">split</span>; <span class="tactic">intros</span>. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">dests_append</span>. <span class="tactic">apply</span> <span class="id">in_or_app</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">eauto</span>. <span class="tactic">rewrite</span> <span class="id">dests_append</span>. <span class="tactic">apply</span> <span class="id">in_or_app</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dests_append</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">elim</span> (<span class="id">in_app_or</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dests_disjoint_append_right</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">m3</span>,<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> (<span class="id">m2</span> ++ <span class="id">m3</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m2</span> /\ <span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof958')">Proof.</div>
<div class="proofscript" id="proof958">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">dests_disjoint_sym</span>. <span class="tactic">rewrite</span> <span class="id">dests_disjoint_append_left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>; <span class="tactic">rewrite</span> <span class="id">dests_disjoint_sym</span>; <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_mill_cons</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">m</span> /\ ~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof959')">Proof.</div>
<div class="proofscript" id="proof959">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_mill</span>, <span class="id">dests_disjoint</span>; <span class="tactic">intros</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_mill_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) &lt;-&gt;<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">m1</span> /\ <span class="id">is_mill</span> <span class="id">m2</span> /\ <span class="id">dests_disjoint</span> <span class="id">m1</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof960')">Proof.</div>
<div class="proofscript" id="proof960">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_mill</span>, <span class="id">dests_disjoint</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">dests_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_norepet_app</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Some properties of <span class="bracket"><span class="id">move_no_temp</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">move_no_temp_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">m1</span> -&gt; <span class="id">move_no_temp</span> <span class="id">m2</span> -&gt; <span class="id">move_no_temp</span> (<span class="id">m1</span> ++ <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof961')">Proof.</div>
<div class="proofscript" id="proof961">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> (<span class="id">in_app_or</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span>); <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">H0</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">move_no_temp_rev</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span>, <span class="id">move_no_temp</span> (<span class="id">List.rev</span> <span class="id">m</span>) -&gt; <span class="id">move_no_temp</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof962')">Proof.</div>
<div class="proofscript" id="proof962">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">List.In_rev</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Some properties of <span class="bracket"><span class="id">temp_last</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">temp_last_change_last_source</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">s</span>' <span class="id">sigma</span>,<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> (<span class="id">sigma</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> (<span class="id">sigma</span> ++ (<span class="id">s</span>', <span class="id">d</span>) :: <span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof963')">Proof.</div>
<div class="proofscript" id="proof963">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">sigma</span>. <span class="tactic">unfold</span> <span class="id">temp_last</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">rev_unit</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">temp_last_push</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">d1</span> <span class="id">s2</span> <span class="id">d2</span> <span class="id">sigma</span>,<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> ((<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">sigma</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_not_temp</span> <span class="id">s1</span> -&gt; <span class="id">is_not_temp</span> <span class="id">d1</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> ((<span class="id">s1</span>, <span class="id">d1</span>) :: (<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">sigma</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof964')">Proof.</div>
<div class="proofscript" id="proof964">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">temp_last</span>; <span class="tactic">intros</span>. <span class="tactic">simpl</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">rev</span> <span class="id">sigma</span>); <span class="tactic">simpl</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>. <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H</span>; <span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H4</span>. <span class="tactic">subst</span>; <span class="tactic">tauto</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">p</span> <span class="kwd">as</span> [<span class="id">sN</span> <span class="id">dN</span>]. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">elim</span> (<span class="id">in_app_or</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H3</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H4</span>; <span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H5</span>; <span class="tactic">subst</span>; <span class="tactic">tauto</span>. <span class="tactic">elim</span> <span class="id">H5</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">temp_last_pop</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s1</span> <span class="id">d1</span> <span class="id">sigma</span> <span class="id">s2</span> <span class="id">d2</span>,<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">sigma</span> ++ (<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">temp_last</span> (<span class="id">sigma</span> ++ (<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof965')">Proof.</div>
<div class="proofscript" id="proof965">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">until</span> <span class="id">d2</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">sigma</span> ++ (<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> ((((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">nil</span>) ++ <span class="id">sigma</span>) ++ ((<span class="id">s2</span>, <span class="id">d2</span>) :: <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">temp_last</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">rev_unit</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_or_app</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Some properties of <span class="bracket"><span class="id">is_path</span></span>. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_path_pop</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">is_path</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>) -&gt; <span class="id">is_path</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof966')">Proof.</div>
<div class="proofscript" id="proof966">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_path_change_last_source</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">s</span>' <span class="id">d</span> <span class="id">sigma</span>,<br/>
&nbsp;&nbsp;<span class="id">is_path</span> (<span class="id">sigma</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_path</span> (<span class="id">sigma</span> ++ (<span class="id">s</span>', <span class="id">d</span>) :: <span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof967')">Proof.</div>
<div class="proofscript" id="proof967">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sigma</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>. <span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>; <span class="tactic">clear</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sigma</span> <span class="kwd">as</span> [ | [<span class="id">s1</span> <span class="id">d1</span>] <span class="id">sigma</span>']; <span class="tactic">simpl</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">path_sources_dests</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s0</span> <span class="id">d0</span> <span class="id">sigma</span>,<br/>
&nbsp;&nbsp;<span class="id">is_path</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">List.incl</span> (<span class="id">srcs</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">s0</span> :: <span class="id">dests</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof968')">Proof.</div>
<div class="proofscript" id="proof968">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sigma</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>; <span class="tactic">subst</span>; <span class="tactic">clear</span> <span class="id">H</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">In</span> <span class="id">s</span> (<span class="id">dests</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">sigma</span> <span class="kwd">as</span> [ | [<span class="id">s1</span> <span class="id">d1</span>] <span class="id">sigma</span>']; <span class="tactic">simpl</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H2</span>; <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">incl_cons</span>. <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">incl_tran</span> <span class="kwd">with</span> (<span class="id">s0</span> :: <span class="id">dests</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">IHsigma</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_read_path</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d1</span> <span class="id">sigma</span> <span class="id">s0</span> <span class="id">d0</span>,<br/>
&nbsp;&nbsp;<span class="id">d1</span> &lt;&gt; <span class="id">s0</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_path</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) -&gt;<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">d1</span> (<span class="id">dests</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id">no_read</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) <span class="id">d1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof969')">Proof.</div>
<div class="proofscript" id="proof969">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">path_sources_dests</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>). <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">elim</span> <span class="id">H1</span>. <span class="tactic">elim</span> (<span class="id">H2</span> <span class="id">_</span> <span class="id">H3</span>); <span class="tactic">intro</span>. <span class="tactic">congruence</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">To benefit from some proof automation, we populate a rewrite database
  with some of the properties above. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">notin_dests_cons</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">x</span> (<span class="id">dests</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>)) &lt;-&gt; <span class="id">x</span> &lt;&gt; <span class="id">d</span> /\ ~<span class="id">In</span> <span class="id">x</span> (<span class="id">dests</span> <span class="id">m</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof970')">Proof.</div>
<div class="proofscript" id="proof970">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">simpl</span>. <span class="tactic">intuition</span> <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">notin_dests_append</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> (<span class="id">m1</span> ++ <span class="id">m2</span>)) &lt;-&gt; ~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m1</span>) /\ ~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof971')">Proof.</div>
<div class="proofscript" id="proof971">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">dests_append</span>. <span class="tactic">rewrite</span> <span class="id">in_app</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">is_mill_cons</span> <span class="id">is_mill_append</span><br/>
&nbsp;&nbsp;<span class="id">dests_disjoint_cons_left</span> <span class="id">dests_disjoint_cons_right</span><br/>
&nbsp;&nbsp;<span class="id">dests_disjoint_append_left</span> <span class="id">dests_disjoint_append_right</span><br/>
&nbsp;&nbsp;<span class="id">notin_dests_cons</span> <span class="id">notin_dests_append</span>: <span class="id">pmov</span>.<br/>
<br/>
<h2> Transitions preserve well-formedness </h2>
<br/>
<span class="kwd">Lemma</span> <span class="id">transition_preserves_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">transition</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">state_wf</span> <span class="id">st</span> -&gt; <span class="id">state_wf</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof972')">Proof.</div>
<div class="proofscript" id="proof972">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intro</span> <span class="id">WF</span>; <span class="tactic">inversion</span> <span class="id">WF</span> <span class="kwd">as</span> [<span class="id">mu0</span> <span class="id">sigma0</span> <span class="id">tau0</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> <span class="id">D</span>];<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>;<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">A</span>; <span class="id">constructor</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>.<br/>
<br/>
&nbsp;Nop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">list_in_insert</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;Start&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">list_in_insert</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">simpl</span>. <span class="tactic">split</span>. <span class="tactic">elim</span> (<span class="id">B</span> <span class="id">s</span> <span class="id">d</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_or_app</span>. <span class="id">right</span>. <span class="tactic">apply</span> <span class="id">in_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">exact</span> <span class="id">I</span>. <span class="id">constructor</span>.<br/>
<br/>
&nbsp;Push&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">list_in_insert</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">B</span> <span class="id">d</span> <span class="id">r</span>). <span class="tactic">apply</span> <span class="id">temp_last_push</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_or_app</span>; <span class="id">right</span>; <span class="tactic">apply</span> <span class="id">in_eq</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;Loop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">temp_last_change_last_source</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_path_change_last_source</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Pop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">temp_last_pop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_path_pop</span>; <span class="tactic">eauto</span>.<br/>
<br/>
&nbsp;Last&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">temp_last</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transitions_preserve_wf</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>', <span class="id">transitions</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">state_wf</span> <span class="id">st</span> -&gt; <span class="id">state_wf</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof973')">Proof.</div>
<div class="proofscript" id="proof973">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transition_preserves_wf</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<h2> Transitions preserve semantics </h2>
<br/>
<div class="doc">We define the semantics of states as follows.
  For a triple <span class="bracket"><span class="id">mu</span>, <span class="id">sigma</span>, <span class="id">tau</span></span>, we perform the moves <span class="bracket"><span class="id">tau</span></span> in
  reverse sequential order, then the moves <span class="bracket"><span class="id">mu</span> ++ <span class="id">sigma</span></span> in parallel. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">statemove</span> (<span class="id">st</span>: <span class="id">state</span>) (<span class="id">e</span>: <span class="id">env</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span> =&gt; <span class="id">exec_par</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>) (<span class="id">exec_seq_rev</span> <span class="id">tau</span> <span class="id">e</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">In preparation to showing that transitions preserve semantics,
  we prove various properties of the parallel and sequential interpretations
  of moves. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_outside</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">e</span> <span class="id">r</span>, ~<span class="id">In</span> <span class="id">r</span> (<span class="id">dests</span> <span class="id">m</span>) -&gt; <span class="id">exec_par</span> <span class="id">m</span> <span class="id">e</span> <span class="id">r</span> = <span class="id">e</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof974')">Proof.</div>
<div class="proofscript" id="proof974">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">rewrite</span> <span class="id">update_o</span>. <span class="tactic">apply</span> <span class="id">IHm</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_lift</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m1</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_par</span> (<span class="id">m1</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m2</span>) <span class="id">e</span> = <span class="id">exec_par</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof975')">Proof.</div>
<div class="proofscript" id="proof975">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s0</span> <span class="id">d0</span>]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">IHm1</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">update_commut</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_ident</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">r</span> <span class="id">m2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> (<span class="id">m1</span> ++ (<span class="id">r</span>, <span class="id">r</span>) :: <span class="id">m2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_par</span> (<span class="id">m1</span> ++ (<span class="id">r</span>, <span class="id">r</span>) :: <span class="id">m2</span>) <span class="id">e</span> = <span class="id">exec_par</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof976')">Proof.</div>
<div class="proofscript" id="proof976">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">replace</span> (<span class="id">e</span> <span class="id">r</span>) <span class="kwd">with</span> (<span class="id">exec_par</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e</span> <span class="id">r</span>). <span class="tactic">apply</span> <span class="id">update_ident</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_par_outside</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_seq_app</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">exec_seq</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e</span> = <span class="id">exec_seq</span> <span class="id">m2</span> (<span class="id">exec_seq</span> <span class="id">m1</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof977')">Proof.</div>
<div class="proofscript" id="proof977">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">rewrite</span> <span class="id">IHm1</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_seq_rev_app</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">exec_seq_rev</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e</span> = <span class="id">exec_seq_rev</span> <span class="id">m1</span> (<span class="id">exec_seq_rev</span> <span class="id">m2</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof978')">Proof.</div>
<div class="proofscript" id="proof978">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">rewrite</span> <span class="id">IHm1</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_seq_exec_seq_rev</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">exec_seq_rev</span> <span class="id">m</span> <span class="id">e</span> = <span class="id">exec_seq</span> (<span class="id">List.rev</span> <span class="id">m</span>) <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof979')">Proof.</div>
<div class="proofscript" id="proof979">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">rewrite</span> <span class="id">exec_seq_app</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">IHm</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_seq_rev_exec_seq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">exec_seq</span> <span class="id">m</span> <span class="id">e</span> = <span class="id">exec_seq_rev</span> (<span class="id">List.rev</span> <span class="id">m</span>) <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof980')">Proof.</div>
<div class="proofscript" id="proof980">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">generalize</span> (<span class="id">exec_seq_exec_seq_rev</span> (<span class="id">List.rev</span> <span class="id">m</span>) <span class="id">e</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.rev_involutive</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_update_no_read</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">m</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_par</span> <span class="id">m</span> (<span class="id">update</span> <span class="id">d</span> (<span class="id">e</span> <span class="id">s</span>) <span class="id">e</span>) =<br/>
&nbsp;&nbsp;<span class="id">update</span> <span class="id">d</span> (<span class="id">e</span> <span class="id">s</span>) (<span class="id">exec_par</span> <span class="id">m</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof981')">Proof.</div>
<div class="proofscript" id="proof981">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_read</span>; <span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s0</span> <span class="id">d0</span>]; <span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">rewrite</span> <span class="id">IHm</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">update_commut</span>. <span class="tactic">f_equal</span>. <span class="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">update_o</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>. <span class="tactic">tauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_append_eq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span> <span class="id">m3</span> <span class="id">e2</span> <span class="id">e3</span>,<br/>
&nbsp;&nbsp;<span class="id">exec_par</span> <span class="id">m2</span> <span class="id">e2</span> = <span class="id">exec_par</span> <span class="id">m3</span> <span class="id">e3</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> (<span class="id">srcs</span> <span class="id">m1</span>) -&gt; <span class="id">e2</span> <span class="id">r</span> = <span class="id">e3</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">exec_par</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) <span class="id">e2</span> = <span class="id">exec_par</span> (<span class="id">m1</span> ++ <span class="id">m3</span>) <span class="id">e3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof982')">Proof.</div>
<div class="proofscript" id="proof982">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m1</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">f_equal</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_combine</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span> <span class="id">sl</span> <span class="id">dl</span>,<br/>
&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">sl</span> = <span class="id">List.length</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">e</span>' := <span class="id">exec_par</span> (<span class="id">combine</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">List.map</span> <span class="id">e</span>' <span class="id">dl</span> = <span class="id">List.map</span> <span class="id">e</span> <span class="id">sl</span> /\<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">l</span>, ~<span class="id">In</span> <span class="id">l</span> <span class="id">dl</span> -&gt; <span class="id">e</span>' <span class="id">l</span> = <span class="id">e</span> <span class="id">l</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof983')">Proof.</div>
<div class="proofscript" id="proof983">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">sl</span>; <span class="tactic">destruct</span> <span class="id">dl</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>; <span class="tactic">try</span> <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">subst</span>; <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">injection</span> <span class="id">H</span>; <span class="tactic">intro</span>; <span class="tactic">clear</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">IHsl</span> <span class="id">dl</span> <span class="id">H0</span> <span class="id">H4</span>) <span class="kwd">as</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e</span>' := <span class="id">exec_par</span> (<span class="id">combine</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="id">decEq</span>. <span class="tactic">apply</span> <span class="id">update_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">A</span>. <span class="tactic">apply</span> <span class="id">list_map_exten</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">update_o</span>. <span class="tactic">auto</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">update_o</span>. <span class="tactic">apply</span> <span class="id">B</span>. <span class="tactic">tauto</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<div class="doc"><span class="bracket"><span class="id">env_equiv</span></span> is an equivalence relation between environments
  capturing the fact that two environments assign the same values to
  non-temporary registers, but can disagree on the values of temporary
  registers. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">env_equiv</span> (<span class="id">e1</span> <span class="id">e2</span>: <span class="id">env</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">is_not_temp</span> <span class="id">r</span> -&gt; <span class="id">e1</span> <span class="id">r</span> = <span class="id">e2</span> <span class="id">r</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">env_equiv_refl</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">env_equiv</span> <span class="id">e</span> <span class="id">e</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof984')">Proof.</div>
<div class="proofscript" id="proof984">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">env_equiv</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">env_equiv_refl</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span>, <span class="id">e1</span> = <span class="id">e2</span> -&gt; <span class="id">env_equiv</span> <span class="id">e1</span> <span class="id">e2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof985')">Proof.</div>
<div class="proofscript" id="proof985">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">env_equiv</span>; <span class="tactic">intros</span>. <span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">env_equiv_sym</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span>, <span class="id">env_equiv</span> <span class="id">e1</span> <span class="id">e2</span> -&gt; <span class="id">env_equiv</span> <span class="id">e2</span> <span class="id">e1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof986')">Proof.</div>
<div class="proofscript" id="proof986">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">env_equiv</span>; <span class="tactic">intros</span>. <span class="tactic">symmetry</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">env_equiv_trans</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">e3</span>, <span class="id">env_equiv</span> <span class="id">e1</span> <span class="id">e2</span> -&gt; <span class="id">env_equiv</span> <span class="id">e2</span> <span class="id">e3</span> -&gt; <span class="id">env_equiv</span> <span class="id">e1</span> <span class="id">e3</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof987')">Proof.</div>
<div class="proofscript" id="proof987">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">env_equiv</span>; <span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">e2</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">exec_par_env_equiv</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">e1</span> <span class="id">e2</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">m</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_equiv</span> <span class="id">e1</span> <span class="id">e2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_equiv</span> (<span class="id">exec_par</span> <span class="id">m</span> <span class="id">e1</span>) (<span class="id">exec_par</span> <span class="id">m</span> <span class="id">e2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof988')">Proof.</div>
<div class="proofscript" id="proof988">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">move_no_temp</span>; <span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>].<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">update</span>. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span> <span class="id">d</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">elim</span> (<span class="id">H</span> <span class="id">s</span> <span class="id">d</span>); <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHm</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The proof that transitions preserve semantics (up to the values of
  temporary registers) follows. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transition_preserves_semantics</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>' <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">transition</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">state_wf</span> <span class="id">st</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_equiv</span> (<span class="id">statemove</span> <span class="id">st</span>' <span class="id">e</span>) (<span class="id">statemove</span> <span class="id">st</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof989')">Proof.</div>
<div class="proofscript" id="proof989">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intro</span> <span class="id">WF</span>; <span class="tactic">inversion</span> <span class="id">WF</span> <span class="kwd">as</span> [<span class="id">mu0</span> <span class="id">sigma0</span> <span class="id">tau0</span> <span class="id">A</span> <span class="id">B</span> <span class="id">C</span> <span class="id">D</span>]; <span class="tactic">subst</span>; <span class="tactic">simpl</span>.<br/>
<br/>
&nbsp;nop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>'. <span class="tactic">unfold</span> <span class="id">statemove</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">app_ass</span>. <span class="tactic">simpl</span>. <span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">exec_par_ident</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">app_ass</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="tactic">exact</span> <span class="id">A</span>.<br/>
<br/>
&nbsp;start&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>'. <span class="tactic">unfold</span> <span class="id">statemove</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">app_ass</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>. <span class="tactic">tauto</span>.<br/>
<br/>
&nbsp;push&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>'. <span class="tactic">unfold</span> <span class="id">statemove</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>. <span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">app_ass</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">update_commut</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">tauto</span>. <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>; <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>; <span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;loop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">statemove</span>. <span class="tactic">simpl</span> <span class="id">exec_seq_rev</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e1</span> := <span class="id">exec_seq_rev</span> <span class="id">tau</span> <span class="id">e</span>).<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">app_ass</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (~<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>))). <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> <span class="id">exec_par_lift</span>; <span class="tactic">auto</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">repeat</span> <span class="tactic">rewrite</span> &lt;- <span class="id">app_nil_end</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">move_no_temp</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span> <span class="kwd">in</span> <span class="id">C</span>. <span class="tactic">rewrite</span> <span class="id">rev_unit</span> <span class="kwd">in</span> <span class="id">C</span>. <span class="tactic">destruct</span> <span class="id">C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">move_no_temp_append</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">move_no_temp_rev</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e2</span> := <span class="id">update</span> (<span class="id">temp</span> <span class="id">s</span>) (<span class="id">e1</span> <span class="id">s</span>) <span class="id">e1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e3</span> := <span class="id">exec_par</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>) <span class="id">e1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e4</span> := <span class="id">exec_par</span> (<span class="id">mu</span> ++ <span class="id">sigma</span>) <span class="id">e2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">env_equiv</span> <span class="id">e2</span> <span class="id">e1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">e2</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">update_o</span>. <span class="tactic">apply</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">env_equiv</span> <span class="id">e4</span> <span class="id">e3</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">e4</span>, <span class="id">e3</span>. <span class="tactic">apply</span> <span class="id">exec_par_env_equiv</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">update</span>. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">r</span> <span class="id">d</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">e2</span>. <span class="tactic">apply</span> <span class="id">update_s</span>. <span class="tactic">apply</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;pop&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>'. <span class="tactic">unfold</span> <span class="id">statemove</span>. <span class="tactic">simpl</span> <span class="id">exec_seq_rev</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e1</span> := <span class="id">exec_seq_rev</span> <span class="id">tau</span> <span class="id">e</span>).<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_par_append_eq</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_par_update_no_read</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">no_read_path</span>; <span class="tactic">auto</span>. <span class="tactic">eapply</span> <span class="id">is_path_pop</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">update_o</span>. <span class="tactic">red</span>; <span class="tactic">intro</span>; <span class="tactic">subst</span> <span class="id">r</span>. <span class="tactic">elim</span> (<span class="id">H</span> <span class="id">H1</span>).<br/>
<br/>
&nbsp;last&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>'. <span class="tactic">unfold</span> <span class="id">statemove</span>. <span class="tactic">simpl</span> <span class="id">exec_seq_rev</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e1</span> := <span class="id">exec_seq_rev</span> <span class="id">tau</span> <span class="id">e</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">exec_par_append_eq</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">update_o</span>. <span class="tactic">red</span>; <span class="tactic">intro</span>; <span class="tactic">subst</span> <span class="id">r</span>. <span class="tactic">elim</span> (<span class="id">H</span> <span class="id">H0</span>).<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transitions_preserve_semantics</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>' <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">transitions</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">state_wf</span> <span class="id">st</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_equiv</span> (<span class="id">statemove</span> <span class="id">st</span>' <span class="id">e</span>) (<span class="id">statemove</span> <span class="id">st</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof990')">Proof.</div>
<div class="proofscript" id="proof990">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transition_preserves_semantics</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">env_equiv_trans</span> <span class="kwd">with</span> (<span class="id">statemove</span> <span class="id">y</span> <span class="id">e</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHclos_refl_trans2</span>. <span class="tactic">eapply</span> <span class="id">transitions_preserve_wf</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">state_wf_start</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">state_wf</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof991')">Proof.</div>
<div class="proofscript" id="proof991">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">constructor</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">app_nil_end</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The main correctness result in this section is the following:
  if we can transition repeatedly from an initial state <span class="bracket"><span class="id">mu</span>, <span class="id">nil</span>, <span class="id">nil</span></span>
  to a final state <span class="bracket"><span class="id">nil</span>, <span class="id">nil</span>, <span class="id">tau</span></span>, then the sequential execution
  of the moves <span class="bracket"><span class="id">rev</span> <span class="id">tau</span></span> is semantically equivalent to the parallel
  execution of the moves <span class="bracket"><span class="id">mu</span></span>. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">transitions_correctness</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transitions</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>) (<span class="id">State</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">tau</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">env_equiv</span> (<span class="id">exec_seq</span> (<span class="id">List.rev</span> <span class="id">tau</span>) <span class="id">e</span>) (<span class="id">exec_par</span> <span class="id">mu</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof992')">Proof.</div>
<div class="proofscript" id="proof992">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">transitions_preserve_semantics</span> <span class="id">_</span> <span class="id">_</span> <span class="id">e</span> <span class="id">H1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">state_wf_start</span> <span class="id">_</span> <span class="id">H</span> <span class="id">H0</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">statemove</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">app_nil_end</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">exec_seq_exec_seq_rev</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Determinisation of the transition relation </h1>
<br/>
<div class="doc">We now define a deterministic variant <span class="bracket"><span class="id">dtransition</span></span> of the
  transition relation <span class="bracket"><span class="id">transition</span></span>.  <span class="bracket"><span class="id">dtransition</span></span> is deterministic
  in the sense that at most one transition applies to a given state. </div>
<br/>
<span class="kwd">Inductive</span> <span class="id">dtransition</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">dtr_nop</span>: <span class="kwd">forall</span> <span class="id">r</span> <span class="id">mu</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> ((<span class="id">r</span>, <span class="id">r</span>) :: <span class="id">mu</span>) <span class="id">nil</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">dtr_start</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">mu</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span> &lt;&gt; <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">mu</span>) <span class="id">nil</span> <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">dtr_push</span>: <span class="kwd">forall</span> <span class="id">mu1</span> <span class="id">d</span> <span class="id">r</span> <span class="id">mu2</span> <span class="id">s</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu1</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> (<span class="id">mu1</span> ++ (<span class="id">d</span>, <span class="id">r</span>) :: <span class="id">mu2</span>) ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">sigma</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> (<span class="id">mu1</span> ++ <span class="id">mu2</span>) ((<span class="id">d</span>, <span class="id">r</span>) :: (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">sigma</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;| <span class="id">dtr_loop_pop</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">r0</span> <span class="id">d</span>  <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu</span> <span class="id">r0</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s</span>, <span class="id">r0</span>) :: <span class="id">sigma</span> ++ (<span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> (<span class="id">sigma</span> ++ (<span class="id">temp</span> <span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>) ((<span class="id">s</span>, <span class="id">r0</span>) :: (<span class="id">r0</span>, <span class="id">temp</span> <span class="id">r0</span>) :: <span class="id">tau</span>))<br/>
&nbsp;&nbsp;| <span class="id">dtr_pop</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s0</span> <span class="id">d0</span> <span class="id">s1</span> <span class="id">d1</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu</span> <span class="id">d1</span> -&gt; <span class="id">d1</span> &lt;&gt; <span class="id">s0</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> (<span class="id">sigma</span> ++ (<span class="id">s0</span>, <span class="id">d0</span>) :: <span class="id">nil</span>) ((<span class="id">s1</span>, <span class="id">d1</span>) :: <span class="id">tau</span>))<br/>
&nbsp;&nbsp;| <span class="id">dtr_last</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">no_read</span> <span class="id">mu</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dtransition</span> (<span class="id">State</span> <span class="id">mu</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">tau</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">tau</span>)).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">dtransitions</span>: <span class="id">state</span> -&gt; <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">clos_refl_trans</span> <span class="id">state</span> <span class="id">dtransition</span>.<br/>
<br/>
<div class="doc">Every deterministic transition corresponds to a sequence of
  non-deterministic transitions. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transition_determ</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">dtransition</span> <span class="id">st</span> <span class="id">st</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">state_wf</span> <span class="id">st</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transitions</span> <span class="id">st</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof993')">Proof.</div>
<div class="proofscript" id="proof993">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intro</span>; <span class="tactic">unfold</span> <span class="id">transitions</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">exact</span> (<span class="id">tr_nop</span> <span class="id">nil</span> <span class="id">r</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">tau</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">exact</span> (<span class="id">tr_start</span> <span class="id">nil</span> <span class="id">s</span> <span class="id">d</span> <span class="id">mu</span> <span class="id">tau</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">apply</span> <span class="id">tr_push</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">rt_trans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> ((<span class="id">s</span>, <span class="id">r0</span>) :: <span class="id">sigma</span> ++ (<span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> (((<span class="id">s</span>, <span class="id">r0</span>) :: <span class="id">sigma</span>) ++ (<span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">tr_loop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">simpl</span>. <span class="tactic">apply</span> <span class="id">tr_pop</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">inv</span> <span class="id">H0</span>.  <span class="tactic">generalize</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">change</span> ((<span class="id">s</span>, <span class="id">r0</span>) :: <span class="id">sigma</span> ++ (<span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">with</span> (((<span class="id">s</span>, <span class="id">r0</span>) :: <span class="id">sigma</span>) ++ (<span class="id">r0</span>, <span class="id">d</span>) :: <span class="id">nil</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">temp_last</span>; <span class="tactic">rewrite</span> <span class="id">List.rev_unit</span>. <span class="tactic">intros</span> [<span class="id">E</span> <span class="id">F</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">elim</span> (<span class="id">F</span> <span class="id">s</span> <span class="id">r0</span>). <span class="tactic">unfold</span> <span class="id">is_not_temp</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">List.In_rev</span>. <span class="tactic">apply</span> <span class="id">in_eq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">apply</span> <span class="id">tr_pop</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">apply</span> <span class="id">tr_last</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">transitions_determ</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">dtransitions</span> <span class="id">st</span> <span class="id">st</span>' -&gt;<br/>
&nbsp;&nbsp;<span class="id">state_wf</span> <span class="id">st</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">transitions</span> <span class="id">st</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof994')">Proof.</div>
<div class="proofscript" id="proof994">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">transitions</span>; <span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transition_determ</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">rt_trans</span> <span class="kwd">with</span> <span class="id">y</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHclos_refl_trans2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transitions_preserve_wf</span> <span class="kwd">with</span> <span class="id">x</span>; <span class="tactic">auto</span>. <span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The semantic correctness of deterministic transitions follows. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">dtransitions_correctness</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">dtransitions</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>) (<span class="id">State</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">tau</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>, <span class="id">env_equiv</span> (<span class="id">exec_seq</span> (<span class="id">List.rev</span> <span class="id">tau</span>) <span class="id">e</span>) (<span class="id">exec_par</span> <span class="id">mu</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof995')">Proof.</div>
<div class="proofscript" id="proof995">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">transitions_correctness</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">transitions_determ</span>. <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">state_wf_start</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> The compilation function </h1>
<br/>
<div class="doc">We now define a function that takes a well-formed parallel move <span class="bracket"><span class="id">mu</span></span>
  and returns a sequence of elementary moves <span class="bracket"><span class="id">tau</span></span> that is semantically
  equivalent.  We start by defining a number of auxiliary functions. </div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">split_move</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">r</span>: <span class="id">reg</span>) {<span class="kwd">struct</span> <span class="id">m</span>} : <span class="id">option</span> (<span class="id">moves</span> * <span class="id">reg</span> * <span class="id">moves</span>) :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">tl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">reg_eq</span> <span class="id">s</span> <span class="id">r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">Some</span> (<span class="id">nil</span>, <span class="id">d</span>, <span class="id">tl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="kwd">match</span> <span class="id">split_move</span> <span class="id">tl</span> <span class="id">r</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">before</span>, <span class="id">d</span>', <span class="id">after</span>) =&gt; <span class="id">Some</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">before</span>, <span class="id">d</span>', <span class="id">after</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">is_last_source</span> (<span class="id">r</span>: <span class="id">reg</span>) (<span class="id">m</span>: <span class="id">moves</span>) {<span class="kwd">struct</span> <span class="id">m</span>} : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">reg_eq</span> <span class="id">s</span> <span class="id">r</span> <span class="kwd">then</span> <span class="id">true</span> <span class="kwd">else</span> <span class="id">false</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">tl</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_last_source</span> <span class="id">r</span> <span class="id">tl</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">replace_last_source</span> (<span class="id">r</span>: <span class="id">reg</span>) (<span class="id">m</span>: <span class="id">moves</span>) {<span class="kwd">struct</span> <span class="id">m</span>} : <span class="id">moves</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">nil</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span> =&gt; (<span class="id">r</span>, <span class="id">d</span>) :: <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">s_d</span> :: <span class="id">tl</span> =&gt; <span class="id">s_d</span> :: <span class="id">replace_last_source</span> <span class="id">r</span> <span class="id">tl</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">final_state</span> (<span class="id">st</span>: <span class="id">state</span>) : <span class="id">bool</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">_</span> =&gt; <span class="id">true</span><br/>
&nbsp;&nbsp;| <span class="id">_</span> =&gt; <span class="id">false</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">parmove_step</span> (<span class="id">st</span>: <span class="id">state</span>) : <span class="id">state</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">nil</span> <span class="id">nil</span> <span class="id">_</span> =&gt; <span class="id">st</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">tl</span>) <span class="id">nil</span> <span class="id">l</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">reg_eq</span> <span class="id">s</span> <span class="id">d</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">State</span> <span class="id">tl</span> <span class="id">nil</span> <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">State</span> <span class="id">tl</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) <span class="id">l</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">t</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">b</span>) <span class="id">l</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">split_move</span> <span class="id">t</span> <span class="id">d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">t1</span>, <span class="id">r</span>, <span class="id">t2</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">State</span> (<span class="id">t1</span> ++ <span class="id">t2</span>) ((<span class="id">d</span>, <span class="id">r</span>) :: (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">b</span>) <span class="id">l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">None</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">b</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">State</span> <span class="id">t</span> <span class="id">nil</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">is_last_source</span> <span class="id">d</span> <span class="id">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">State</span> <span class="id">t</span> (<span class="id">replace_last_source</span> (<span class="id">temp</span> <span class="id">d</span>) <span class="id">b</span>) ((<span class="id">s</span>, <span class="id">d</span>) :: (<span class="id">d</span>, <span class="id">temp</span> <span class="id">d</span>) :: <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">State</span> <span class="id">t</span> <span class="id">b</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<div class="doc">Here are the main correctness properties of these functions. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">split_move_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">r</span>,<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">split_move</span> <span class="id">m</span> <span class="id">r</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Some</span> (<span class="id">before</span>, <span class="id">d</span>, <span class="id">after</span>) =&gt; <span class="id">m</span> = <span class="id">before</span> ++ (<span class="id">r</span>, <span class="id">d</span>) :: <span class="id">after</span> /\ <span class="id">no_read</span> <span class="id">before</span> <span class="id">r</span><br/>
&nbsp;&nbsp;| <span class="id">None</span> =&gt; <span class="id">no_read</span> <span class="id">m</span> <span class="id">r</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof996')">Proof.</div>
<div class="proofscript" id="proof996">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">no_read</span>. <span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>; <span class="tactic">intros</span>.<br/>
- <span class="tactic">tauto</span>.<br/>
- <span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">s</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;+ <span class="tactic">subst</span> <span class="id">s</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id">specialize</span> (<span class="id">IHm</span> <span class="id">r</span>). <span class="tactic">destruct</span> (<span class="id">split_move</span> <span class="id">m</span> <span class="id">r</span>) <span class="kwd">as</span> [[[<span class="id">before</span> <span class="id">d</span>'] <span class="id">after</span>] | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">IHm</span>. <span class="tactic">subst</span> <span class="id">m</span>. <span class="tactic">simpl</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">simpl</span>; <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">is_last_source_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">is_last_source</span> <span class="id">r</span> (<span class="id">m</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>)<br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">s</span> = <span class="id">r</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">s</span> &lt;&gt; <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof997')">Proof.</div>
<div class="proofscript" id="proof997">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">s</span> <span class="id">r</span>); <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s0</span> <span class="id">d0</span>]. <span class="id">case_eq</span> (<span class="id">m</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">app_cons_not_nil</span> <span class="id">m</span> <span class="id">nil</span> (<span class="id">s</span>, <span class="id">d</span>)). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">replace_last_source_charact</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">s</span>' <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">replace_last_source</span> <span class="id">s</span>' (<span class="id">m</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>) =<br/>
&nbsp;&nbsp;<span class="id">m</span> ++ (<span class="id">s</span>', <span class="id">d</span>) :: <span class="id">nil</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof998')">Proof.</div>
<div class="proofscript" id="proof998">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s0</span> <span class="id">d0</span>]. <span class="id">case_eq</span> (<span class="id">m</span> ++ (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">nil</span>); <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">app_cons_not_nil</span> <span class="id">m</span> <span class="id">nil</span> (<span class="id">s</span>, <span class="id">d</span>)). <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_step_compatible</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span>,<br/>
&nbsp;&nbsp;<span class="id">final_state</span> <span class="id">st</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">dtransition</span> <span class="id">st</span> (<span class="id">parmove_step</span> <span class="id">st</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof999')">Proof.</div>
<div class="proofscript" id="proof999">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">st</span> <span class="id">NOTFINAL</span>. <span class="tactic">destruct</span> <span class="id">st</span> <span class="kwd">as</span> [<span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span>]. <span class="tactic">unfold</span> <span class="id">parmove_step</span>.<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> <span class="id">mu</span>; [<span class="tactic">intros</span> <span class="id">MEQ</span> | <span class="tactic">intros</span> [<span class="id">ms</span> <span class="id">md</span>] <span class="id">mtl</span> <span class="id">MEQ</span>].<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> <span class="id">sigma</span>; [<span class="tactic">intros</span> <span class="id">SEQ</span> | <span class="tactic">intros</span> [<span class="id">ss</span> <span class="id">sd</span>] <span class="id">stl</span> <span class="id">SEQ</span>].<br/>
&nbsp;&nbsp;<span class="tactic">subst</span> <span class="id">mu</span> <span class="id">sigma</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">NOTFINAL</span>. <span class="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> <span class="id">stl</span>; [<span class="tactic">intros</span> <span class="id">STLEQ</span> | <span class="tactic">intros</span> <span class="id">xx1</span> <span class="id">xx2</span> <span class="id">STLEQ</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dtr_last</span>. <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (@<span class="id">exists_last</span> <span class="id">_</span> <span class="id">stl</span>). 2:<span class="tactic">congruence</span>. <span class="tactic">intros</span> <span class="id">sigma1</span> [[<span class="id">ss1</span> <span class="id">sd1</span>] <span class="id">SEQ2</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">STLEQ</span>. <span class="tactic">clear</span> <span class="id">STLEQ</span> <span class="id">xx1</span> <span class="id">xx2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_last_source_charact</span> <span class="id">sd</span> <span class="id">ss1</span> <span class="id">sd1</span> <span class="id">sigma1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">SEQ2</span>. <span class="tactic">destruct</span> (<span class="id">is_last_source</span> <span class="id">sd</span> (<span class="id">sigma1</span> ++ (<span class="id">ss1</span>, <span class="id">sd1</span>) :: <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">subst</span> <span class="id">ss1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">replace_last_source_charact</span>. <span class="tactic">apply</span> <span class="id">dtr_loop_pop</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">apply</span> <span class="id">dtr_pop</span>. <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> <span class="id">sigma</span>; [<span class="tactic">intros</span> <span class="id">SEQ</span> | <span class="tactic">intros</span> [<span class="id">ss</span> <span class="id">sd</span>] <span class="id">stl</span> <span class="id">SEQ</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">reg_eq</span> <span class="id">ms</span> <span class="id">md</span>).<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>. <span class="tactic">apply</span> <span class="id">dtr_nop</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dtr_start</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">split_move_charact</span> ((<span class="id">ms</span>, <span class="id">md</span>) :: <span class="id">mtl</span>) <span class="id">sd</span>).<br/>
&nbsp;&nbsp;<span class="tactic">case</span> (<span class="id">split_move</span> ((<span class="id">ms</span>, <span class="id">md</span>) :: <span class="id">mtl</span>) <span class="id">sd</span>); [<span class="tactic">intros</span> [[<span class="id">before</span> <span class="id">r</span>] <span class="id">after</span>] | <span class="id">idtac</span>].<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> [<span class="id">MEQ2</span> <span class="id">NOREAD</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">MEQ2</span>. <span class="tactic">apply</span> <span class="id">dtr_push</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">NOREAD</span>.<br/>
&nbsp;&nbsp;<span class="id">case_eq</span> <span class="id">stl</span>; [<span class="tactic">intros</span> <span class="id">STLEQ</span> | <span class="tactic">intros</span> <span class="id">xx1</span> <span class="id">xx2</span> <span class="id">STLEQ</span>].<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dtr_last</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> (@<span class="id">exists_last</span> <span class="id">_</span> <span class="id">stl</span>). 2:<span class="tactic">congruence</span>. <span class="tactic">intros</span> <span class="id">sigma1</span> [[<span class="id">ss1</span> <span class="id">sd1</span>] <span class="id">SEQ2</span>].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">STLEQ</span>. <span class="tactic">clear</span> <span class="id">STLEQ</span> <span class="id">xx1</span> <span class="id">xx2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">is_last_source_charact</span> <span class="id">sd</span> <span class="id">ss1</span> <span class="id">sd1</span> <span class="id">sigma1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">SEQ2</span>. <span class="tactic">destruct</span> (<span class="id">is_last_source</span> <span class="id">sd</span> (<span class="id">sigma1</span> ++ (<span class="id">ss1</span>, <span class="id">sd1</span>) :: <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">subst</span> <span class="id">ss1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">replace_last_source_charact</span>. <span class="tactic">apply</span> <span class="id">dtr_loop_pop</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intro</span>. <span class="tactic">apply</span> <span class="id">dtr_pop</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The compilation function is obtained by iterating the <span class="bracket"><span class="id">parmov_step</span></span>
  function.  To show that this iteration always terminates, we introduce
  the following measure over states. </div>
<br/>
<span class="kwd">Open</span> <span class="kwd">Scope</span> <span class="id">nat_scope</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="kwd">measure</span> (<span class="id">st</span>: <span class="id">state</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">State</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span> =&gt; 2 * <span class="id">List.length</span> <span class="id">mu</span> + <span class="id">List.length</span> <span class="id">sigma</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">measure_decreasing_1</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">dtransition</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="kwd">measure</span> <span class="id">st</span>' &lt; <span class="kwd">measure</span> <span class="id">st</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1000')">Proof.</div>
<div class="proofscript" id="proof1000">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">repeat</span> (<span class="tactic">simpl</span>; <span class="tactic">rewrite</span> <span class="id">List.app_length</span>); <span class="tactic">simpl</span>; <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">measure_decreasing_2</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span>,<br/>
&nbsp;&nbsp;<span class="id">final_state</span> <span class="id">st</span> = <span class="id">false</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">measure</span> (<span class="id">parmove_step</span> <span class="id">st</span>) &lt; <span class="kwd">measure</span> <span class="id">st</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1001')">Proof.</div>
<div class="proofscript" id="proof1001">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">measure_decreasing_1</span>. <span class="tactic">apply</span> <span class="id">parmove_step_compatible</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Compilation function for parallel moves. </div>
<br/>
<span class="id">Function</span> <span class="id">parmove_aux</span> (<span class="id">st</span>: <span class="id">state</span>) {<span class="kwd">measure</span> <span class="kwd">measure</span> <span class="id">st</span>} : <span class="id">moves</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">if</span> <span class="id">final_state</span> <span class="id">st</span><br/>
&nbsp;&nbsp;<span class="kwd">then</span> <span class="kwd">match</span> <span class="id">st</span> <span class="kwd">with</span> <span class="id">State</span> <span class="id">_</span> <span class="id">_</span> <span class="id">tau</span> =&gt; <span class="id">tau</span> <span class="kwd">end</span><br/>
&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">parmove_aux</span> (<span class="id">parmove_step</span> <span class="id">st</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1002')">Proof.</div>
<div class="proofscript" id="proof1002">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">measure_decreasing_2</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_aux_transitions</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span>,<br/>
&nbsp;&nbsp;<span class="id">dtransitions</span> <span class="id">st</span> (<span class="id">State</span> <span class="id">nil</span> <span class="id">nil</span> (<span class="id">parmove_aux</span> <span class="id">st</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1003')">Proof.</div>
<div class="proofscript" id="proof1003">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dtransitions</span>. <span class="tactic">intro</span> <span class="id">st</span>. <span class="id">functional</span> <span class="tactic">induction</span> (<span class="id">parmove_aux</span> <span class="id">st</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">_x</span>; <span class="tactic">destruct</span> <span class="id">_x0</span>; <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">e</span>; <span class="tactic">discriminate</span> || <span class="tactic">apply</span> <span class="id">rt_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">rt_trans</span>. <span class="tactic">apply</span> <span class="id">rt_step</span>. <span class="tactic">apply</span> <span class="id">parmove_step_compatible</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">parmove</span> (<span class="id">mu</span>: <span class="id">moves</span>) : <span class="id">moves</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.rev</span> (<span class="id">parmove_aux</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>)).<br/>
<br/>
<div class="doc">This is the main correctness theorem: the sequence of elementary
  moves <span class="bracket"><span class="id">parmove</span> <span class="id">mu</span></span> is semantically equivalent to the parallel move
  <span class="bracket"><span class="id">mu</span></span> if the latter is well-formed. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">parmove_correctness</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span>,<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span> -&gt; <span class="id">is_mill</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="id">env_equiv</span> (<span class="id">exec_seq</span> (<span class="id">parmove</span> <span class="id">mu</span>) <span class="id">e</span>) (<span class="id">exec_par</span> <span class="id">mu</span> <span class="id">e</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1004')">Proof.</div>
<div class="proofscript" id="proof1004">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">parmove</span>. <span class="tactic">apply</span> <span class="id">dtransitions_correctness</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">parmove_aux_transitions</span>.<br/>
Qed.</div>
<br/>
<div class="doc">Here is an alternate formulation of <span class="bracket"><span class="id">parmove</span></span>, where the
  parallel move problem is given as two separate lists of sources
  and destinations. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">parmove2</span> (<span class="id">sl</span> <span class="id">dl</span>: <span class="id">list</span> <span class="id">reg</span>) : <span class="id">moves</span> :=<br/>
&nbsp;&nbsp;<span class="id">parmove</span> (<span class="id">List.combine</span> <span class="id">sl</span> <span class="id">dl</span>).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">parmove2_correctness</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">dl</span>,<br/>
&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">sl</span> = <span class="id">List.length</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">list_norepet</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">sl</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">dl</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">e</span>' := <span class="id">exec_seq</span> (<span class="id">parmove2</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">List.map</span> <span class="id">e</span>' <span class="id">dl</span> = <span class="id">List.map</span> <span class="id">e</span> <span class="id">sl</span> /\<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, ~<span class="id">In</span> <span class="id">r</span> <span class="id">dl</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span> -&gt; <span class="id">e</span>' <span class="id">r</span> = <span class="id">e</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1005')">Proof.</div>
<div class="proofscript" id="proof1005">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">srcs_dests_combine</span> <span class="id">sl</span> <span class="id">dl</span> <span class="id">H</span>) <span class="kwd">as</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">env_equiv</span> <span class="id">e</span>' (<span class="id">exec_par</span> (<span class="id">List.combine</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">e</span>', <span class="id">parmove2</span>. <span class="tactic">apply</span> <span class="id">parmove_correctness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>; <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="tactic">eapply</span> <span class="id">List.in_combine_l</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H2</span>. <span class="tactic">eapply</span> <span class="id">List.in_combine_r</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">rewrite</span> <span class="id">B</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">exec_par_combine</span> <span class="id">e</span> <span class="id">sl</span> <span class="id">dl</span> <span class="id">H</span> <span class="id">H0</span>) <span class="kwd">as</span> [<span class="id">C</span> <span class="id">D</span>].<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e1</span> := <span class="id">exec_par</span> (<span class="id">combine</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span>) <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">C</span>. <span class="tactic">apply</span> <span class="id">list_map_exten</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">H3</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">e1</span> <span class="id">r</span>); <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<h1> Additional syntactic properties </h1>
<br/>
<div class="doc">We now show an additional property of the sequence of moves
  generated by <span class="bracket"><span class="id">parmove</span> <span class="id">mu</span></span>: any such move <span class="bracket"><span class="id">s</span> -&gt; <span class="id">d</span></span> is either
  already present in <span class="bracket"><span class="id">mu</span></span>, or of the form <span class="bracket"><span class="id">temp</span> <span class="id">s</span> -&gt; <span class="id">d</span></span> or <span class="bracket"><span class="id">s</span> -&gt; <span class="id">temp</span> <span class="id">s</span></span>
  for some <span class="bracket"><span class="id">s</span> -&gt; <span class="id">d</span></span> in <span class="bracket"><span class="id">mu</span></span>.  This syntactic property is useful
  to show that <span class="bracket"><span class="id">parmove</span></span> preserves register classes, for instance. </div>
<br/>
<span class="kwd">Section</span> <span class="id">PROPERTIES</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">initial_move</span>: <span class="id">moves</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">wf_move</span>: <span class="id">reg</span> -&gt; <span class="id">reg</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">wf_move_same</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">initial_move</span> -&gt; <span class="id">wf_move</span> <span class="id">s</span> <span class="id">d</span><br/>
&nbsp;&nbsp;| <span class="id">wf_move_temp_left</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wf_move</span> <span class="id">s</span> <span class="id">d</span> -&gt; <span class="id">wf_move</span> (<span class="id">temp</span> <span class="id">s</span>) <span class="id">d</span><br/>
&nbsp;&nbsp;| <span class="id">wf_move_temp_right</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wf_move</span> <span class="id">s</span> <span class="id">d</span> -&gt; <span class="id">wf_move</span> <span class="id">s</span> (<span class="id">temp</span> <span class="id">s</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">wf_moves</span> (<span class="id">m</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">m</span> -&gt; <span class="id">wf_move</span> <span class="id">s</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">wf_moves_cons</span>: <span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span> <span class="id">m</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_moves</span> ((<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>) &lt;-&gt; <span class="id">wf_move</span> <span class="id">s</span> <span class="id">d</span> /\ <span class="id">wf_moves</span> <span class="id">m</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1006')">Proof.</div>
<div class="proofscript" id="proof1006">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">wf_moves</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>. <span class="tactic">firstorder</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>; <span class="tactic">subst</span> <span class="id">s0</span> <span class="id">d0</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">wf_moves_append</span>: <span class="kwd">forall</span> <span class="id">m1</span> <span class="id">m2</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_moves</span> (<span class="id">m1</span> ++ <span class="id">m2</span>) &lt;-&gt; <span class="id">wf_moves</span> <span class="id">m1</span> /\ <span class="id">wf_moves</span> <span class="id">m2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1007')">Proof.</div>
<div class="proofscript" id="proof1007">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">wf_moves</span>; <span class="tactic">intros</span>. <span class="tactic">split</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">intros</span>; <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">apply</span> <span class="id">in_or_app</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">elim</span> (<span class="id">in_app_or</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>); <span class="tactic">intro</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Hint</span> <span class="id">Rewrite</span> <span class="id">wf_moves_cons</span> <span class="id">wf_moves_append</span>: <span class="id">pmov</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">wf_state</span>: <span class="id">state</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">wf_state_intro</span>: <span class="kwd">forall</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wf_moves</span> <span class="id">mu</span> -&gt; <span class="id">wf_moves</span> <span class="id">sigma</span> -&gt; <span class="id">wf_moves</span> <span class="id">tau</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wf_state</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">sigma</span> <span class="id">tau</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">dtransition_preserves_wf_state</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">dtransition</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">wf_state</span> <span class="id">st</span> -&gt; <span class="id">wf_state</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1008')">Proof.</div>
<div class="proofscript" id="proof1008">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intro</span> <span class="id">WF</span>; <span class="id">inv</span> <span class="id">WF</span>; <span class="id">constructor</span>; <span class="id">autorewrite</span> <span class="kwd">with</span> <span class="id">pmov</span> <span class="kwd">in</span> *; <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">wf_move_temp_left</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">wf_move_temp_right</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dtransitions_preserve_wf_state</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">st</span> <span class="id">st</span>',<br/>
&nbsp;&nbsp;<span class="id">dtransitions</span> <span class="id">st</span> <span class="id">st</span>' -&gt; <span class="id">wf_state</span> <span class="id">st</span> -&gt; <span class="id">wf_state</span> <span class="id">st</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1009')">Proof.</div>
<div class="proofscript" id="proof1009">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>; <span class="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dtransition_preserves_wf_state</span>; <span class="tactic">eauto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PROPERTIES</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_wf_moves</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span>, <span class="id">wf_moves</span> <span class="id">mu</span> (<span class="id">parmove</span> <span class="id">mu</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1010')">Proof.</div>
<div class="proofscript" id="proof1010">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wf_state</span> <span class="id">mu</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">wf_move_same</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>. <span class="tactic">red</span>; <span class="tactic">simpl</span>; <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">dtransitions_preserve_wf_state</span> <span class="id">mu</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">_</span> <span class="id">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">parmove_aux_transitions</span> (<span class="id">State</span> <span class="id">mu</span> <span class="id">nil</span> <span class="id">nil</span>)) <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">WFS</span>. <span class="id">inv</span> <span class="id">WFS</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">parmove</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.In_rev</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove2_wf_moves</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">dl</span>, <span class="id">wf_moves</span> (<span class="id">List.combine</span> <span class="id">sl</span> <span class="id">dl</span>) (<span class="id">parmove2</span> <span class="id">sl</span> <span class="id">dl</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1011')">Proof.</div>
<div class="proofscript" id="proof1011">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">parmove2</span>. <span class="tactic">apply</span> <span class="id">parmove_wf_moves</span>.<br/>
Qed.</div>
<br/>
<div class="doc">As a corollary, we show that all sources of <span class="bracket"><span class="id">parmove</span> <span class="id">mu</span></span>
    are sources of <span class="bracket"><span class="id">mu</span></span> or temporaries,
    and likewise all destinations of <span class="bracket"><span class="id">parmove</span> <span class="id">mu</span></span> are destinations of <span class="bracket"><span class="id">mu</span></span>
    or temporaries. </div>
<br/>
<span class="kwd">Remark</span> <span class="id">wf_move_initial_reg_or_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;<span class="id">wf_move</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">s</span>) /\ (<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">d</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1012')">Proof.</div>
<div class="proofscript" id="proof1012">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> <span class="id">s</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">s</span>, <span class="id">d</span>)). <span class="tactic">unfold</span> <span class="id">srcs</span>. <span class="tactic">apply</span> <span class="id">List.in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">change</span> <span class="id">d</span> <span class="kwd">with</span> (<span class="id">snd</span> (<span class="id">s</span>, <span class="id">d</span>)). <span class="tactic">unfold</span> <span class="id">dests</span>. <span class="tactic">apply</span> <span class="id">List.in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="id">right</span>. <span class="id">exists</span> <span class="id">s</span>; <span class="tactic">auto</span>. <span class="tactic">tauto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">tauto</span>. <span class="id">right</span>. <span class="id">exists</span> <span class="id">s</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_initial_reg_or_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) (<span class="id">parmove</span> <span class="id">mu</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">s</span>) /\ (<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">d</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1013')">Proof.</div>
<div class="proofscript" id="proof1013">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">wf_move_initial_reg_or_temp</span>. <span class="tactic">apply</span> <span class="id">parmove_wf_moves</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">in_srcs</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span>, <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) -&gt; <span class="id">exists</span> <span class="id">d</span>, <span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">mu</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1014')">Proof.</div>
<div class="proofscript" id="proof1014">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">list_in_map_inv</span> (@<span class="id">fst</span> <span class="id">reg</span> <span class="id">reg</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">d</span>'] [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">d</span>'; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Remark</span> <span class="id">in_dests</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) -&gt; <span class="id">exists</span> <span class="id">s</span>, <span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">mu</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1015')">Proof.</div>
<div class="proofscript" id="proof1015">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">list_in_map_inv</span> (@<span class="id">snd</span> <span class="id">reg</span> <span class="id">reg</span>) <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> [[<span class="id">s</span>' <span class="id">d</span>'] [<span class="id">A</span> <span class="id">B</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">A</span>. <span class="id">exists</span> <span class="id">s</span>'; <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_srcs_initial_reg_or_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">s</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> (<span class="id">parmove</span> <span class="id">mu</span>)) -&gt; <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">s</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1016')">Proof.</div>
<div class="proofscript" id="proof1016">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">in_srcs</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> [<span class="id">d</span> <span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">parmove_initial_reg_or_temp</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>). <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_dests_initial_reg_or_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> (<span class="id">parmove</span> <span class="id">mu</span>)) -&gt; <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">d</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1017')">Proof.</div>
<div class="proofscript" id="proof1017">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> (<span class="id">in_dests</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>) <span class="kwd">as</span> [<span class="id">s</span> <span class="id">A</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">parmove_initial_reg_or_temp</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">A</span>). <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">As a second corollary, we show that <span class="bracket"><span class="id">parmov</span></span> preserves register
    classes, in the sense made precise below. </div>
<br/>
<span class="kwd">Section</span> <span class="id">REGISTER_CLASSES</span>.<br/>
<br/>
<span class="kwd">Variable</span> <span class="id">class</span>: <span class="kwd">Type</span>.<br/>
<span class="kwd">Variable</span> <span class="id">regclass</span>: <span class="id">reg</span> -&gt; <span class="id">class</span>.<br/>
<span class="kwd">Hypothesis</span> <span class="id">temp_preserves_class</span>: <span class="kwd">forall</span> <span class="id">r</span>, <span class="id">regclass</span> (<span class="id">temp</span> <span class="id">r</span>) = <span class="id">regclass</span> <span class="id">r</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">is_class_compatible</span> (<span class="id">mu</span>: <span class="id">moves</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">In</span> (<span class="id">s</span>, <span class="id">d</span>) <span class="id">mu</span> -&gt; <span class="id">regclass</span> <span class="id">s</span> = <span class="id">regclass</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">parmove_preserves_register_classes</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">mu</span>,<br/>
&nbsp;&nbsp;<span class="id">is_class_compatible</span> <span class="id">mu</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">is_class_compatible</span> (<span class="id">parmove</span> <span class="id">mu</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1018')">Proof.</div>
<div class="proofscript" id="proof1018">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">wf_move</span> <span class="id">mu</span> <span class="id">s</span> <span class="id">d</span> -&gt; <span class="id">regclass</span> <span class="id">s</span> = <span class="id">regclass</span> <span class="id">d</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">temp_preserves_class</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>; <span class="tactic">apply</span> <span class="id">temp_preserves_class</span>.<br/>
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">parmove_wf_moves</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">REGISTER_CLASSES</span>.<br/>
<br/>
<h1> Extension to partially overlapping registers </h1>
<br/>
<div class="doc">We now extend the previous results to the case where distinct
  registers can partially overlap, so that assigning to one register
  changes the value of the other.  We asuume given a disjointness relation
  <span class="bracket"><span class="id">disjoint</span></span> between registers. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">disjoint</span>: <span class="id">reg</span> -&gt; <span class="id">reg</span> -&gt; <span class="kwd">Prop</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">disjoint_sym</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">r2</span>, <span class="id">disjoint</span> <span class="id">r1</span> <span class="id">r2</span> -&gt; <span class="id">disjoint</span> <span class="id">r2</span> <span class="id">r1</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">disjoint_not_equal</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">r2</span>, <span class="id">disjoint</span> <span class="id">r1</span> <span class="id">r2</span> -&gt; <span class="id">r1</span> &lt;&gt; <span class="id">r2</span>.<br/>
<br/>
<div class="doc">Two registers partially overlap if they are different and not disjoint.
    For the Coq development, it is easier to define the complement:
    two registers do not partially overlap if they are identical or disjoint. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">no_overlap</span> (<span class="id">r1</span> <span class="id">r2</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">r1</span> = <span class="id">r2</span> \/ <span class="id">disjoint</span> <span class="id">r1</span> <span class="id">r2</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_overlap_sym</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">r2</span>, <span class="id">no_overlap</span> <span class="id">r1</span> <span class="id">r2</span> -&gt; <span class="id">no_overlap</span> <span class="id">r2</span> <span class="id">r1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1019')">Proof.</div>
<div class="proofscript" id="proof1019">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="id">left</span>; <span class="tactic">auto</span>. <span class="id">right</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">We axiomatize the effect of assigning a value to a register over an
  execution environment.  The target register is set to the given value
  (property <span class="bracket"><span class="id">weak_update_s</span></span>), and registers disjoint from the target
  keep their previous values (property <span class="bracket"><span class="id">weak_update_d</span></span>).  The values of
  other registers are undefined after the assignment. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">weak_update</span>: <span class="id">reg</span> -&gt; <span class="id">val</span> -&gt; <span class="id">env</span> -&gt; <span class="id">env</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">weak_update_s</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span>, <span class="id">weak_update</span> <span class="id">r</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r</span> = <span class="id">v</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">weak_update_d</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r2</span>, <span class="id">disjoint</span> <span class="id">r1</span> <span class="id">r2</span> -&gt; <span class="id">weak_update</span> <span class="id">r1</span> <span class="id">v</span> <span class="id">e</span> <span class="id">r2</span> = <span class="id">e</span> <span class="id">r2</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">weak_exec_seq</span> (<span class="id">m</span>: <span class="id">moves</span>) (<span class="id">e</span>: <span class="id">env</span>) {<span class="kwd">struct</span> <span class="id">m</span>}: <span class="id">env</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">m</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">nil</span> =&gt; <span class="id">e</span><br/>
&nbsp;&nbsp;| (<span class="id">s</span>, <span class="id">d</span>) :: <span class="id">m</span>' =&gt; <span class="id">weak_exec_seq</span> <span class="id">m</span>' (<span class="id">weak_update</span> <span class="id">d</span> (<span class="id">e</span> <span class="id">s</span>) <span class="id">e</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">disjoint_list</span> (<span class="id">r</span>: <span class="id">reg</span>) (<span class="id">l</span>: <span class="id">list</span> <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>', <span class="id">In</span> <span class="id">r</span>' <span class="id">l</span> -&gt; <span class="id">disjoint</span> <span class="id">r</span> <span class="id">r</span>'.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">pairwise_disjoint</span>: <span class="id">list</span> <span class="id">reg</span> -&gt; <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id">pairwise_disjoint_nil</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pairwise_disjoint</span> <span class="id">nil</span><br/>
&nbsp;&nbsp;| <span class="id">pairwise_disjoint_cons</span>: <span class="kwd">forall</span> <span class="id">r</span> <span class="id">l</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">disjoint_list</span> <span class="id">r</span> <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pairwise_disjoint</span> <span class="id">l</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pairwise_disjoint</span> (<span class="id">r</span> :: <span class="id">l</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">disjoint_temps</span> (<span class="id">r</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">is_temp</span> <span class="id">t</span> -&gt; <span class="id">disjoint</span> <span class="id">r</span> <span class="id">t</span>.<br/>
<br/>
<span class="kwd">Section</span> <span class="id">OVERLAP</span>.<br/>
<br/>
<div class="doc">We consider a parallel move problem <span class="bracket"><span class="id">mu</span></span> that satisfies the following
  conditions, which are stronger, overlap-aware variants of the
  <span class="bracket"><span class="id">move_no_temp</span> <span class="id">mu</span></span> and <span class="bracket"><span class="id">is_mill</span> <span class="id">mu</span></span> conditions used previously. </div>
<br/>
<span class="kwd">Variable</span> <span class="id">mu</span>: <span class="id">moves</span>.<br/>
<br/>
<div class="doc">Sources and destinations are disjoint from all temporary registers. </div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">mu_no_temporaries_src</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span>, <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) -&gt; <span class="id">disjoint_temps</span> <span class="id">s</span>.<br/>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">mu_no_temporaries_dst</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) -&gt; <span class="id">disjoint_temps</span> <span class="id">d</span>.<br/>
<br/>
<div class="doc">Destinations are pairwise disjoint. </div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">mu_dest_pairwise_disjoint</span>:<br/>
&nbsp;&nbsp;<span class="id">pairwise_disjoint</span> (<span class="id">dests</span> <span class="id">mu</span>).<br/>
<br/>
<div class="doc">Sources and destinations do not partially overlap. </div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">mu_src_dst_no_overlap</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) -&gt; <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) -&gt; <span class="id">no_overlap</span> <span class="id">s</span> <span class="id">d</span>.<br/>
<br/>
<div class="doc">Distinct temporaries do not partially overlap. </div>
<br/>
<span class="kwd">Hypothesis</span> <span class="id">temps_no_overlap</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">is_temp</span> <span class="id">t1</span> -&gt; <span class="id">is_temp</span> <span class="id">t2</span> -&gt; <span class="id">no_overlap</span> <span class="id">t1</span> <span class="id">t2</span>.<br/>
<br/>
<div class="doc">The following lemmas show that <span class="bracket"><span class="id">mu</span></span> is a windmill and does not
  contain temporary registers. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">disjoint_list_notin</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span> <span class="id">l</span>, <span class="id">disjoint_list</span> <span class="id">r</span> <span class="id">l</span> -&gt; ~<span class="id">In</span> <span class="id">r</span> <span class="id">l</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1020')">Proof.</div>
<div class="proofscript" id="proof1020">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span>; <span class="tactic">intro</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">r</span> &lt;&gt; <span class="id">r</span>). <span class="tactic">apply</span> <span class="id">disjoint_not_equal</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">pairwise_disjoint_norepet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">l</span>, <span class="id">pairwise_disjoint</span> <span class="id">l</span> -&gt; <span class="id">list_norepet</span> <span class="id">l</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1021')">Proof.</div>
<div class="proofscript" id="proof1021">
&nbsp;&nbsp;<span class="tactic">induction</span> 1.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span>. <span class="tactic">apply</span> <span class="id">disjoint_list_notin</span>; <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">disjoint_temps_not_temp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">disjoint_temps</span> <span class="id">r</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1022')">Proof.</div>
<div class="proofscript" id="proof1022">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">disjoint_not_equal</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="id">exists</span> <span class="id">d</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mu_is_mill</span>:<br/>
&nbsp;&nbsp;<span class="id">is_mill</span> <span class="id">mu</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1023')">Proof.</div>
<div class="proofscript" id="proof1023">
&nbsp;&nbsp;<span class="tactic">red</span>. <span class="tactic">apply</span> <span class="id">pairwise_disjoint_norepet</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">mu_move_no_temp</span>:<br/>
&nbsp;&nbsp;<span class="id">move_no_temp</span> <span class="id">mu</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1024')">Proof.</div>
<div class="proofscript" id="proof1024">
&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">apply</span> <span class="id">disjoint_temps_not_temp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mu_no_temporaries_src</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">srcs</span>. <span class="id">change</span> <span class="id">s</span> <span class="kwd">with</span> (<span class="id">fst</span> (<span class="id">s</span>,<span class="id">d</span>)). <span class="tactic">apply</span> <span class="id">List.in_map</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">mu_no_temporaries_dst</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dests</span>. <span class="id">change</span> <span class="id">d</span> <span class="kwd">with</span> (<span class="id">snd</span> (<span class="id">s</span>,<span class="id">d</span>)). <span class="tactic">apply</span> <span class="id">List.in_map</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">We define the ``adherence'' of the problem <span class="bracket"><span class="id">mu</span></span> as the set of
  registers that partially overlap with one of the registers
  possibly assigned by the parallel move: destinations and temporaries.
  Again, we define the complement of the ``adherence'' set, which is
  more convenient for Coq reasoning. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">no_adherence</span> (<span class="id">r</span>: <span class="id">reg</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">x</span>, <span class="id">In</span> <span class="id">x</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">x</span> -&gt; <span class="id">no_overlap</span> <span class="id">x</span> <span class="id">r</span>.<br/>
<br/>
<div class="doc">As a consequence of the hypotheses on <span class="bracket"><span class="id">mu</span></span>, none of the destination
  registers, source registers, and temporaries belong to the adherence. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_overlap_pairwise</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r1</span> <span class="id">r2</span> <span class="id">m</span>, <span class="id">pairwise_disjoint</span> <span class="id">m</span> -&gt; <span class="id">In</span> <span class="id">r1</span> <span class="id">m</span> -&gt; <span class="id">In</span> <span class="id">r2</span> <span class="id">m</span> -&gt; <span class="id">no_overlap</span> <span class="id">r1</span> <span class="id">r2</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1025')">Proof.</div>
<div class="proofscript" id="proof1025">
&nbsp;&nbsp;<span class="tactic">induction</span> 1; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">elim</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> *. <span class="tactic">destruct</span> <span class="id">H1</span>; <span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>. <span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>. <span class="id">right</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>. <span class="id">right</span>. <span class="tactic">apply</span> <span class="id">disjoint_sym</span>. <span class="tactic">apply</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_adherence_dst</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) -&gt; <span class="id">no_adherence</span> <span class="id">d</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1026')">Proof.</div>
<div class="proofscript" id="proof1026">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">apply</span> <span class="id">no_overlap_pairwise</span> <span class="kwd">with</span> (<span class="id">dests</span> <span class="id">mu</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">disjoint_sym</span>. <span class="tactic">apply</span> <span class="id">mu_no_temporaries_dst</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_adherence_src</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">s</span>, <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) -&gt; <span class="id">no_adherence</span> <span class="id">s</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1027')">Proof.</div>
<div class="proofscript" id="proof1027">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">no_overlap_sym</span>. <span class="tactic">apply</span> <span class="id">mu_src_dst_no_overlap</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">disjoint_sym</span>. <span class="tactic">apply</span> <span class="id">mu_no_temporaries_src</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">no_adherence_tmp</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">t</span>, <span class="id">is_temp</span> <span class="id">t</span> -&gt; <span class="id">no_adherence</span> <span class="id">t</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1028')">Proof.</div>
<div class="proofscript" id="proof1028">
&nbsp;&nbsp;<span class="tactic">intros</span>; <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">mu_no_temporaries_dst</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">temps_no_overlap</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<div class="doc">The relation <span class="bracket"><span class="id">env_match</span></span> holds between two environments <span class="bracket"><span class="id">e1</span></span> and <span class="bracket"><span class="id">e2</span></span>
    if they assign the same values to all registers not in the adherence set. </div>
<br/>
<span class="kwd">Definition</span> <span class="id">env_match</span> (<span class="id">e1</span> <span class="id">e2</span>: <span class="id">env</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">no_adherence</span> <span class="id">r</span> -&gt; <span class="id">e1</span> <span class="id">r</span> = <span class="id">e2</span> <span class="id">r</span>.<br/>
<br/>
<div class="doc">The following lemmas relate the effect of executing moves
  using normal, overlap-unaware update and weak, overlap-aware update. </div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_update_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e1</span> <span class="id">e2</span> <span class="id">s</span> <span class="id">d</span>,<br/>
&nbsp;&nbsp;(<span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">s</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">d</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_match</span> <span class="id">e1</span> <span class="id">e2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_match</span> (<span class="id">update</span> <span class="id">d</span> (<span class="id">e1</span> <span class="id">s</span>) <span class="id">e1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">weak_update</span> <span class="id">d</span> (<span class="id">e2</span> <span class="id">s</span>) <span class="id">e2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1029')">Proof.</div>
<div class="proofscript" id="proof1029">
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">red</span>; <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">no_overlap</span> <span class="id">d</span> <span class="id">r</span>). <span class="tactic">apply</span> <span class="id">H2</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>. <span class="tactic">rewrite</span> <span class="id">update_s</span>. <span class="tactic">rewrite</span> <span class="id">weak_update_s</span>. <span class="tactic">apply</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">apply</span> <span class="id">no_adherence_src</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">no_adherence_tmp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">update_o</span>. <span class="tactic">rewrite</span> <span class="id">weak_update_d</span>. <span class="tactic">apply</span> <span class="id">H1</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">sym_not_equal</span>. <span class="tactic">apply</span> <span class="id">disjoint_not_equal</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">weak_exec_seq_match</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">m</span> <span class="id">e1</span> <span class="id">e2</span>,<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">s</span>, <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">m</span>) -&gt; <span class="id">In</span> <span class="id">s</span> (<span class="id">srcs</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">s</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">m</span>) -&gt; <span class="id">In</span> <span class="id">d</span> (<span class="id">dests</span> <span class="id">mu</span>) \/ <span class="id">is_temp</span> <span class="id">d</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_match</span> <span class="id">e1</span> <span class="id">e2</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id">env_match</span> (<span class="id">exec_seq</span> <span class="id">m</span> <span class="id">e1</span>) (<span class="id">weak_exec_seq</span> <span class="id">m</span> <span class="id">e2</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1030')">Proof.</div>
<div class="proofscript" id="proof1030">
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">m</span>; <span class="tactic">intros</span>; <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">a</span> <span class="kwd">as</span> [<span class="id">s</span> <span class="id">d</span>]. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHm</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">weak_update_match</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">OVERLAP</span>.<br/>
<br/>
<div class="doc">These lemmas imply the following correctness theorem for the <span class="bracket"><span class="id">parmove2</span></span>
  function, taking partial register overlap into account. </div>
<br/>
<span class="kwd">Theorem</span> <span class="id">parmove2_correctness_with_overlap</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">sl</span> <span class="id">dl</span>,<br/>
&nbsp;&nbsp;<span class="id">List.length</span> <span class="id">sl</span> = <span class="id">List.length</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">sl</span> -&gt; <span class="id">disjoint_temps</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">dl</span> -&gt; <span class="id">disjoint_temps</span> <span class="id">r</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id">pairwise_disjoint</span> <span class="id">dl</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">s</span> <span class="id">d</span>, <span class="id">In</span> <span class="id">s</span> <span class="id">sl</span> -&gt; <span class="id">In</span> <span class="id">d</span> <span class="id">dl</span> -&gt; <span class="id">no_overlap</span> <span class="id">s</span> <span class="id">d</span>) -&gt;<br/>
&nbsp;&nbsp;(<span class="kwd">forall</span> <span class="id">t1</span> <span class="id">t2</span>, <span class="id">is_temp</span> <span class="id">t1</span> -&gt; <span class="id">is_temp</span> <span class="id">t2</span> -&gt; <span class="id">no_overlap</span> <span class="id">t1</span> <span class="id">t2</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">e</span>,<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">e</span>' := <span class="id">weak_exec_seq</span> (<span class="id">parmove2</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">List.map</span> <span class="id">e</span>' <span class="id">dl</span> = <span class="id">List.map</span> <span class="id">e</span> <span class="id">sl</span> /\<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> <span class="id">r</span>, <span class="id">disjoint_list</span> <span class="id">r</span> <span class="id">dl</span> -&gt; <span class="id">disjoint_temps</span> <span class="id">r</span> -&gt; <span class="id">e</span>' <span class="id">r</span> = <span class="id">e</span> <span class="id">r</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1031')">Proof.</div>
<div class="proofscript" id="proof1031">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">list_norepet</span> <span class="id">dl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">pairwise_disjoint_norepet</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">r</span> : <span class="id">reg</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">sl</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">disjoint_temps_not_temp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> <span class="id">r</span> : <span class="id">reg</span>, <span class="id">In</span> <span class="id">r</span> <span class="id">dl</span> -&gt; <span class="id">is_not_temp</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">disjoint_temps_not_temp</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> (<span class="id">parmove2_correctness</span> <span class="id">sl</span> <span class="id">dl</span> <span class="id">H</span> <span class="id">H5</span> <span class="id">H6</span> <span class="id">H7</span> <span class="id">e</span>).<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">e1</span> := <span class="id">exec_seq</span> (<span class="id">parmove2</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e</span>). <span class="tactic">intros</span> [<span class="id">A</span> <span class="id">B</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">srcs_dests_combine</span> <span class="id">sl</span> <span class="id">dl</span> <span class="id">H</span>) <span class="kwd">as</span> [<span class="id">C</span> <span class="id">D</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">env_match</span> (<span class="id">combine</span> <span class="id">sl</span> <span class="id">dl</span>) <span class="id">e1</span> <span class="id">e</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">parmove2</span>. <span class="tactic">unfold</span> <span class="id">e1</span>, <span class="id">e</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">weak_exec_seq_match</span>; <span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">C</span>); <span class="tactic">try</span> (<span class="tactic">rewrite</span> <span class="id">D</span>); <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">C</span>. <span class="tactic">apply</span> <span class="id">parmove_srcs_initial_reg_or_temp</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">D</span>. <span class="tactic">apply</span> <span class="id">parmove_dests_initial_reg_or_temp</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">red</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">A</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_map_exten</span>; <span class="tactic">intros</span>. <span class="tactic">apply</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">no_adherence_dst</span>. <span class="tactic">rewrite</span> <span class="id">D</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">D</span>; <span class="tactic">auto</span>. <span class="tactic">rewrite</span> <span class="id">D</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">transitivity</span> (<span class="id">e1</span> <span class="id">r</span>).<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>. <span class="tactic">apply</span> <span class="id">H8</span>. <span class="tactic">red</span>. <span class="tactic">rewrite</span> <span class="id">D</span>. <span class="tactic">intros</span>. <span class="tactic">destruct</span> <span class="id">H11</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">disjoint_sym</span>. <span class="tactic">apply</span> <span class="id">H9</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">apply</span> <span class="id">disjoint_sym</span>. <span class="tactic">apply</span> <span class="id">H10</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">B</span>. <span class="tactic">apply</span> <span class="id">disjoint_list_notin</span>; <span class="tactic">auto</span>. <span class="tactic">apply</span> <span class="id">disjoint_temps_not_temp</span>; <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">End</span> <span class="id">PARMOV</span>.<br/>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
